// ==UserScript==
// @name         AI工作猎手-让ai帮您找工作！
// @namespace    https://github.com/yangfeng20
// @version      0.0.8-beta
// @author       maple.
// @description  找工作，用AI工作猎手！让AI帮您找工作！ai坐席：【DeepSeek+ChatGpt】赋能，ai助理作为您的求职者分身24小时 * 7在线找工作，并结合您的简历信息定制化回复。批量投递，自动发送简历，交换联系方式。hr拒绝挽留。高意向邮件通知，让您不错过每一份工作机会。BOSS直聘
// @license      Apache License 2.0
// @icon         https://gitee.com/yangfeng20/ai-job/raw/master/file/icon.png
// @downloadURL  https://gitee.com/yangfeng20/ai-job/raw/master/ai-job-hunting.user.js
// @updateURL    https://gitee.com/yangfeng20/ai-job/raw/master/ai-job-hunting.user.js
// @match        https://www.zhipin.com/web/geek/*
// @require      https://cdn.jsdelivr.net/npm/vue@3.4.21/dist/vue.global.prod.js
// @require      https://unpkg.com/vue-demi@latest/lib/index.iife.js
// @require      data:application/javascript,%3Bwindow.Vue%3DVue%3B
// @require      https://cdn.jsdelivr.net/npm/element-plus@2.7.0/dist/index.full.min.js
// @require      https://cdn.jsdelivr.net/npm/protobufjs@7.2.6/dist/protobuf.min.js
// @require      https://cdn.jsdelivr.net/npm/pinia@2.1.7/dist/pinia.iife.prod.js
// @require      https://cdn.jsdelivr.net/npm/event-source-polyfill@1.0.31/src/eventsource.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.14.3/dist/system.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.14.3/dist/extras/named-register.min.js
// @require      data:application/javascript,%3B(typeof%20System!%3D'undefined')%26%26(System%3Dnew%20System.constructor())%3B
// @resource     element-plus/dist/index.css  https://cdn.jsdelivr.net/npm/element-plus@2.7.0/dist/index.css
// @connect      docdownload.zhipin.com
// @grant        GM_addStyle
// @grant        GM_addValueChangeListener
// @grant        GM_getResourceText
// @grant        GM_getValue
// @grant        GM_notification
// @grant        GM_setValue
// @grant        GM_xmlhttpRequest
// @grant        unsafeWindow
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const l=document.createElement("style");l.textContent=e,document.head.append(l)})(` @charset "UTF-8";:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645,.045,.355,1);--el-transition-function-fast-bezier:cubic-bezier(.23,1,.32,1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0,0,0,.04),0px 8px 20px rgba(0,0,0,.08);--el-box-shadow-light:0px 0px 12px rgba(0,0,0,.12);--el-box-shadow-lighter:0px 0px 6px rgba(0,0,0,.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0,0,0,.08),0px 12px 32px rgba(0,0,0,.12),0px 8px 16px -8px rgba(0,0,0,.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0,0,0,.8);--el-overlay-color-light:rgba(0,0,0,.7);--el-overlay-color-lighter:rgba(0,0,0,.5);--el-mask-color:rgba(255,255,255,.9);--el-mask-color-extra-light:rgba(255,255,255,.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.el-icon{--color:inherit;align-items:center;display:inline-flex;height:1em;justify-content:center;line-height:1em;position:relative;width:1em;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255,255,255,.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary);align-items:center;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);border-radius:var(--el-border-radius-base);box-sizing:border-box;color:var(--el-button-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-button-font-weight);height:32px;justify-content:center;line-height:1;outline:none;padding:8px 15px;text-align:center;transition:.1s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-button:hover{background-color:var(--el-button-hover-bg-color);border-color:var(--el-button-hover-border-color);color:var(--el-button-hover-text-color);outline:none}.el-button:active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button>span{align-items:center;display:inline-flex}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button.is-disabled,.el-button.is-disabled:hover{background-color:var(--el-button-disabled-bg-color);background-image:none;border-color:var(--el-button-disabled-border-color);color:var(--el-button-disabled-text-color);cursor:not-allowed}.el-button.is-loading{pointer-events:none;position:relative}.el-button.is-loading:before{background-color:var(--el-mask-color-extra-light);border-radius:inherit;bottom:-1px;content:"";left:-1px;pointer-events:none;position:absolute;right:-1px;top:-1px;z-index:1}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px;width:32px}.el-button.is-text{background-color:transparent;border:0 solid transparent;color:var(--el-button-text-color)}.el-button.is-text.is-disabled{background-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{background:transparent;border-color:transparent;color:var(--el-button-text-color);height:auto;padding:2px}.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-link:not(.is-disabled):hover{background-color:transparent;border-color:transparent}.el-button.is-link:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-button-active-color)}.el-button--text{background:transparent;border-color:transparent;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button--text:not(.is-disabled):hover{background-color:transparent;border-color:transparent;color:var(--el-color-primary-light-3)}.el-button--text:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-color-primary-dark-2)}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8);color:var(--el-color-primary-light-5)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8);color:var(--el-color-success-light-5)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8);color:var(--el-color-warning-light-5)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8);color:var(--el-color-danger-light-5)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8);color:var(--el-color-info-light-5)}.el-button--large{--el-button-size:40px;border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base);height:var(--el-button-size);padding:12px 19px}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{padding:12px;width:var(--el-button-size)}.el-button--small{--el-button-size:24px;border-radius:calc(var(--el-border-radius-base) - 1px);font-size:12px;height:var(--el-button-size);padding:5px 11px}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{padding:5px;width:var(--el-button-size)}:root{--el-menu-active-color:var(--el-color-primary);--el-menu-text-color:var(--el-text-color-primary);--el-menu-hover-text-color:var(--el-color-primary);--el-menu-bg-color:var(--el-fill-color-blank);--el-menu-hover-bg-color:var(--el-color-primary-light-9);--el-menu-item-height:56px;--el-menu-sub-item-height:calc(var(--el-menu-item-height) - 6px);--el-menu-horizontal-height:60px;--el-menu-horizontal-sub-item-height:36px;--el-menu-item-font-size:var(--el-font-size-base);--el-menu-item-hover-fill:var(--el-color-primary-light-9);--el-menu-border-color:var(--el-border-color);--el-menu-base-level-padding:20px;--el-menu-level-padding:20px;--el-menu-icon-width:24px}.el-menu{background-color:var(--el-menu-bg-color);border-right:1px solid var(--el-menu-border-color);box-sizing:border-box;list-style:none;margin:0;padding-left:0;position:relative}.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item-group__title,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-sub-menu__title{padding-left:calc(var(--el-menu-base-level-padding) + var(--el-menu-level)*var(--el-menu-level-padding));white-space:nowrap}.el-menu:not(.el-menu--collapse) .el-sub-menu__title{padding-right:calc(var(--el-menu-base-level-padding) + var(--el-menu-icon-width))}.el-menu--horizontal{border-right:none;display:flex;flex-wrap:nowrap;height:var(--el-menu-horizontal-height)}.el-menu--horizontal.el-menu--popup-container{height:unset}.el-menu--horizontal.el-menu{border-bottom:1px solid var(--el-menu-border-color)}.el-menu--horizontal>.el-menu-item{align-items:center;border-bottom:2px solid transparent;color:var(--el-menu-text-color);display:inline-flex;height:100%;justify-content:center;margin:0}.el-menu--horizontal>.el-menu-item a,.el-menu--horizontal>.el-menu-item a:hover{color:inherit}.el-menu--horizontal>.el-sub-menu:focus,.el-menu--horizontal>.el-sub-menu:hover{outline:none}.el-menu--horizontal>.el-sub-menu:hover .el-sub-menu__title{color:var(--el-menu-hover-text-color)}.el-menu--horizontal>.el-sub-menu.is-active .el-sub-menu__title{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title{border-bottom:2px solid transparent;color:var(--el-menu-text-color);height:100%}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title:hover{background-color:var(--el-menu-bg-color)}.el-menu--horizontal .el-menu .el-menu-item,.el-menu--horizontal .el-menu .el-sub-menu__title{align-items:center;background-color:var(--el-menu-bg-color);color:var(--el-menu-text-color);display:flex;height:var(--el-menu-horizontal-sub-item-height);line-height:var(--el-menu-horizontal-sub-item-height);padding:0 10px}.el-menu--horizontal .el-menu .el-sub-menu__title{padding-right:40px}.el-menu--horizontal .el-menu .el-menu-item.is-active,.el-menu--horizontal .el-menu .el-sub-menu.is-active>.el-sub-menu__title{color:var(--el-menu-active-color)}.el-menu--horizontal .el-menu-item:not(.is-disabled):focus,.el-menu--horizontal .el-menu-item:not(.is-disabled):hover{background-color:var(--el-menu-hover-bg-color);color:var(--el-menu-hover-text-color);outline:none}.el-menu--horizontal>.el-menu-item.is-active{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)!important}.el-menu--collapse{width:calc(var(--el-menu-icon-width) + var(--el-menu-base-level-padding)*2)}.el-menu--collapse>.el-menu-item [class^=el-icon],.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title [class^=el-icon],.el-menu--collapse>.el-sub-menu>.el-sub-menu__title [class^=el-icon]{margin:0;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-menu--collapse>.el-menu-item .el-sub-menu__icon-arrow,.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow{display:none}.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title>span,.el-menu--collapse>.el-menu-item>span,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title>span{display:inline-block;height:0;overflow:hidden;visibility:hidden;width:0}.el-menu--collapse>.el-menu-item.is-active i{color:inherit}.el-menu--collapse .el-menu .el-sub-menu{min-width:200px}.el-menu--collapse .el-sub-menu.is-active .el-sub-menu__title{color:var(--el-menu-active-color)}.el-menu--popup{border:none;border-radius:var(--el-border-radius-small);box-shadow:var(--el-box-shadow-light);min-width:200px;padding:5px 0;z-index:100}.el-menu .el-icon{flex-shrink:0}.el-menu-item{align-items:center;box-sizing:border-box;color:var(--el-menu-text-color);cursor:pointer;display:flex;font-size:var(--el-menu-item-font-size);height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);list-style:none;padding:0 var(--el-menu-base-level-padding);position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);white-space:nowrap}.el-menu-item *{vertical-align:bottom}.el-menu-item i{color:inherit}.el-menu-item:focus,.el-menu-item:hover{outline:none}.el-menu-item:hover{background-color:var(--el-menu-hover-bg-color)}.el-menu-item.is-disabled{background:none!important;cursor:not-allowed;opacity:.25}.el-menu-item [class^=el-icon]{font-size:18px;margin-right:5px;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-menu-item.is-active{color:var(--el-menu-active-color)}.el-menu-item.is-active i{color:inherit}.el-menu-item .el-menu-tooltip__trigger{align-items:center;box-sizing:border-box;display:inline-flex;height:100%;left:0;padding:0 var(--el-menu-base-level-padding);position:absolute;top:0;width:100%}.el-sub-menu{list-style:none;margin:0;padding-left:0}.el-sub-menu__title{align-items:center;box-sizing:border-box;color:var(--el-menu-text-color);cursor:pointer;display:flex;font-size:var(--el-menu-item-font-size);height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);list-style:none;padding:0 var(--el-menu-base-level-padding);position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);white-space:nowrap}.el-sub-menu__title *{vertical-align:bottom}.el-sub-menu__title i{color:inherit}.el-sub-menu__title:focus,.el-sub-menu__title:hover{outline:none}.el-sub-menu__title.is-disabled{background:none!important;cursor:not-allowed;opacity:.25}.el-sub-menu__title:hover{background-color:var(--el-menu-hover-bg-color)}.el-sub-menu .el-menu{border:none}.el-sub-menu .el-menu-item{height:var(--el-menu-sub-item-height);line-height:var(--el-menu-sub-item-height)}.el-sub-menu__hide-arrow .el-sub-menu__icon-arrow{display:none!important}.el-sub-menu.is-active .el-sub-menu__title{border-bottom-color:var(--el-menu-active-color)}.el-sub-menu.is-disabled .el-menu-item,.el-sub-menu.is-disabled .el-sub-menu__title{background:none!important;cursor:not-allowed;opacity:.25}.el-sub-menu .el-icon{font-size:18px;margin-right:5px;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-sub-menu .el-icon.el-sub-menu__icon-more{margin-right:0!important}.el-sub-menu .el-sub-menu__icon-arrow{font-size:12px;margin-right:0;margin-top:-6px;position:absolute;right:var(--el-menu-base-level-padding);top:50%;transition:transform var(--el-transition-duration);width:inherit}.el-menu-item-group>ul{padding:0}.el-menu-item-group__title{color:var(--el-text-color-secondary);font-size:12px;line-height:normal;padding:7px 0 7px var(--el-menu-base-level-padding)}.horizontal-collapse-transition .el-sub-menu__title .el-sub-menu__icon-arrow{opacity:0;transition:var(--el-transition-duration-fast)}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius,4px);border-radius:var(--el-popper-border-radius);font-size:12px;line-height:20px;min-width:10px;overflow-wrap:break-word;padding:5px 11px;position:absolute;visibility:visible;z-index:2000}.el-popper.is-dark{background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary);color:var(--el-bg-color)}.el-popper.is-dark .el-popper__arrow:before{background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow:before{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{height:10px;position:absolute;width:10px;z-index:-1}.el-popper__arrow:before{background:var(--el-text-color-primary);box-sizing:border-box;content:" ";height:10px;position:absolute;transform:rotate(45deg);width:10px;z-index:-1}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent!important;border-top-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{to{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{background:var(--el-popup-modal-bg-color);height:100%;left:0;opacity:var(--el-popup-modal-opacity);position:fixed;top:0;width:100%}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:16px;--el-dialog-border-radius:var(--el-border-radius-small);background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;margin:var(--el-dialog-margin-top,15vh) auto 50px;overflow-wrap:break-word;padding:var(--el-dialog-padding-primary);position:relative;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:none!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;height:100%;margin-bottom:0;overflow:auto}.el-dialog__wrapper{bottom:0;left:0;margin:0;overflow:auto;position:fixed;right:0;top:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding-bottom:var(--el-dialog-padding-primary)}.el-dialog__header.show-close{padding-right:calc(var(--el-dialog-padding-primary) + var(--el-message-close-size, 16px))}.el-dialog__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:48px;outline:none;padding:0;position:absolute;right:0;top:0;width:48px}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{color:var(--el-text-color-primary);font-size:var(--el-dialog-title-font-size);line-height:var(--el-dialog-font-line-height)}.el-dialog__body{color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{box-sizing:border-box;padding-top:var(--el-dialog-padding-primary);text-align:right}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{bottom:0;left:0;overflow:auto;position:fixed;right:0;top:0}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@-webkit-keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@-webkit-keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{background-color:var(--el-overlay-color-lighter);bottom:0;height:100%;left:0;overflow:auto;position:fixed;right:0;top:0;z-index:2000}.el-overlay .el-overlay-root{height:0}.el-image__error,.el-image__inner,.el-image__placeholder,.el-image__wrapper{height:100%;width:100%}.el-image{display:inline-block;overflow:hidden;position:relative}.el-image__inner{opacity:1;vertical-align:top}.el-image__inner.is-loading{opacity:0}.el-image__wrapper{left:0;position:absolute;top:0}.el-image__error,.el-image__placeholder{background:var(--el-fill-color-light)}.el-image__error{align-items:center;color:var(--el-text-color-placeholder);display:flex;font-size:14px;justify-content:center;vertical-align:middle}.el-image__preview{cursor:pointer}.el-image-viewer__wrapper{bottom:0;left:0;position:fixed;right:0;top:0}.el-image-viewer__btn{align-items:center;border-radius:50%;box-sizing:border-box;cursor:pointer;display:flex;justify-content:center;opacity:.8;position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:1}.el-image-viewer__btn .el-icon{cursor:pointer;font-size:inherit}.el-image-viewer__close{font-size:40px;height:40px;right:40px;top:40px;width:40px}.el-image-viewer__canvas{align-items:center;display:flex;height:100%;justify-content:center;position:static;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:100%}.el-image-viewer__actions{background-color:var(--el-text-color-regular);border-color:#fff;border-radius:22px;bottom:30px;height:44px;left:50%;padding:0 23px;transform:translate(-50%);width:282px}.el-image-viewer__actions__inner{align-items:center;color:#fff;cursor:default;display:flex;font-size:23px;height:100%;justify-content:space-around;width:100%}.el-image-viewer__prev{left:40px}.el-image-viewer__next,.el-image-viewer__prev{background-color:var(--el-text-color-regular);border-color:#fff;color:#fff;font-size:24px;height:44px;top:50%;transform:translateY(-50%);width:44px}.el-image-viewer__next{right:40px;text-indent:2px}.el-image-viewer__close{background-color:var(--el-text-color-regular);border-color:#fff;color:#fff;font-size:24px;height:44px;width:44px}.el-image-viewer__mask{background:#000;height:100%;left:0;opacity:.5;position:absolute;top:0;width:100%}.viewer-fade-enter-active{-webkit-animation:viewer-fade-in var(--el-transition-duration);animation:viewer-fade-in var(--el-transition-duration)}.viewer-fade-leave-active{-webkit-animation:viewer-fade-out var(--el-transition-duration);animation:viewer-fade-out var(--el-transition-duration)}@-webkit-keyframes viewer-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes viewer-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@-webkit-keyframes viewer-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@keyframes viewer-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;font-size:var(--el-font-size-base);position:relative;vertical-align:bottom;width:100%}.el-textarea__inner{-webkit-appearance:none;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));display:block;font-family:inherit;font-size:inherit;line-height:1.5;padding:5px 11px;position:relative;resize:vertical;transition:var(--el-transition-box-shadow);width:100%}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset;outline:none}.el-textarea .el-input__count{background:var(--el-fill-color-blank);bottom:5px;color:var(--el-color-info);font-size:12px;line-height:14px;position:absolute;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;--el-input-height:var(--el-component-size);box-sizing:border-box;display:inline-flex;font-size:var(--el-font-size-base);line-height:var(--el-input-height);position:relative;vertical-align:middle;width:var(--el-input-width)}.el-input::-webkit-scrollbar{width:6px;z-index:11}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{background:var(--el-text-color-disabled);border-radius:5px;width:6px}.el-input::-webkit-scrollbar-corner,.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);cursor:pointer;font-size:14px}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{align-items:center;color:var(--el-color-info);display:inline-flex;font-size:12px;height:100%}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);display:inline-block;line-height:normal;padding-left:8px}.el-input__wrapper{align-items:center;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;cursor:text;display:inline-flex;flex-grow:1;justify-content:center;padding:1px 11px;transform:translateZ(0);transition:var(--el-transition-box-shadow)}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);-webkit-appearance:none;background:none;border:none;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));flex-grow:1;font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);outline:none;padding:0;width:100%}.el-input__inner:focus{outline:none}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__prefix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__suffix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{align-items:center;display:flex;height:inherit;justify-content:center;line-height:inherit;margin-left:8px;transition:all var(--el-transition-duration)}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color, ) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{align-items:stretch;display:inline-flex;width:100%}.el-input-group__append,.el-input-group__prepend{align-items:center;background-color:var(--el-fill-color-light);border-radius:var(--el-input-border-radius);color:var(--el-color-info);display:inline-flex;justify-content:center;min-height:100%;padding:0 20px;position:relative;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:none}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{background-color:transparent;border-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-bottom-right-radius:0;border-right:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-bottom-left-radius:0;border-left:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-bottom-left-radius:0;border-top-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-bottom-right-radius:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-bottom-right-radius:0;border-top-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-bottom-left-radius:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-hidden{display:none!important}.el-table{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-bg-color);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0,0,0,.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0,0,0,.15);--el-table-index:var(--el-index-normal);background-color:var(--el-table-bg-color);box-sizing:border-box;color:var(--el-table-text-color);font-size:14px;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;max-width:100%;overflow:hidden;position:relative;width:100%}.el-table__inner-wrapper{display:flex;flex-direction:column;height:100%;position:relative}.el-table__inner-wrapper:before{bottom:0;height:1px;left:0;width:100%}.el-table tbody:focus-visible{outline:none}.el-table.has-footer.el-table--fluid-height tr:last-child td.el-table__cell,.el-table.has-footer.el-table--scrollable-y tr:last-child td.el-table__cell{border-bottom-color:transparent}.el-table__empty-block{align-items:center;display:flex;justify-content:center;left:0;min-height:60px;position:-webkit-sticky;position:sticky;text-align:center;width:100%}.el-table__empty-text{color:var(--el-text-color-secondary);line-height:60px;width:50%}.el-table__expand-column .cell{padding:0;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table__expand-icon{color:var(--el-text-color-regular);cursor:pointer;font-size:12px;height:20px;position:relative;transition:transform var(--el-transition-duration-fast) ease-in-out}.el-table__expand-icon--expanded{transform:rotate(90deg)}.el-table__expand-icon>.el-icon{font-size:12px}.el-table__expanded-cell{background-color:var(--el-table-expanded-cell-bg-color)}.el-table__expanded-cell[class*=cell]{padding:20px 50px}.el-table__expanded-cell:hover{background-color:transparent!important}.el-table__placeholder{display:inline-block;width:20px}.el-table__append-wrapper{overflow:hidden}.el-table--fit{border-bottom:0;border-right:0}.el-table--fit .el-table__cell.gutter{border-right-width:1px}.el-table thead{color:var(--el-table-header-text-color)}.el-table thead th{font-weight:600}.el-table thead.is-group th.el-table__cell{background:var(--el-fill-color-light)}.el-table .el-table__cell{box-sizing:border-box;min-width:0;padding:8px 0;position:relative;text-align:left;text-overflow:ellipsis;vertical-align:middle;z-index:var(--el-table-index)}.el-table .el-table__cell.is-center{text-align:center}.el-table .el-table__cell.is-right{text-align:right}.el-table .el-table__cell.gutter{border-bottom-width:0;border-right-width:0;padding:0;width:15px}.el-table .el-table__cell.is-hidden>*{visibility:hidden}.el-table .cell{box-sizing:border-box;line-height:23px;overflow:hidden;overflow-wrap:break-word;padding:0 12px;text-overflow:ellipsis;white-space:normal}.el-table .cell.el-tooltip{min-width:50px;white-space:nowrap}.el-table--large{font-size:var(--el-font-size-base)}.el-table--large .el-table__cell{padding:12px 0}.el-table--large .cell{padding:0 16px}.el-table--default{font-size:14px}.el-table--default .el-table__cell{padding:8px 0}.el-table--default .cell{padding:0 12px}.el-table--small{font-size:12px}.el-table--small .el-table__cell{padding:4px 0}.el-table--small .cell{padding:0 8px}.el-table tr{background-color:var(--el-table-tr-bg-color)}.el-table tr input[type=checkbox]{margin:0}.el-table td.el-table__cell,.el-table th.el-table__cell.is-leaf{border-bottom:var(--el-table-border)}.el-table th.el-table__cell.is-sortable{cursor:pointer}.el-table th.el-table__cell{background-color:var(--el-table-header-bg-color);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table th.el-table__cell>.cell.highlight{color:var(--el-color-primary)}.el-table th.el-table__cell.required>div:before{background:#ff4d51;border-radius:50%;content:"";display:inline-block;height:8px;margin-right:5px;vertical-align:middle;width:8px}.el-table td.el-table__cell div{box-sizing:border-box}.el-table td.el-table__cell.gutter{width:0}.el-table--border .el-table__inner-wrapper:after,.el-table--border:after,.el-table--border:before,.el-table__inner-wrapper:before{background-color:var(--el-table-border-color);content:"";position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table--border .el-table__inner-wrapper:after{height:1px;left:0;top:0;width:100%;z-index:calc(var(--el-table-index) + 2)}.el-table--border:before{height:100%;left:0;top:-1px;width:1px}.el-table--border:after{height:100%;right:0;top:-1px;width:1px}.el-table--border .el-table__inner-wrapper{border-bottom:none;border-right:none}.el-table--border .el-table__footer-wrapper{flex-shrink:0;position:relative}.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table--border th.el-table__cell.gutter:last-of-type{border-bottom:var(--el-table-border);border-bottom-width:1px}.el-table--border th.el-table__cell{border-bottom:var(--el-table-border)}.el-table--hidden{visibility:hidden}.el-table__body-wrapper,.el-table__footer-wrapper,.el-table__header-wrapper{width:100%}.el-table__body-wrapper tr td.el-table-fixed-column--left,.el-table__body-wrapper tr td.el-table-fixed-column--right,.el-table__body-wrapper tr th.el-table-fixed-column--left,.el-table__body-wrapper tr th.el-table-fixed-column--right,.el-table__footer-wrapper tr td.el-table-fixed-column--left,.el-table__footer-wrapper tr td.el-table-fixed-column--right,.el-table__footer-wrapper tr th.el-table-fixed-column--left,.el-table__footer-wrapper tr th.el-table-fixed-column--right,.el-table__header-wrapper tr td.el-table-fixed-column--left,.el-table__header-wrapper tr td.el-table-fixed-column--right,.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background:inherit;position:-webkit-sticky!important;position:sticky!important;z-index:calc(var(--el-table-index) + 1)}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{bottom:-1px;box-shadow:none;content:"";overflow-x:hidden;overflow-y:hidden;pointer-events:none;position:absolute;top:0;touch-action:none;width:10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before{left:-10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{box-shadow:none;right:-10px}.el-table__body-wrapper tr td.el-table__fixed-right-patch,.el-table__body-wrapper tr th.el-table__fixed-right-patch,.el-table__footer-wrapper tr td.el-table__fixed-right-patch,.el-table__footer-wrapper tr th.el-table__fixed-right-patch,.el-table__header-wrapper tr td.el-table__fixed-right-patch,.el-table__header-wrapper tr th.el-table__fixed-right-patch{background:#fff;position:-webkit-sticky!important;position:sticky!important;right:0;z-index:calc(var(--el-table-index) + 1)}.el-table__header-wrapper{flex-shrink:0}.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body,.el-table__footer,.el-table__header{border-collapse:separate;table-layout:fixed}.el-table__header-wrapper{overflow:hidden}.el-table__header-wrapper tbody td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__footer-wrapper{flex-shrink:0;overflow:hidden}.el-table__footer-wrapper tfoot td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__body-wrapper .el-table-column--selection>.cell,.el-table__header-wrapper .el-table-column--selection>.cell{align-items:center;display:inline-flex;height:23px}.el-table__body-wrapper .el-table-column--selection .el-checkbox,.el-table__header-wrapper .el-table-column--selection .el-checkbox{height:unset}.el-table.is-scrolling-left .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-left.el-table--border .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:var(--el-table-border)}.el-table.is-scrolling-left th.el-table-fixed-column--left{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-right th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-middle .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-none .el-table-fixed-column--left.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--left.is-last-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-last-column:before{box-shadow:none}.el-table.is-scrolling-none th.el-table-fixed-column--left,.el-table.is-scrolling-none th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body-wrapper{flex:1;overflow:hidden;position:relative}.el-table__body-wrapper .el-scrollbar__bar{z-index:calc(var(--el-table-index) + 2)}.el-table .caret-wrapper{align-items:center;cursor:pointer;display:inline-flex;flex-direction:column;height:14px;overflow:initial;position:relative;vertical-align:middle;width:24px}.el-table .sort-caret{border:5px solid transparent;height:0;left:7px;position:absolute;width:0}.el-table .sort-caret.ascending{border-bottom-color:var(--el-text-color-placeholder);top:-5px}.el-table .sort-caret.descending{border-top-color:var(--el-text-color-placeholder);bottom:-3px}.el-table .ascending .sort-caret.ascending{border-bottom-color:var(--el-color-primary)}.el-table .descending .sort-caret.descending{border-top-color:var(--el-color-primary)}.el-table .hidden-columns{position:absolute;visibility:hidden;z-index:-1}.el-table--striped .el-table__body tr.el-table__row--striped td.el-table__cell{background:var(--el-fill-color-lighter)}.el-table--striped .el-table__body tr.el-table__row--striped.current-row td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__body tr.hover-row.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped>td.el-table__cell,.el-table__body tr.hover-row>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr>td.hover-cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr.current-row>td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table.el-table--scrollable-y .el-table__body-header{position:-webkit-sticky;position:sticky;top:0;z-index:calc(var(--el-table-index) + 2)}.el-table.el-table--scrollable-y .el-table__body-footer{bottom:0;position:-webkit-sticky;position:sticky;z-index:calc(var(--el-table-index) + 2)}.el-table__column-resize-proxy{border-left:var(--el-table-border);bottom:0;left:200px;position:absolute;top:0;width:0;z-index:calc(var(--el-table-index) + 9)}.el-table__column-filter-trigger{cursor:pointer;display:inline-block}.el-table__column-filter-trigger i{color:var(--el-color-info);font-size:14px;vertical-align:middle}.el-table__border-left-patch{height:100%;top:0;width:1px}.el-table__border-bottom-patch,.el-table__border-left-patch{background-color:var(--el-table-border-color);left:0;position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table__border-bottom-patch{height:1px}.el-table__border-right-patch{background-color:var(--el-table-border-color);height:100%;position:absolute;top:0;width:1px;z-index:calc(var(--el-table-index) + 2)}.el-table--enable-row-transition .el-table__body td.el-table__cell{transition:background-color .25s ease}.el-table--enable-row-hover .el-table__body tr:hover>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table [class*=el-table__row--level] .el-table__expand-icon{display:inline-block;height:12px;line-height:12px;margin-right:8px;text-align:center;width:12px}.el-table .el-table.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table:not(.el-table--border) .el-table__cell{border-right:none}.el-table:not(.el-table--border)>.el-table__inner-wrapper:after{content:none}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary);align-items:center;color:var(--el-checkbox-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-checkbox-font-weight);height:var(--el-checkbox-height,32px);margin-right:30px;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{border:var(--el-border);border-radius:var(--el-border-radius-base);box-sizing:border-box;padding:0 15px 0 9px}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{border-radius:var(--el-border-radius-base);padding:0 19px 0 11px}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{border-radius:calc(var(--el-border-radius-base) - 1px);padding:0 11px 0 7px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{border-radius:var(--el-checkbox-border-radius);outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px}.el-checkbox__input{cursor:pointer;display:inline-flex;outline:none;position:relative;white-space:nowrap}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-icon-color);cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-checked-icon-color);transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-checked-icon-color);content:"";display:block;height:2px;left:0;position:absolute;right:0;top:5px;transform:scale(.5)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{background-color:var(--el-checkbox-bg-color);border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;display:inline-block;height:var(--el-checkbox-input-height);position:relative;transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46);width:var(--el-checkbox-input-width);z-index:var(--el-index-normal)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{border:1px solid transparent;border-left:0;border-top:0;box-sizing:content-box;content:"";height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);transform-origin:center;transition:transform .15s ease-in .05s;width:3px}.el-checkbox__original{height:0;margin:0;opacity:0;outline:none;position:absolute;width:0;z-index:-1}.el-checkbox__label{display:inline-block;font-size:var(--el-checkbox-font-size);line-height:1;padding-left:8px}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox:last-of-type{margin-right:0}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary);height:100%;overflow:hidden;position:relative}.el-scrollbar__wrap{height:100%;overflow:auto}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));border-radius:inherit;cursor:pointer;display:block;height:0;opacity:var(--el-scrollbar-opacity,.3);position:relative;transition:var(--el-transition-duration) background-color;width:0}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{border-radius:4px;bottom:2px;position:absolute;right:2px;z-index:1}.el-scrollbar__bar.is-vertical{top:2px;width:6px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px;--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);align-items:center;background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);border-radius:var(--el-tag-border-radius);border-style:solid;border-width:1px;box-sizing:border-box;color:var(--el-tag-text-color);display:inline-flex;font-size:var(--el-tag-font-size);height:24px;justify-content:center;line-height:1;padding:0 9px;vertical-align:middle;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color);flex-shrink:0}.el-tag .el-tag__close:hover{background-color:var(--el-tag-hover-color);color:var(--el-color-white)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info,.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{height:32px;padding:0 11px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{height:20px;padding:0 7px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-table-column--selection .cell{padding-left:14px;padding-right:14px}.el-table-filter{background-color:#fff;border:1px solid var(--el-border-color-lighter);border-radius:2px;box-shadow:var(--el-box-shadow-light);box-sizing:border-box}.el-table-filter__list{list-style:none;margin:0;min-width:100px;padding:5px 0}.el-table-filter__list-item{cursor:pointer;font-size:var(--el-font-size-base);line-height:36px;padding:0 10px}.el-table-filter__list-item:hover{background-color:var(--el-color-primary-light-9);color:var(--el-color-primary)}.el-table-filter__list-item.is-active{background-color:var(--el-color-primary);color:#fff}.el-table-filter__content{min-width:100px}.el-table-filter__bottom{border-top:1px solid var(--el-border-color-lighter);padding:8px}.el-table-filter__bottom button{background:transparent;border:none;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-small);padding:0 3px}.el-table-filter__bottom button:hover{color:var(--el-color-primary)}.el-table-filter__bottom button:focus{outline:none}.el-table-filter__bottom button.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-table-filter__wrap{max-height:280px}.el-table-filter__checkbox-group{padding:10px}.el-table-filter__checkbox-group label.el-checkbox{align-items:center;display:flex;height:unset;margin-bottom:12px;margin-left:5px;margin-right:5px}.el-table-filter__checkbox-group .el-checkbox:last-child{margin-bottom:0}.el-link{--el-link-font-size:var(--el-font-size-base);--el-link-font-weight:var(--el-font-weight-primary);--el-link-text-color:var(--el-text-color-regular);--el-link-hover-text-color:var(--el-color-primary);--el-link-disabled-text-color:var(--el-text-color-placeholder);align-items:center;color:var(--el-link-text-color);cursor:pointer;display:inline-flex;flex-direction:row;font-size:var(--el-link-font-size);font-weight:var(--el-link-font-weight);justify-content:center;outline:none;padding:0;position:relative;text-decoration:none;vertical-align:middle}.el-link:hover{color:var(--el-link-hover-text-color)}.el-link.is-underline:hover:after{border-bottom:1px solid var(--el-link-hover-text-color);bottom:0;content:"";height:0;left:0;position:absolute;right:0}.el-link.is-disabled{color:var(--el-link-disabled-text-color);cursor:not-allowed}.el-link [class*=el-icon-]+span{margin-left:5px}.el-link.el-link--default:after{border-color:var(--el-link-hover-text-color)}.el-link__inner{align-items:center;display:inline-flex;justify-content:center}.el-link.el-link--primary{--el-link-text-color:var(--el-color-primary);--el-link-hover-text-color:var(--el-color-primary-light-3);--el-link-disabled-text-color:var(--el-color-primary-light-5)}.el-link.el-link--primary:after{border-color:var(--el-link-text-color)}.el-link.el-link--primary.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--success{--el-link-text-color:var(--el-color-success);--el-link-hover-text-color:var(--el-color-success-light-3);--el-link-disabled-text-color:var(--el-color-success-light-5)}.el-link.el-link--success:after{border-color:var(--el-link-text-color)}.el-link.el-link--success.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning{--el-link-text-color:var(--el-color-warning);--el-link-hover-text-color:var(--el-color-warning-light-3);--el-link-disabled-text-color:var(--el-color-warning-light-5)}.el-link.el-link--warning:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger{--el-link-text-color:var(--el-color-danger);--el-link-hover-text-color:var(--el-color-danger-light-3);--el-link-disabled-text-color:var(--el-color-danger-light-5)}.el-link.el-link--danger:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--error{--el-link-text-color:var(--el-color-error);--el-link-hover-text-color:var(--el-color-error-light-3);--el-link-disabled-text-color:var(--el-color-error-light-5)}.el-link.el-link--error:after{border-color:var(--el-link-text-color)}.el-link.el-link--error.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--info{--el-link-text-color:var(--el-color-info);--el-link-hover-text-color:var(--el-color-info-light-3);--el-link-disabled-text-color:var(--el-color-info-light-5)}.el-link.el-link--info:after{border-color:var(--el-link-text-color)}.el-link.el-link--info.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-switch{--el-switch-on-color:var(--el-color-primary);--el-switch-off-color:var(--el-border-color);align-items:center;display:inline-flex;font-size:14px;height:32px;line-height:20px;position:relative;vertical-align:middle}.el-switch.is-disabled .el-switch__core,.el-switch.is-disabled .el-switch__label{cursor:not-allowed}.el-switch__label{color:var(--el-text-color-primary);cursor:pointer;display:inline-block;font-size:14px;font-weight:500;height:20px;transition:var(--el-transition-duration-fast);vertical-align:middle}.el-switch__label.is-active{color:var(--el-color-primary)}.el-switch__label--left{margin-right:10px}.el-switch__label--right{margin-left:10px}.el-switch__label *{display:inline-block;font-size:14px;line-height:1}.el-switch__label .el-icon{height:inherit}.el-switch__label .el-icon svg{vertical-align:middle}.el-switch__input{height:0;margin:0;opacity:0;position:absolute;width:0}.el-switch__input:focus-visible~.el-switch__core{outline:2px solid var(--el-switch-on-color);outline-offset:1px}.el-switch__core{align-items:center;background:var(--el-switch-off-color);border:1px solid var(--el-switch-border-color,var(--el-switch-off-color));border-radius:10px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:20px;min-width:40px;outline:none;position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration)}.el-switch__core .el-switch__inner{align-items:center;display:flex;height:16px;justify-content:center;overflow:hidden;padding:0 4px 0 18px;transition:all var(--el-transition-duration);width:100%}.el-switch__core .el-switch__inner .is-icon,.el-switch__core .el-switch__inner .is-text{color:var(--el-color-white);font-size:12px;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.el-switch__core .el-switch__action{align-items:center;background-color:var(--el-color-white);border-radius:var(--el-border-radius-circle);color:var(--el-switch-off-color);display:flex;height:16px;justify-content:center;left:1px;position:absolute;transition:all var(--el-transition-duration);width:16px}.el-switch.is-checked .el-switch__core{background-color:var(--el-switch-on-color);border-color:var(--el-switch-border-color,var(--el-switch-on-color))}.el-switch.is-checked .el-switch__core .el-switch__action{color:var(--el-switch-on-color);left:calc(100% - 17px)}.el-switch.is-checked .el-switch__core .el-switch__inner{padding:0 18px 0 4px}.el-switch.is-disabled{opacity:.6}.el-switch--wide .el-switch__label.el-switch__label--left span{left:10px}.el-switch--wide .el-switch__label.el-switch__label--right span{right:10px}.el-switch .label-fade-enter-from,.el-switch .label-fade-leave-active{opacity:0}.el-switch--large{font-size:14px;height:40px;line-height:24px}.el-switch--large .el-switch__label{font-size:14px;height:24px}.el-switch--large .el-switch__label *{font-size:14px}.el-switch--large .el-switch__core{border-radius:12px;height:24px;min-width:50px}.el-switch--large .el-switch__core .el-switch__inner{height:20px;padding:0 6px 0 22px}.el-switch--large .el-switch__core .el-switch__action{height:20px;width:20px}.el-switch--large.is-checked .el-switch__core .el-switch__action{left:calc(100% - 21px)}.el-switch--large.is-checked .el-switch__core .el-switch__inner{padding:0 22px 0 6px}.el-switch--small{font-size:12px;height:24px;line-height:16px}.el-switch--small .el-switch__label{font-size:12px;height:16px}.el-switch--small .el-switch__label *{font-size:12px}.el-switch--small .el-switch__core{border-radius:8px;height:16px;min-width:30px}.el-switch--small .el-switch__core .el-switch__inner{height:12px;padding:0 2px 0 14px}.el-switch--small .el-switch__core .el-switch__action{height:12px;width:12px}.el-switch--small.is-checked .el-switch__core .el-switch__action{left:calc(100% - 13px)}.el-switch--small.is-checked .el-switch__core .el-switch__inner{padding:0 14px 0 2px}.el-input-number{display:inline-flex;line-height:30px;position:relative;width:150px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;line-height:1;text-align:center}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-input-number__decrease,.el-input-number__increase{align-items:center;background:var(--el-fill-color-light);bottom:1px;color:var(--el-text-color-regular);cursor:pointer;display:flex;font-size:13px;height:auto;justify-content:center;position:absolute;top:1px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:32px;z-index:1}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{border-left:var(--el-border);border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;right:1px}.el-input-number__decrease{border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border);left:1px}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{line-height:38px;width:180px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{font-size:14px;width:40px}.el-input-number--large .el-input--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{line-height:22px;width:120px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{font-size:12px;width:24px}.el-input-number--small .el-input--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{border-bottom:var(--el-border);border-radius:0 var(--el-border-radius-base) 0 0;bottom:auto;left:auto}.el-input-number.is-controls-right .el-input-number__decrease{border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0;border-right:none;left:auto;right:1px;top:auto}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-text{--el-text-font-size:var(--el-font-size-base);--el-text-color:var(--el-text-color-regular);align-self:center;color:var(--el-text-color);font-size:var(--el-text-font-size);margin:0;overflow-wrap:break-word;padding:0}.el-text.is-truncated{display:inline-block;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-text.is-line-clamp{display:-webkit-inline-box;-webkit-box-orient:vertical;overflow:hidden}.el-text--large{--el-text-font-size:var(--el-font-size-medium)}.el-text--default{--el-text-font-size:var(--el-font-size-base)}.el-text--small{--el-text-font-size:var(--el-font-size-extra-small)}.el-text.el-text--primary{--el-text-color:var(--el-color-primary)}.el-text.el-text--success{--el-text-color:var(--el-color-success)}.el-text.el-text--warning{--el-text-color:var(--el-color-warning)}.el-text.el-text--danger{--el-text-color:var(--el-color-danger)}.el-text.el-text--error{--el-text-color:var(--el-color-error)}.el-text.el-text--info{--el-text-color:var(--el-color-info)}.el-text>.el-icon{vertical-align:-2px}.my-header[data-v-382b5e09]{display:flex;flex-direction:row;justify-content:space-between;gap:16px}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--label-left .el-form-item__label{justify-content:flex-start}.el-form--label-top .el-form-item{display:block}.el-form--label-top .el-form-item .el-form-item__label{display:block;height:auto;line-height:22px;margin-bottom:8px;text-align:left}.el-form--inline .el-form-item{display:inline-flex;margin-right:32px;vertical-align:middle}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form--large.el-form--label-top .el-form-item .el-form-item__label{line-height:22px;margin-bottom:12px}.el-form--default.el-form--label-top .el-form-item .el-form-item__label{line-height:22px;margin-bottom:8px}.el-form--small.el-form--label-top .el-form-item .el-form-item__label{line-height:20px;margin-bottom:4px}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item__label-wrap{display:flex}.el-form-item__label{align-items:flex-start;box-sizing:border-box;color:var(--el-text-color-regular);display:inline-flex;flex:0 0 auto;font-size:var(--el-form-label-font-size);height:32px;justify-content:flex-end;line-height:32px;padding:0 12px 0 0}.el-form-item__content{align-items:center;display:flex;flex:1;flex-wrap:wrap;font-size:var(--font-size);line-height:32px;min-width:0;position:relative}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;left:0;line-height:1;padding-top:2px;position:absolute;top:100%}.el-form-item__error--inline{display:inline-block;left:auto;margin-left:10px;position:relative;top:auto}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{color:var(--el-color-danger);content:"*";margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{color:var(--el-color-danger);content:"*";margin-left:4px}.el-form-item.is-error .el-input__wrapper,.el-form-item.is-error .el-input__wrapper.is-focus,.el-form-item.is-error .el-input__wrapper:focus,.el-form-item.is-error .el-input__wrapper:hover,.el-form-item.is-error .el-select__wrapper,.el-form-item.is-error .el-select__wrapper.is-focus,.el-form-item.is-error .el-select__wrapper:focus,.el-form-item.is-error .el-select__wrapper:hover,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner.is-focus,.el-form-item.is-error .el-textarea__inner:focus,.el-form-item.is-error .el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:inset 0 0 0 1px transparent}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-upload{--el-upload-dragger-padding-horizontal:40px;--el-upload-dragger-padding-vertical:10px;align-items:center;cursor:pointer;display:inline-flex;justify-content:center;outline:none}.el-upload__input{display:none}.el-upload__tip{color:var(--el-text-color-regular);font-size:12px;margin-top:7px}.el-upload iframe{filter:alpha(opacity=0);left:0;opacity:0;position:absolute;top:0;z-index:-1}.el-upload--picture-card{--el-upload-picture-card-size:148px;align-items:center;background-color:var(--el-fill-color-lighter);border:1px dashed var(--el-border-color-darker);border-radius:6px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:var(--el-upload-picture-card-size);justify-content:center;vertical-align:top;width:var(--el-upload-picture-card-size)}.el-upload--picture-card>i{color:var(--el-text-color-secondary);font-size:28px}.el-upload--picture-card:hover{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload.is-drag{display:block}.el-upload:focus{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload:focus .el-upload-dragger{border-color:var(--el-color-primary)}.el-upload-dragger{background-color:var(--el-fill-color-blank);border:1px dashed var(--el-border-color);border-radius:6px;box-sizing:border-box;cursor:pointer;overflow:hidden;padding:var(--el-upload-dragger-padding-horizontal) var(--el-upload-dragger-padding-vertical);position:relative;text-align:center}.el-upload-dragger .el-icon--upload{color:var(--el-text-color-placeholder);font-size:67px;line-height:50px;margin-bottom:16px}.el-upload-dragger+.el-upload__tip{text-align:center}.el-upload-dragger~.el-upload__files{border-top:var(--el-border);margin-top:7px;padding-top:5px}.el-upload-dragger .el-upload__text{color:var(--el-text-color-regular);font-size:14px;text-align:center}.el-upload-dragger .el-upload__text em{color:var(--el-color-primary);font-style:normal}.el-upload-dragger:hover{border-color:var(--el-color-primary)}.el-upload-dragger.is-dragover{background-color:var(--el-color-primary-light-9);border:2px dashed var(--el-color-primary);padding:calc(var(--el-upload-dragger-padding-horizontal) - 1px) calc(var(--el-upload-dragger-padding-vertical) - 1px)}.el-upload-list{list-style:none;margin:10px 0 0;padding:0;position:relative}.el-upload-list__item{border-radius:4px;box-sizing:border-box;color:var(--el-text-color-regular);font-size:14px;margin-bottom:5px;position:relative;transition:all .5s cubic-bezier(.55,0,.1,1);width:100%}.el-upload-list__item .el-progress{position:absolute;top:20px;width:100%}.el-upload-list__item .el-progress__text{position:absolute;right:0;top:-13px}.el-upload-list__item .el-progress-bar{margin-right:0;padding-right:0}.el-upload-list__item .el-icon--upload-success{color:var(--el-color-success)}.el-upload-list__item .el-icon--close{color:var(--el-text-color-regular);cursor:pointer;display:none;opacity:.75;position:absolute;right:5px;top:50%;transform:translateY(-50%);transition:opacity var(--el-transition-duration)}.el-upload-list__item .el-icon--close:hover{color:var(--el-color-primary);opacity:1}.el-upload-list__item .el-icon--close-tip{color:var(--el-color-primary);cursor:pointer;display:none;font-size:12px;font-style:normal;opacity:1;position:absolute;right:5px;top:1px}.el-upload-list__item:hover{background-color:var(--el-fill-color-light)}.el-upload-list__item:hover .el-icon--close{display:inline-flex}.el-upload-list__item:hover .el-progress__text{display:none}.el-upload-list__item .el-upload-list__item-info{display:inline-flex;flex-direction:column;justify-content:center;margin-left:4px;width:calc(100% - 30px)}.el-upload-list__item.is-success .el-upload-list__item-status-label{display:inline-flex}.el-upload-list__item.is-success .el-upload-list__item-name:focus,.el-upload-list__item.is-success .el-upload-list__item-name:hover{color:var(--el-color-primary);cursor:pointer}.el-upload-list__item.is-success:focus:not(:hover) .el-icon--close-tip{display:inline-block}.el-upload-list__item.is-success:active,.el-upload-list__item.is-success:not(.focusing):focus{outline-width:0}.el-upload-list__item.is-success:active .el-icon--close-tip,.el-upload-list__item.is-success:not(.focusing):focus .el-icon--close-tip{display:none}.el-upload-list__item.is-success:focus .el-upload-list__item-status-label,.el-upload-list__item.is-success:hover .el-upload-list__item-status-label{display:none;opacity:0}.el-upload-list__item-name{align-items:center;color:var(--el-text-color-regular);display:inline-flex;font-size:var(--el-font-size-base);padding:0 4px;text-align:center;transition:color var(--el-transition-duration)}.el-upload-list__item-name .el-icon{color:var(--el-text-color-secondary);margin-right:6px}.el-upload-list__item-file-name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-upload-list__item-status-label{align-items:center;display:none;height:100%;justify-content:center;line-height:inherit;position:absolute;right:5px;top:0;transition:opacity var(--el-transition-duration)}.el-upload-list__item-delete{color:var(--el-text-color-regular);display:none;font-size:12px;position:absolute;right:10px;top:0}.el-upload-list__item-delete:hover{color:var(--el-color-primary)}.el-upload-list--picture-card{--el-upload-list-picture-card-size:148px;display:inline-flex;flex-wrap:wrap;margin:0}.el-upload-list--picture-card .el-upload-list__item{background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;display:inline-flex;height:var(--el-upload-list-picture-card-size);margin:0 8px 8px 0;overflow:hidden;padding:0;width:var(--el-upload-list-picture-card-size)}.el-upload-list--picture-card .el-upload-list__item .el-icon--check,.el-upload-list--picture-card .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture-card .el-upload-list__item .el-icon--close{display:none}.el-upload-list--picture-card .el-upload-list__item:hover .el-upload-list__item-status-label{display:block;opacity:0}.el-upload-list--picture-card .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture-card .el-upload-list__item .el-upload-list__item-name{display:none}.el-upload-list--picture-card .el-upload-list__item-thumbnail{height:100%;-o-object-fit:contain;object-fit:contain;width:100%}.el-upload-list--picture-card .el-upload-list__item-status-label{background:var(--el-color-success);height:24px;right:-15px;text-align:center;top:-6px;transform:rotate(45deg);width:40px}.el-upload-list--picture-card .el-upload-list__item-status-label i{font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-list--picture-card .el-upload-list__item-actions{align-items:center;background-color:var(--el-overlay-color-lighter);color:#fff;cursor:default;display:inline-flex;font-size:20px;height:100%;justify-content:center;left:0;opacity:0;position:absolute;top:0;transition:opacity var(--el-transition-duration);width:100%}.el-upload-list--picture-card .el-upload-list__item-actions span{cursor:pointer;display:none}.el-upload-list--picture-card .el-upload-list__item-actions span+span{margin-left:1rem}.el-upload-list--picture-card .el-upload-list__item-actions .el-upload-list__item-delete{color:inherit;font-size:inherit;position:static}.el-upload-list--picture-card .el-upload-list__item-actions:hover{opacity:1}.el-upload-list--picture-card .el-upload-list__item-actions:hover span{display:inline-flex}.el-upload-list--picture-card .el-progress{bottom:auto;left:50%;top:50%;transform:translate(-50%,-50%);width:126px}.el-upload-list--picture-card .el-progress .el-progress__text{top:50%}.el-upload-list--picture .el-upload-list__item{align-items:center;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;display:flex;margin-top:10px;overflow:hidden;padding:10px;z-index:0}.el-upload-list--picture .el-upload-list__item .el-icon--check,.el-upload-list--picture .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture .el-upload-list__item:hover .el-upload-list__item-status-label{display:inline-flex;opacity:0}.el-upload-list--picture .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture .el-upload-list__item.is-success .el-upload-list__item-name i{display:none}.el-upload-list--picture .el-upload-list__item .el-icon--close{top:5px;transform:translateY(0)}.el-upload-list--picture .el-upload-list__item-thumbnail{align-items:center;background-color:var(--el-color-white);display:inline-flex;height:70px;justify-content:center;-o-object-fit:contain;object-fit:contain;position:relative;width:70px;z-index:1}.el-upload-list--picture .el-upload-list__item-status-label{background:var(--el-color-success);height:26px;position:absolute;right:-17px;text-align:center;top:-7px;transform:rotate(45deg);width:46px}.el-upload-list--picture .el-upload-list__item-status-label i{font-size:12px;margin-top:12px;transform:rotate(-45deg)}.el-upload-list--picture .el-progress{position:relative;top:-7px}.el-upload-cover{cursor:default;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:10}.el-upload-cover:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-upload-cover img{display:block;height:100%;width:100%}.el-upload-cover__label{background:var(--el-color-success);height:24px;right:-15px;text-align:center;top:-6px;transform:rotate(45deg);width:40px}.el-upload-cover__label i{color:#fff;font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-cover__progress{display:inline-block;position:static;vertical-align:middle;width:243px}.el-upload-cover__progress+.el-upload__inner{opacity:0}.el-upload-cover__content{height:100%;left:0;position:absolute;top:0;width:100%}.el-upload-cover__interact{background-color:var(--el-overlay-color-light);bottom:0;height:100%;left:0;position:absolute;text-align:center;width:100%}.el-upload-cover__interact .btn{color:#fff;cursor:pointer;display:inline-block;font-size:14px;margin-top:60px;transition:var(--el-transition-md-fade);vertical-align:middle}.el-upload-cover__interact .btn i{margin-top:0}.el-upload-cover__interact .btn span{opacity:0;transition:opacity .15s linear}.el-upload-cover__interact .btn:not(:first-child){margin-left:35px}.el-upload-cover__interact .btn:hover{transform:translateY(-13px)}.el-upload-cover__interact .btn:hover span{opacity:1}.el-upload-cover__interact .btn i{color:#fff;display:block;font-size:24px;line-height:inherit;margin:0 auto 5px}.el-upload-cover__title{background-color:#fff;bottom:0;color:var(--el-text-color-primary);font-size:14px;font-weight:400;height:36px;left:0;line-height:36px;margin:0;overflow:hidden;padding:0 10px;position:absolute;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%}.el-upload-cover+.el-upload__inner{opacity:0;position:relative;z-index:1}.el-progress{align-items:center;display:flex;line-height:1;position:relative}.el-progress__text{color:var(--el-text-color-regular);font-size:14px;line-height:1;margin-left:5px;min-width:50px}.el-progress__text i{display:block;vertical-align:middle}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{left:0;margin:0;position:absolute;text-align:center;top:50%;transform:translateY(-50%);width:100%}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{display:inline-block;vertical-align:middle}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{display:block;margin-right:0;padding-right:0}.el-progress--text-inside .el-progress-bar{margin-right:0;padding-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{box-sizing:border-box;flex-grow:1}.el-progress-bar__outer{background-color:var(--el-border-color-lighter);border-radius:100px;height:6px;overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{background-color:var(--el-color-primary);border-radius:100px;height:100%;left:0;line-height:1;position:absolute;text-align:right;top:0;transition:width .6s ease;white-space:nowrap}.el-progress-bar__inner:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{-webkit-animation:indeterminate 3s infinite;animation:indeterminate 3s infinite;transform:translateZ(0)}.el-progress-bar__inner--striped{background-image:linear-gradient(45deg,rgba(0,0,0,.1) 25%,transparent 0,transparent 50%,rgba(0,0,0,.1) 0,rgba(0,0,0,.1) 75%,transparent 0,transparent);background-size:1.25em 1.25em}.el-progress-bar__inner--striped.el-progress-bar__inner--striped-flow{-webkit-animation:striped-flow 3s linear infinite;animation:striped-flow 3s linear infinite}.el-progress-bar__innerText{color:#fff;display:inline-block;font-size:12px;margin:0 5px;vertical-align:middle}@-webkit-keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@-webkit-keyframes indeterminate{0%{left:-100%}to{left:100%}}@keyframes indeterminate{0%{left:-100%}to{left:100%}}@-webkit-keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}@keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{background-color:var(--el-color-primary);background-position:50%;background-repeat:no-repeat;border-right:none;border-top:none;content:"";height:12px;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;position:absolute;right:20px;top:50%;transform:translateY(-50%);width:12px}.el-select-dropdown{border-radius:var(--el-border-radius-base);box-sizing:border-box;z-index:calc(var(--el-index-top) + 1)}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__empty,.el-select-dropdown__loading{color:var(--el-text-color-secondary);font-size:var(--el-select-font-size);margin:0;padding:10px 0;text-align:center}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{box-sizing:border-box;list-style:none;margin:0;padding:6px 0}.el-select-dropdown__list.el-vl__window{margin:6px 0;padding:0}.el-select-dropdown__header{border-bottom:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__footer{border-top:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__item{box-sizing:border-box;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-base);height:34px;line-height:34px;overflow:hidden;padding:0 32px 0 20px;position:relative;text-overflow:ellipsis;white-space:nowrap}.el-select-dropdown__item.is-hovering{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.is-selected{color:var(--el-color-primary);font-weight:700}.el-select-dropdown__item.is-disabled{background-color:unset;color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{background-color:var(--el-color-primary);background-position:50%;background-repeat:no-repeat;border-right:none;border-top:none;content:"";height:12px;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;position:absolute;right:20px;top:50%;transform:translateY(-50%);width:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-disabled:after{background-color:var(--el-text-color-placeholder)}.el-select-group{margin:0;padding:0}.el-select-group__wrap{list-style:none;margin:0;padding:0;position:relative}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type):after{background:var(--el-border-color-light);bottom:12px;content:"";display:block;height:1px;left:20px;position:absolute;right:20px}.el-select-group__split-dash{background:var(--el-border-color-light);height:1px;left:20px;position:absolute;right:20px}.el-select-group__title{color:var(--el-color-info);font-size:12px;line-height:30px;padding-left:20px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-color:var(--el-disabled-text-color);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px;--el-select-width:100%;display:inline-block;position:relative;vertical-align:middle;width:var(--el-select-width)}.el-select__wrapper{align-items:center;background-color:var(--el-fill-color-blank);border-radius:var(--el-border-radius-base);box-shadow:0 0 0 1px var(--el-border-color) inset;box-sizing:border-box;cursor:pointer;display:flex;font-size:14px;gap:6px;line-height:24px;min-height:32px;padding:4px 12px;position:relative;text-align:left;transition:var(--el-transition-duration)}.el-select__wrapper:hover{box-shadow:0 0 0 1px var(--el-text-color) inset}.el-select__wrapper.is-filterable{cursor:text}.el-select__wrapper.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-select__wrapper.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-select__wrapper.is-disabled{background-color:var(--el-fill-color-light);box-shadow:0 0 0 1px var(--el-select-disabled-border) inset;color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select__wrapper.is-disabled:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-select__wrapper.is-disabled .el-select__selected-item{color:var(--el-select-disabled-color)}.el-select__wrapper.is-disabled .el-select__caret,.el-select__wrapper.is-disabled .el-tag{cursor:not-allowed}.el-select__prefix,.el-select__suffix{align-items:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:flex;flex-shrink:0;gap:6px}.el-select__caret{color:var(--el-select-input-color);cursor:pointer;font-size:var(--el-select-input-font-size);transform:rotate(0);transition:var(--el-transition-duration)}.el-select__caret.is-reverse{transform:rotate(180deg)}.el-select__selection{align-items:center;display:flex;flex:1;flex-wrap:wrap;gap:6px;min-width:0;position:relative}.el-select__selection.is-near{margin-left:-8px}.el-select__selection .el-tag{border-color:transparent;cursor:pointer}.el-select__selection .el-tag .el-tag__content{min-width:0}.el-select__selected-item{display:flex;flex-wrap:wrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select__tags-text{line-height:normal}.el-select__placeholder,.el-select__tags-text{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select__placeholder{color:var(--el-input-text-color,var(--el-text-color-regular));position:absolute;top:50%;transform:translateY(-50%);width:100%}.el-select__placeholder.is-transparent{color:var(--el-text-color-placeholder);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select__input-wrapper{max-width:100%}.el-select__input-wrapper.is-hidden{opacity:0;position:absolute}.el-select__input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-select-multiple-input-color);font-family:inherit;font-size:inherit;height:24px;max-width:100%;outline:none;padding:0}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input-calculator{left:0;max-width:100%;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:pre}.el-select--large .el-select__wrapper{font-size:14px;gap:6px;line-height:24px;min-height:40px;padding:8px 16px}.el-select--large .el-select__selection{gap:6px}.el-select--large .el-select__selection.is-near{margin-left:-8px}.el-select--large .el-select__prefix,.el-select--large .el-select__suffix{gap:6px}.el-select--large .el-select__input{height:24px}.el-select--small .el-select__wrapper{font-size:12px;gap:4px;line-height:20px;min-height:24px;padding:2px 8px}.el-select--small .el-select__selection{gap:4px}.el-select--small .el-select__selection.is-near{margin-left:-6px}.el-select--small .el-select__prefix,.el-select--small .el-select__suffix{gap:4px}.el-select--small .el-select__input{height:20px}.input-opt[data-v-7741ec68]>:first-child{width:100px}.form-item-upload[data-v-7741ec68]>:first-child{margin-left:0}.el-pagination{--el-pagination-font-size:14px;--el-pagination-bg-color:var(--el-fill-color-blank);--el-pagination-text-color:var(--el-text-color-primary);--el-pagination-border-radius:2px;--el-pagination-button-color:var(--el-text-color-primary);--el-pagination-button-width:32px;--el-pagination-button-height:32px;--el-pagination-button-disabled-color:var(--el-text-color-placeholder);--el-pagination-button-disabled-bg-color:var(--el-fill-color-blank);--el-pagination-button-bg-color:var(--el-fill-color);--el-pagination-hover-color:var(--el-color-primary);--el-pagination-font-size-small:12px;--el-pagination-button-width-small:24px;--el-pagination-button-height-small:24px;--el-pagination-item-gap:16px;align-items:center;color:var(--el-pagination-text-color);display:flex;font-size:var(--el-pagination-font-size);font-weight:400;white-space:nowrap}.el-pagination .el-input__inner{-moz-appearance:textfield;text-align:center}.el-pagination .el-select{width:128px}.el-pagination button{align-items:center;background:var(--el-pagination-bg-color);border:none;border-radius:var(--el-pagination-border-radius);box-sizing:border-box;color:var(--el-pagination-button-color);cursor:pointer;display:flex;font-size:var(--el-pagination-font-size);height:var(--el-pagination-button-height);justify-content:center;line-height:var(--el-pagination-button-height);min-width:var(--el-pagination-button-width);padding:0 4px;text-align:center}.el-pagination button *{pointer-events:none}.el-pagination button:focus{outline:none}.el-pagination button:hover{color:var(--el-pagination-hover-color)}.el-pagination button.is-active{color:var(--el-pagination-hover-color);cursor:default;font-weight:700}.el-pagination button.is-active.is-disabled{color:var(--el-text-color-secondary);font-weight:700}.el-pagination button.is-disabled,.el-pagination button:disabled{background-color:var(--el-pagination-button-disabled-bg-color);color:var(--el-pagination-button-disabled-color);cursor:not-allowed}.el-pagination button:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-pagination .btn-next .el-icon,.el-pagination .btn-prev .el-icon{display:block;font-size:12px;font-weight:700;width:inherit}.el-pagination>.is-first{margin-left:0!important}.el-pagination>.is-last{margin-right:0!important}.el-pagination .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination__sizes,.el-pagination__total{color:var(--el-text-color-regular);font-weight:400;margin-left:var(--el-pagination-item-gap)}.el-pagination__total[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__jump{align-items:center;color:var(--el-text-color-regular);display:flex;font-weight:400;margin-left:var(--el-pagination-item-gap)}.el-pagination__jump[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__goto{margin-right:8px}.el-pagination__editor{box-sizing:border-box;text-align:center}.el-pagination__editor.el-input{width:56px}.el-pagination__editor .el-input__inner::-webkit-inner-spin-button,.el-pagination__editor .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-pagination__classifier{margin-left:8px}.el-pagination__rightwrapper{align-items:center;display:flex;flex:1;justify-content:flex-end}.el-pagination.is-background .btn-next,.el-pagination.is-background .btn-prev,.el-pagination.is-background .el-pager li{background-color:var(--el-pagination-button-bg-color);margin:0 4px}.el-pagination.is-background .btn-next.is-active,.el-pagination.is-background .btn-prev.is-active,.el-pagination.is-background .el-pager li.is-active{background-color:var(--el-color-primary);color:var(--el-color-white)}.el-pagination.is-background .btn-next.is-disabled,.el-pagination.is-background .btn-next:disabled,.el-pagination.is-background .btn-prev.is-disabled,.el-pagination.is-background .btn-prev:disabled,.el-pagination.is-background .el-pager li.is-disabled,.el-pagination.is-background .el-pager li:disabled{background-color:var(--el-disabled-bg-color);color:var(--el-text-color-placeholder)}.el-pagination.is-background .btn-next.is-disabled.is-active,.el-pagination.is-background .btn-next:disabled.is-active,.el-pagination.is-background .btn-prev.is-disabled.is-active,.el-pagination.is-background .btn-prev:disabled.is-active,.el-pagination.is-background .el-pager li.is-disabled.is-active,.el-pagination.is-background .el-pager li:disabled.is-active{background-color:var(--el-fill-color-dark);color:var(--el-text-color-secondary)}.el-pagination.is-background .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination--small .btn-next,.el-pagination--small .btn-prev,.el-pagination--small .el-pager li{font-size:var(--el-pagination-font-size-small);height:var(--el-pagination-button-height-small);line-height:var(--el-pagination-button-height-small);min-width:var(--el-pagination-button-width-small)}.el-pagination--small button,.el-pagination--small span:not([class*=suffix]){font-size:var(--el-pagination-font-size-small)}.el-pagination--small .el-select{width:100px}.el-pager{font-size:0;list-style:none;margin:0;padding:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-pager,.el-pager li{align-items:center;display:flex}.el-pager li{background:var(--el-pagination-bg-color);border:none;border-radius:var(--el-pagination-border-radius);box-sizing:border-box;color:var(--el-pagination-button-color);cursor:pointer;font-size:var(--el-pagination-font-size);height:var(--el-pagination-button-height);justify-content:center;line-height:var(--el-pagination-button-height);min-width:var(--el-pagination-button-width);padding:0 4px;text-align:center}.el-pager li *{pointer-events:none}.el-pager li:focus{outline:none}.el-pager li:hover{color:var(--el-pagination-hover-color)}.el-pager li.is-active{color:var(--el-pagination-hover-color);cursor:default;font-weight:700}.el-pager li.is-active.is-disabled{color:var(--el-text-color-secondary);font-weight:700}.el-pager li.is-disabled,.el-pager li:disabled{background-color:var(--el-pagination-button-disabled-bg-color);color:var(--el-pagination-button-disabled-color);cursor:not-allowed}.el-pager li:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-empty{--el-empty-padding:40px 0;--el-empty-image-width:160px;--el-empty-description-margin-top:20px;--el-empty-bottom-margin-top:20px;--el-empty-fill-color-0:var(--el-color-white);--el-empty-fill-color-1:#fcfcfd;--el-empty-fill-color-2:#f8f9fb;--el-empty-fill-color-3:#f7f8fc;--el-empty-fill-color-4:#eeeff3;--el-empty-fill-color-5:#edeef2;--el-empty-fill-color-6:#e9ebef;--el-empty-fill-color-7:#e5e7e9;--el-empty-fill-color-8:#e0e3e9;--el-empty-fill-color-9:#d5d7de;align-items:center;box-sizing:border-box;display:flex;flex-direction:column;justify-content:center;padding:var(--el-empty-padding);text-align:center}.el-empty__image{width:var(--el-empty-image-width)}.el-empty__image img{height:100%;-o-object-fit:contain;object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;width:100%}.el-empty__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;height:100%;vertical-align:top;width:100%}.el-empty__description{margin-top:var(--el-empty-description-margin-top)}.el-empty__description p{color:var(--el-text-color-secondary);font-size:var(--el-font-size-base);margin:0}.el-empty__bottom{margin-top:var(--el-empty-bottom-margin-top)}.el-row{box-sizing:border-box;display:flex;flex-wrap:wrap;position:relative}.el-row.is-justify-center{justify-content:center}.el-row.is-justify-end{justify-content:flex-end}.el-row.is-justify-space-between{justify-content:space-between}.el-row.is-justify-space-around{justify-content:space-around}.el-row.is-justify-space-evenly{justify-content:space-evenly}.el-row.is-align-top{align-items:flex-start}.el-row.is-align-middle{align-items:center}.el-row.is-align-bottom{align-items:flex-end}[class*=el-col-]{box-sizing:border-box}[class*=el-col-].is-guttered{display:block;min-height:1px}.el-col-0,.el-col-0.is-guttered{display:none}.el-col-0{flex:0 0 0%;max-width:0}.el-col-offset-0{margin-left:0}.el-col-pull-0{position:relative;right:0}.el-col-push-0{left:0;position:relative}.el-col-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-offset-1{margin-left:4.1666666667%}.el-col-pull-1{position:relative;right:4.1666666667%}.el-col-push-1{left:4.1666666667%;position:relative}.el-col-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-offset-2{margin-left:8.3333333333%}.el-col-pull-2{position:relative;right:8.3333333333%}.el-col-push-2{left:8.3333333333%;position:relative}.el-col-3{flex:0 0 12.5%;max-width:12.5%}.el-col-offset-3{margin-left:12.5%}.el-col-pull-3{position:relative;right:12.5%}.el-col-push-3{left:12.5%;position:relative}.el-col-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-offset-4{margin-left:16.6666666667%}.el-col-pull-4{position:relative;right:16.6666666667%}.el-col-push-4{left:16.6666666667%;position:relative}.el-col-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-offset-5{margin-left:20.8333333333%}.el-col-pull-5{position:relative;right:20.8333333333%}.el-col-push-5{left:20.8333333333%;position:relative}.el-col-6{flex:0 0 25%;max-width:25%}.el-col-offset-6{margin-left:25%}.el-col-pull-6{position:relative;right:25%}.el-col-push-6{left:25%;position:relative}.el-col-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-offset-7{margin-left:29.1666666667%}.el-col-pull-7{position:relative;right:29.1666666667%}.el-col-push-7{left:29.1666666667%;position:relative}.el-col-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-offset-8{margin-left:33.3333333333%}.el-col-pull-8{position:relative;right:33.3333333333%}.el-col-push-8{left:33.3333333333%;position:relative}.el-col-9{flex:0 0 37.5%;max-width:37.5%}.el-col-offset-9{margin-left:37.5%}.el-col-pull-9{position:relative;right:37.5%}.el-col-push-9{left:37.5%;position:relative}.el-col-10{flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-offset-10{margin-left:41.6666666667%}.el-col-pull-10{position:relative;right:41.6666666667%}.el-col-push-10{left:41.6666666667%;position:relative}.el-col-11{flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-offset-11{margin-left:45.8333333333%}.el-col-pull-11{position:relative;right:45.8333333333%}.el-col-push-11{left:45.8333333333%;position:relative}.el-col-12{flex:0 0 50%;max-width:50%}.el-col-offset-12{margin-left:50%}.el-col-pull-12{position:relative;right:50%}.el-col-push-12{left:50%;position:relative}.el-col-13{flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-offset-13{margin-left:54.1666666667%}.el-col-pull-13{position:relative;right:54.1666666667%}.el-col-push-13{left:54.1666666667%;position:relative}.el-col-14{flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-offset-14{margin-left:58.3333333333%}.el-col-pull-14{position:relative;right:58.3333333333%}.el-col-push-14{left:58.3333333333%;position:relative}.el-col-15{flex:0 0 62.5%;max-width:62.5%}.el-col-offset-15{margin-left:62.5%}.el-col-pull-15{position:relative;right:62.5%}.el-col-push-15{left:62.5%;position:relative}.el-col-16{flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-offset-16{margin-left:66.6666666667%}.el-col-pull-16{position:relative;right:66.6666666667%}.el-col-push-16{left:66.6666666667%;position:relative}.el-col-17{flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-offset-17{margin-left:70.8333333333%}.el-col-pull-17{position:relative;right:70.8333333333%}.el-col-push-17{left:70.8333333333%;position:relative}.el-col-18{flex:0 0 75%;max-width:75%}.el-col-offset-18{margin-left:75%}.el-col-pull-18{position:relative;right:75%}.el-col-push-18{left:75%;position:relative}.el-col-19{flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-offset-19{margin-left:79.1666666667%}.el-col-pull-19{position:relative;right:79.1666666667%}.el-col-push-19{left:79.1666666667%;position:relative}.el-col-20{flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-offset-20{margin-left:83.3333333333%}.el-col-pull-20{position:relative;right:83.3333333333%}.el-col-push-20{left:83.3333333333%;position:relative}.el-col-21{flex:0 0 87.5%;max-width:87.5%}.el-col-offset-21{margin-left:87.5%}.el-col-pull-21{position:relative;right:87.5%}.el-col-push-21{left:87.5%;position:relative}.el-col-22{flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-offset-22{margin-left:91.6666666667%}.el-col-pull-22{position:relative;right:91.6666666667%}.el-col-push-22{left:91.6666666667%;position:relative}.el-col-23{flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-offset-23{margin-left:95.8333333333%}.el-col-pull-23{position:relative;right:95.8333333333%}.el-col-push-23{left:95.8333333333%;position:relative}.el-col-24{flex:0 0 100%;max-width:100%}.el-col-offset-24{margin-left:100%}.el-col-pull-24{position:relative;right:100%}.el-col-push-24{left:100%;position:relative}@media only screen and (max-width:767px){.el-col-xs-0,.el-col-xs-0.is-guttered{display:none}.el-col-xs-0{flex:0 0 0%;max-width:0}.el-col-xs-offset-0{margin-left:0}.el-col-xs-pull-0{position:relative;right:0}.el-col-xs-push-0{left:0;position:relative}.el-col-xs-1{display:block;flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xs-offset-1{margin-left:4.1666666667%}.el-col-xs-pull-1{position:relative;right:4.1666666667%}.el-col-xs-push-1{left:4.1666666667%;position:relative}.el-col-xs-2{display:block;flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xs-offset-2{margin-left:8.3333333333%}.el-col-xs-pull-2{position:relative;right:8.3333333333%}.el-col-xs-push-2{left:8.3333333333%;position:relative}.el-col-xs-3{display:block;flex:0 0 12.5%;max-width:12.5%}.el-col-xs-offset-3{margin-left:12.5%}.el-col-xs-pull-3{position:relative;right:12.5%}.el-col-xs-push-3{left:12.5%;position:relative}.el-col-xs-4{display:block;flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xs-offset-4{margin-left:16.6666666667%}.el-col-xs-pull-4{position:relative;right:16.6666666667%}.el-col-xs-push-4{left:16.6666666667%;position:relative}.el-col-xs-5{display:block;flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xs-offset-5{margin-left:20.8333333333%}.el-col-xs-pull-5{position:relative;right:20.8333333333%}.el-col-xs-push-5{left:20.8333333333%;position:relative}.el-col-xs-6{display:block;flex:0 0 25%;max-width:25%}.el-col-xs-offset-6{margin-left:25%}.el-col-xs-pull-6{position:relative;right:25%}.el-col-xs-push-6{left:25%;position:relative}.el-col-xs-7{display:block;flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xs-offset-7{margin-left:29.1666666667%}.el-col-xs-pull-7{position:relative;right:29.1666666667%}.el-col-xs-push-7{left:29.1666666667%;position:relative}.el-col-xs-8{display:block;flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xs-offset-8{margin-left:33.3333333333%}.el-col-xs-pull-8{position:relative;right:33.3333333333%}.el-col-xs-push-8{left:33.3333333333%;position:relative}.el-col-xs-9{display:block;flex:0 0 37.5%;max-width:37.5%}.el-col-xs-offset-9{margin-left:37.5%}.el-col-xs-pull-9{position:relative;right:37.5%}.el-col-xs-push-9{left:37.5%;position:relative}.el-col-xs-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xs-offset-10{margin-left:41.6666666667%}.el-col-xs-pull-10{position:relative;right:41.6666666667%}.el-col-xs-push-10{left:41.6666666667%;position:relative}.el-col-xs-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xs-offset-11{margin-left:45.8333333333%}.el-col-xs-pull-11{position:relative;right:45.8333333333%}.el-col-xs-push-11{left:45.8333333333%;position:relative}.el-col-xs-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xs-offset-12{margin-left:50%}.el-col-xs-pull-12{position:relative;right:50%}.el-col-xs-push-12{left:50%;position:relative}.el-col-xs-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xs-offset-13{margin-left:54.1666666667%}.el-col-xs-pull-13{position:relative;right:54.1666666667%}.el-col-xs-push-13{left:54.1666666667%;position:relative}.el-col-xs-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xs-offset-14{margin-left:58.3333333333%}.el-col-xs-pull-14{position:relative;right:58.3333333333%}.el-col-xs-push-14{left:58.3333333333%;position:relative}.el-col-xs-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xs-offset-15{margin-left:62.5%}.el-col-xs-pull-15{position:relative;right:62.5%}.el-col-xs-push-15{left:62.5%;position:relative}.el-col-xs-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xs-offset-16{margin-left:66.6666666667%}.el-col-xs-pull-16{position:relative;right:66.6666666667%}.el-col-xs-push-16{left:66.6666666667%;position:relative}.el-col-xs-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xs-offset-17{margin-left:70.8333333333%}.el-col-xs-pull-17{position:relative;right:70.8333333333%}.el-col-xs-push-17{left:70.8333333333%;position:relative}.el-col-xs-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xs-offset-18{margin-left:75%}.el-col-xs-pull-18{position:relative;right:75%}.el-col-xs-push-18{left:75%;position:relative}.el-col-xs-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xs-offset-19{margin-left:79.1666666667%}.el-col-xs-pull-19{position:relative;right:79.1666666667%}.el-col-xs-push-19{left:79.1666666667%;position:relative}.el-col-xs-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xs-offset-20{margin-left:83.3333333333%}.el-col-xs-pull-20{position:relative;right:83.3333333333%}.el-col-xs-push-20{left:83.3333333333%;position:relative}.el-col-xs-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xs-offset-21{margin-left:87.5%}.el-col-xs-pull-21{position:relative;right:87.5%}.el-col-xs-push-21{left:87.5%;position:relative}.el-col-xs-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xs-offset-22{margin-left:91.6666666667%}.el-col-xs-pull-22{position:relative;right:91.6666666667%}.el-col-xs-push-22{left:91.6666666667%;position:relative}.el-col-xs-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xs-offset-23{margin-left:95.8333333333%}.el-col-xs-pull-23{position:relative;right:95.8333333333%}.el-col-xs-push-23{left:95.8333333333%;position:relative}.el-col-xs-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xs-offset-24{margin-left:100%}.el-col-xs-pull-24{position:relative;right:100%}.el-col-xs-push-24{left:100%;position:relative}}@media only screen and (min-width:768px){.el-col-sm-0,.el-col-sm-0.is-guttered{display:none}.el-col-sm-0{flex:0 0 0%;max-width:0}.el-col-sm-offset-0{margin-left:0}.el-col-sm-pull-0{position:relative;right:0}.el-col-sm-push-0{left:0;position:relative}.el-col-sm-1{display:block;flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-sm-offset-1{margin-left:4.1666666667%}.el-col-sm-pull-1{position:relative;right:4.1666666667%}.el-col-sm-push-1{left:4.1666666667%;position:relative}.el-col-sm-2{display:block;flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-sm-offset-2{margin-left:8.3333333333%}.el-col-sm-pull-2{position:relative;right:8.3333333333%}.el-col-sm-push-2{left:8.3333333333%;position:relative}.el-col-sm-3{display:block;flex:0 0 12.5%;max-width:12.5%}.el-col-sm-offset-3{margin-left:12.5%}.el-col-sm-pull-3{position:relative;right:12.5%}.el-col-sm-push-3{left:12.5%;position:relative}.el-col-sm-4{display:block;flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-sm-offset-4{margin-left:16.6666666667%}.el-col-sm-pull-4{position:relative;right:16.6666666667%}.el-col-sm-push-4{left:16.6666666667%;position:relative}.el-col-sm-5{display:block;flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-sm-offset-5{margin-left:20.8333333333%}.el-col-sm-pull-5{position:relative;right:20.8333333333%}.el-col-sm-push-5{left:20.8333333333%;position:relative}.el-col-sm-6{display:block;flex:0 0 25%;max-width:25%}.el-col-sm-offset-6{margin-left:25%}.el-col-sm-pull-6{position:relative;right:25%}.el-col-sm-push-6{left:25%;position:relative}.el-col-sm-7{display:block;flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-sm-offset-7{margin-left:29.1666666667%}.el-col-sm-pull-7{position:relative;right:29.1666666667%}.el-col-sm-push-7{left:29.1666666667%;position:relative}.el-col-sm-8{display:block;flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-sm-offset-8{margin-left:33.3333333333%}.el-col-sm-pull-8{position:relative;right:33.3333333333%}.el-col-sm-push-8{left:33.3333333333%;position:relative}.el-col-sm-9{display:block;flex:0 0 37.5%;max-width:37.5%}.el-col-sm-offset-9{margin-left:37.5%}.el-col-sm-pull-9{position:relative;right:37.5%}.el-col-sm-push-9{left:37.5%;position:relative}.el-col-sm-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-sm-offset-10{margin-left:41.6666666667%}.el-col-sm-pull-10{position:relative;right:41.6666666667%}.el-col-sm-push-10{left:41.6666666667%;position:relative}.el-col-sm-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-sm-offset-11{margin-left:45.8333333333%}.el-col-sm-pull-11{position:relative;right:45.8333333333%}.el-col-sm-push-11{left:45.8333333333%;position:relative}.el-col-sm-12{display:block;flex:0 0 50%;max-width:50%}.el-col-sm-offset-12{margin-left:50%}.el-col-sm-pull-12{position:relative;right:50%}.el-col-sm-push-12{left:50%;position:relative}.el-col-sm-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-sm-offset-13{margin-left:54.1666666667%}.el-col-sm-pull-13{position:relative;right:54.1666666667%}.el-col-sm-push-13{left:54.1666666667%;position:relative}.el-col-sm-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-sm-offset-14{margin-left:58.3333333333%}.el-col-sm-pull-14{position:relative;right:58.3333333333%}.el-col-sm-push-14{left:58.3333333333%;position:relative}.el-col-sm-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-sm-offset-15{margin-left:62.5%}.el-col-sm-pull-15{position:relative;right:62.5%}.el-col-sm-push-15{left:62.5%;position:relative}.el-col-sm-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-sm-offset-16{margin-left:66.6666666667%}.el-col-sm-pull-16{position:relative;right:66.6666666667%}.el-col-sm-push-16{left:66.6666666667%;position:relative}.el-col-sm-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-sm-offset-17{margin-left:70.8333333333%}.el-col-sm-pull-17{position:relative;right:70.8333333333%}.el-col-sm-push-17{left:70.8333333333%;position:relative}.el-col-sm-18{display:block;flex:0 0 75%;max-width:75%}.el-col-sm-offset-18{margin-left:75%}.el-col-sm-pull-18{position:relative;right:75%}.el-col-sm-push-18{left:75%;position:relative}.el-col-sm-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-sm-offset-19{margin-left:79.1666666667%}.el-col-sm-pull-19{position:relative;right:79.1666666667%}.el-col-sm-push-19{left:79.1666666667%;position:relative}.el-col-sm-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-sm-offset-20{margin-left:83.3333333333%}.el-col-sm-pull-20{position:relative;right:83.3333333333%}.el-col-sm-push-20{left:83.3333333333%;position:relative}.el-col-sm-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-sm-offset-21{margin-left:87.5%}.el-col-sm-pull-21{position:relative;right:87.5%}.el-col-sm-push-21{left:87.5%;position:relative}.el-col-sm-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-sm-offset-22{margin-left:91.6666666667%}.el-col-sm-pull-22{position:relative;right:91.6666666667%}.el-col-sm-push-22{left:91.6666666667%;position:relative}.el-col-sm-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-sm-offset-23{margin-left:95.8333333333%}.el-col-sm-pull-23{position:relative;right:95.8333333333%}.el-col-sm-push-23{left:95.8333333333%;position:relative}.el-col-sm-24{display:block;flex:0 0 100%;max-width:100%}.el-col-sm-offset-24{margin-left:100%}.el-col-sm-pull-24{position:relative;right:100%}.el-col-sm-push-24{left:100%;position:relative}}@media only screen and (min-width:992px){.el-col-md-0,.el-col-md-0.is-guttered{display:none}.el-col-md-0{flex:0 0 0%;max-width:0}.el-col-md-offset-0{margin-left:0}.el-col-md-pull-0{position:relative;right:0}.el-col-md-push-0{left:0;position:relative}.el-col-md-1{display:block;flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-md-offset-1{margin-left:4.1666666667%}.el-col-md-pull-1{position:relative;right:4.1666666667%}.el-col-md-push-1{left:4.1666666667%;position:relative}.el-col-md-2{display:block;flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-md-offset-2{margin-left:8.3333333333%}.el-col-md-pull-2{position:relative;right:8.3333333333%}.el-col-md-push-2{left:8.3333333333%;position:relative}.el-col-md-3{display:block;flex:0 0 12.5%;max-width:12.5%}.el-col-md-offset-3{margin-left:12.5%}.el-col-md-pull-3{position:relative;right:12.5%}.el-col-md-push-3{left:12.5%;position:relative}.el-col-md-4{display:block;flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-md-offset-4{margin-left:16.6666666667%}.el-col-md-pull-4{position:relative;right:16.6666666667%}.el-col-md-push-4{left:16.6666666667%;position:relative}.el-col-md-5{display:block;flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-md-offset-5{margin-left:20.8333333333%}.el-col-md-pull-5{position:relative;right:20.8333333333%}.el-col-md-push-5{left:20.8333333333%;position:relative}.el-col-md-6{display:block;flex:0 0 25%;max-width:25%}.el-col-md-offset-6{margin-left:25%}.el-col-md-pull-6{position:relative;right:25%}.el-col-md-push-6{left:25%;position:relative}.el-col-md-7{display:block;flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-md-offset-7{margin-left:29.1666666667%}.el-col-md-pull-7{position:relative;right:29.1666666667%}.el-col-md-push-7{left:29.1666666667%;position:relative}.el-col-md-8{display:block;flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-md-offset-8{margin-left:33.3333333333%}.el-col-md-pull-8{position:relative;right:33.3333333333%}.el-col-md-push-8{left:33.3333333333%;position:relative}.el-col-md-9{display:block;flex:0 0 37.5%;max-width:37.5%}.el-col-md-offset-9{margin-left:37.5%}.el-col-md-pull-9{position:relative;right:37.5%}.el-col-md-push-9{left:37.5%;position:relative}.el-col-md-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-md-offset-10{margin-left:41.6666666667%}.el-col-md-pull-10{position:relative;right:41.6666666667%}.el-col-md-push-10{left:41.6666666667%;position:relative}.el-col-md-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-md-offset-11{margin-left:45.8333333333%}.el-col-md-pull-11{position:relative;right:45.8333333333%}.el-col-md-push-11{left:45.8333333333%;position:relative}.el-col-md-12{display:block;flex:0 0 50%;max-width:50%}.el-col-md-offset-12{margin-left:50%}.el-col-md-pull-12{position:relative;right:50%}.el-col-md-push-12{left:50%;position:relative}.el-col-md-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-md-offset-13{margin-left:54.1666666667%}.el-col-md-pull-13{position:relative;right:54.1666666667%}.el-col-md-push-13{left:54.1666666667%;position:relative}.el-col-md-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-md-offset-14{margin-left:58.3333333333%}.el-col-md-pull-14{position:relative;right:58.3333333333%}.el-col-md-push-14{left:58.3333333333%;position:relative}.el-col-md-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-md-offset-15{margin-left:62.5%}.el-col-md-pull-15{position:relative;right:62.5%}.el-col-md-push-15{left:62.5%;position:relative}.el-col-md-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-md-offset-16{margin-left:66.6666666667%}.el-col-md-pull-16{position:relative;right:66.6666666667%}.el-col-md-push-16{left:66.6666666667%;position:relative}.el-col-md-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-md-offset-17{margin-left:70.8333333333%}.el-col-md-pull-17{position:relative;right:70.8333333333%}.el-col-md-push-17{left:70.8333333333%;position:relative}.el-col-md-18{display:block;flex:0 0 75%;max-width:75%}.el-col-md-offset-18{margin-left:75%}.el-col-md-pull-18{position:relative;right:75%}.el-col-md-push-18{left:75%;position:relative}.el-col-md-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-md-offset-19{margin-left:79.1666666667%}.el-col-md-pull-19{position:relative;right:79.1666666667%}.el-col-md-push-19{left:79.1666666667%;position:relative}.el-col-md-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-md-offset-20{margin-left:83.3333333333%}.el-col-md-pull-20{position:relative;right:83.3333333333%}.el-col-md-push-20{left:83.3333333333%;position:relative}.el-col-md-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-md-offset-21{margin-left:87.5%}.el-col-md-pull-21{position:relative;right:87.5%}.el-col-md-push-21{left:87.5%;position:relative}.el-col-md-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-md-offset-22{margin-left:91.6666666667%}.el-col-md-pull-22{position:relative;right:91.6666666667%}.el-col-md-push-22{left:91.6666666667%;position:relative}.el-col-md-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-md-offset-23{margin-left:95.8333333333%}.el-col-md-pull-23{position:relative;right:95.8333333333%}.el-col-md-push-23{left:95.8333333333%;position:relative}.el-col-md-24{display:block;flex:0 0 100%;max-width:100%}.el-col-md-offset-24{margin-left:100%}.el-col-md-pull-24{position:relative;right:100%}.el-col-md-push-24{left:100%;position:relative}}@media only screen and (min-width:1200px){.el-col-lg-0,.el-col-lg-0.is-guttered{display:none}.el-col-lg-0{flex:0 0 0%;max-width:0}.el-col-lg-offset-0{margin-left:0}.el-col-lg-pull-0{position:relative;right:0}.el-col-lg-push-0{left:0;position:relative}.el-col-lg-1{display:block;flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-lg-offset-1{margin-left:4.1666666667%}.el-col-lg-pull-1{position:relative;right:4.1666666667%}.el-col-lg-push-1{left:4.1666666667%;position:relative}.el-col-lg-2{display:block;flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-lg-offset-2{margin-left:8.3333333333%}.el-col-lg-pull-2{position:relative;right:8.3333333333%}.el-col-lg-push-2{left:8.3333333333%;position:relative}.el-col-lg-3{display:block;flex:0 0 12.5%;max-width:12.5%}.el-col-lg-offset-3{margin-left:12.5%}.el-col-lg-pull-3{position:relative;right:12.5%}.el-col-lg-push-3{left:12.5%;position:relative}.el-col-lg-4{display:block;flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-lg-offset-4{margin-left:16.6666666667%}.el-col-lg-pull-4{position:relative;right:16.6666666667%}.el-col-lg-push-4{left:16.6666666667%;position:relative}.el-col-lg-5{display:block;flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-lg-offset-5{margin-left:20.8333333333%}.el-col-lg-pull-5{position:relative;right:20.8333333333%}.el-col-lg-push-5{left:20.8333333333%;position:relative}.el-col-lg-6{display:block;flex:0 0 25%;max-width:25%}.el-col-lg-offset-6{margin-left:25%}.el-col-lg-pull-6{position:relative;right:25%}.el-col-lg-push-6{left:25%;position:relative}.el-col-lg-7{display:block;flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-lg-offset-7{margin-left:29.1666666667%}.el-col-lg-pull-7{position:relative;right:29.1666666667%}.el-col-lg-push-7{left:29.1666666667%;position:relative}.el-col-lg-8{display:block;flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-lg-offset-8{margin-left:33.3333333333%}.el-col-lg-pull-8{position:relative;right:33.3333333333%}.el-col-lg-push-8{left:33.3333333333%;position:relative}.el-col-lg-9{display:block;flex:0 0 37.5%;max-width:37.5%}.el-col-lg-offset-9{margin-left:37.5%}.el-col-lg-pull-9{position:relative;right:37.5%}.el-col-lg-push-9{left:37.5%;position:relative}.el-col-lg-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-lg-offset-10{margin-left:41.6666666667%}.el-col-lg-pull-10{position:relative;right:41.6666666667%}.el-col-lg-push-10{left:41.6666666667%;position:relative}.el-col-lg-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-lg-offset-11{margin-left:45.8333333333%}.el-col-lg-pull-11{position:relative;right:45.8333333333%}.el-col-lg-push-11{left:45.8333333333%;position:relative}.el-col-lg-12{display:block;flex:0 0 50%;max-width:50%}.el-col-lg-offset-12{margin-left:50%}.el-col-lg-pull-12{position:relative;right:50%}.el-col-lg-push-12{left:50%;position:relative}.el-col-lg-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-lg-offset-13{margin-left:54.1666666667%}.el-col-lg-pull-13{position:relative;right:54.1666666667%}.el-col-lg-push-13{left:54.1666666667%;position:relative}.el-col-lg-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-lg-offset-14{margin-left:58.3333333333%}.el-col-lg-pull-14{position:relative;right:58.3333333333%}.el-col-lg-push-14{left:58.3333333333%;position:relative}.el-col-lg-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-lg-offset-15{margin-left:62.5%}.el-col-lg-pull-15{position:relative;right:62.5%}.el-col-lg-push-15{left:62.5%;position:relative}.el-col-lg-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-lg-offset-16{margin-left:66.6666666667%}.el-col-lg-pull-16{position:relative;right:66.6666666667%}.el-col-lg-push-16{left:66.6666666667%;position:relative}.el-col-lg-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-lg-offset-17{margin-left:70.8333333333%}.el-col-lg-pull-17{position:relative;right:70.8333333333%}.el-col-lg-push-17{left:70.8333333333%;position:relative}.el-col-lg-18{display:block;flex:0 0 75%;max-width:75%}.el-col-lg-offset-18{margin-left:75%}.el-col-lg-pull-18{position:relative;right:75%}.el-col-lg-push-18{left:75%;position:relative}.el-col-lg-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-lg-offset-19{margin-left:79.1666666667%}.el-col-lg-pull-19{position:relative;right:79.1666666667%}.el-col-lg-push-19{left:79.1666666667%;position:relative}.el-col-lg-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-lg-offset-20{margin-left:83.3333333333%}.el-col-lg-pull-20{position:relative;right:83.3333333333%}.el-col-lg-push-20{left:83.3333333333%;position:relative}.el-col-lg-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-lg-offset-21{margin-left:87.5%}.el-col-lg-pull-21{position:relative;right:87.5%}.el-col-lg-push-21{left:87.5%;position:relative}.el-col-lg-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-lg-offset-22{margin-left:91.6666666667%}.el-col-lg-pull-22{position:relative;right:91.6666666667%}.el-col-lg-push-22{left:91.6666666667%;position:relative}.el-col-lg-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-lg-offset-23{margin-left:95.8333333333%}.el-col-lg-pull-23{position:relative;right:95.8333333333%}.el-col-lg-push-23{left:95.8333333333%;position:relative}.el-col-lg-24{display:block;flex:0 0 100%;max-width:100%}.el-col-lg-offset-24{margin-left:100%}.el-col-lg-pull-24{position:relative;right:100%}.el-col-lg-push-24{left:100%;position:relative}}@media only screen and (min-width:1920px){.el-col-xl-0,.el-col-xl-0.is-guttered{display:none}.el-col-xl-0{flex:0 0 0%;max-width:0}.el-col-xl-offset-0{margin-left:0}.el-col-xl-pull-0{position:relative;right:0}.el-col-xl-push-0{left:0;position:relative}.el-col-xl-1{display:block;flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xl-offset-1{margin-left:4.1666666667%}.el-col-xl-pull-1{position:relative;right:4.1666666667%}.el-col-xl-push-1{left:4.1666666667%;position:relative}.el-col-xl-2{display:block;flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xl-offset-2{margin-left:8.3333333333%}.el-col-xl-pull-2{position:relative;right:8.3333333333%}.el-col-xl-push-2{left:8.3333333333%;position:relative}.el-col-xl-3{display:block;flex:0 0 12.5%;max-width:12.5%}.el-col-xl-offset-3{margin-left:12.5%}.el-col-xl-pull-3{position:relative;right:12.5%}.el-col-xl-push-3{left:12.5%;position:relative}.el-col-xl-4{display:block;flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xl-offset-4{margin-left:16.6666666667%}.el-col-xl-pull-4{position:relative;right:16.6666666667%}.el-col-xl-push-4{left:16.6666666667%;position:relative}.el-col-xl-5{display:block;flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xl-offset-5{margin-left:20.8333333333%}.el-col-xl-pull-5{position:relative;right:20.8333333333%}.el-col-xl-push-5{left:20.8333333333%;position:relative}.el-col-xl-6{display:block;flex:0 0 25%;max-width:25%}.el-col-xl-offset-6{margin-left:25%}.el-col-xl-pull-6{position:relative;right:25%}.el-col-xl-push-6{left:25%;position:relative}.el-col-xl-7{display:block;flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xl-offset-7{margin-left:29.1666666667%}.el-col-xl-pull-7{position:relative;right:29.1666666667%}.el-col-xl-push-7{left:29.1666666667%;position:relative}.el-col-xl-8{display:block;flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xl-offset-8{margin-left:33.3333333333%}.el-col-xl-pull-8{position:relative;right:33.3333333333%}.el-col-xl-push-8{left:33.3333333333%;position:relative}.el-col-xl-9{display:block;flex:0 0 37.5%;max-width:37.5%}.el-col-xl-offset-9{margin-left:37.5%}.el-col-xl-pull-9{position:relative;right:37.5%}.el-col-xl-push-9{left:37.5%;position:relative}.el-col-xl-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xl-offset-10{margin-left:41.6666666667%}.el-col-xl-pull-10{position:relative;right:41.6666666667%}.el-col-xl-push-10{left:41.6666666667%;position:relative}.el-col-xl-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xl-offset-11{margin-left:45.8333333333%}.el-col-xl-pull-11{position:relative;right:45.8333333333%}.el-col-xl-push-11{left:45.8333333333%;position:relative}.el-col-xl-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xl-offset-12{margin-left:50%}.el-col-xl-pull-12{position:relative;right:50%}.el-col-xl-push-12{left:50%;position:relative}.el-col-xl-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xl-offset-13{margin-left:54.1666666667%}.el-col-xl-pull-13{position:relative;right:54.1666666667%}.el-col-xl-push-13{left:54.1666666667%;position:relative}.el-col-xl-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xl-offset-14{margin-left:58.3333333333%}.el-col-xl-pull-14{position:relative;right:58.3333333333%}.el-col-xl-push-14{left:58.3333333333%;position:relative}.el-col-xl-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xl-offset-15{margin-left:62.5%}.el-col-xl-pull-15{position:relative;right:62.5%}.el-col-xl-push-15{left:62.5%;position:relative}.el-col-xl-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xl-offset-16{margin-left:66.6666666667%}.el-col-xl-pull-16{position:relative;right:66.6666666667%}.el-col-xl-push-16{left:66.6666666667%;position:relative}.el-col-xl-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xl-offset-17{margin-left:70.8333333333%}.el-col-xl-pull-17{position:relative;right:70.8333333333%}.el-col-xl-push-17{left:70.8333333333%;position:relative}.el-col-xl-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xl-offset-18{margin-left:75%}.el-col-xl-pull-18{position:relative;right:75%}.el-col-xl-push-18{left:75%;position:relative}.el-col-xl-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xl-offset-19{margin-left:79.1666666667%}.el-col-xl-pull-19{position:relative;right:79.1666666667%}.el-col-xl-push-19{left:79.1666666667%;position:relative}.el-col-xl-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xl-offset-20{margin-left:83.3333333333%}.el-col-xl-pull-20{position:relative;right:83.3333333333%}.el-col-xl-push-20{left:83.3333333333%;position:relative}.el-col-xl-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xl-offset-21{margin-left:87.5%}.el-col-xl-pull-21{position:relative;right:87.5%}.el-col-xl-push-21{left:87.5%;position:relative}.el-col-xl-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xl-offset-22{margin-left:91.6666666667%}.el-col-xl-pull-22{position:relative;right:91.6666666667%}.el-col-xl-push-22{left:91.6666666667%;position:relative}.el-col-xl-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xl-offset-23{margin-left:95.8333333333%}.el-col-xl-pull-23{position:relative;right:95.8333333333%}.el-col-xl-push-23{left:95.8333333333%;position:relative}.el-col-xl-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xl-offset-24{margin-left:100%}.el-col-xl-pull-24{position:relative;right:100%}.el-col-xl-push-24{left:100%;position:relative}}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transform-origin:center top;transition:var(--el-transition-md-fade)}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transform-origin:center bottom;transition:var(--el-transition-md-fade)}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transform-origin:top left;transition:var(--el-transition-md-fade)}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-picker__popper{--el-datepicker-border-color:var(--el-disabled-border-color)}.el-picker__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-datepicker-border-color);box-shadow:var(--el-box-shadow-light)}.el-picker__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-datepicker-border-color)}.el-picker__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-date-editor{--el-date-editor-width:220px;--el-date-editor-monthrange-width:300px;--el-date-editor-daterange-width:350px;--el-date-editor-datetimerange-width:400px;--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;position:relative;text-align:left;vertical-align:middle}.el-date-editor.el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-date-editor.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-date-editor.el-input,.el-date-editor.el-input__wrapper{height:var(--el-input-height,var(--el-component-size));width:var(--el-date-editor-width)}.el-date-editor--monthrange{--el-date-editor-width:var(--el-date-editor-monthrange-width)}.el-date-editor--daterange,.el-date-editor--timerange{--el-date-editor-width:var(--el-date-editor-daterange-width)}.el-date-editor--datetimerange{--el-date-editor-width:var(--el-date-editor-datetimerange-width)}.el-date-editor--dates .el-input__wrapper{text-overflow:ellipsis;white-space:nowrap}.el-date-editor .clear-icon,.el-date-editor .close-icon{cursor:pointer}.el-date-editor .clear-icon:hover{color:var(--el-text-color-secondary)}.el-date-editor .el-range__icon{color:var(--el-text-color-placeholder);float:left;font-size:14px;height:inherit}.el-date-editor .el-range__icon svg{vertical-align:middle}.el-date-editor .el-range-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-text-color-regular);display:inline-block;font-size:var(--el-font-size-base);height:30px;line-height:30px;margin:0;outline:none;padding:0;text-align:center;width:39%}.el-date-editor .el-range-input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input::placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-separator{align-items:center;color:var(--el-text-color-primary);display:inline-flex;flex:1;font-size:14px;height:100%;justify-content:center;margin:0;overflow-wrap:break-word;padding:0 5px}.el-date-editor .el-range__close-icon{color:var(--el-text-color-placeholder);cursor:pointer;font-size:14px;height:inherit;width:unset}.el-date-editor .el-range__close-icon:hover{color:var(--el-text-color-secondary)}.el-date-editor .el-range__close-icon svg{vertical-align:middle}.el-date-editor .el-range__close-icon--hidden{opacity:0;visibility:hidden}.el-range-editor.el-input__wrapper{align-items:center;display:inline-flex;padding:0 10px}.el-range-editor.is-active,.el-range-editor.is-active:hover{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-range-editor--large{line-height:var(--el-component-size-large)}.el-range-editor--large.el-input__wrapper{height:var(--el-component-size-large)}.el-range-editor--large .el-range-separator{font-size:14px;line-height:40px}.el-range-editor--large .el-range-input{font-size:14px;height:38px;line-height:38px}.el-range-editor--small{line-height:var(--el-component-size-small)}.el-range-editor--small.el-input__wrapper{height:var(--el-component-size-small)}.el-range-editor--small .el-range-separator{font-size:12px;line-height:24px}.el-range-editor--small .el-range-input{font-size:12px;height:22px;line-height:22px}.el-range-editor.is-disabled{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled:focus,.el-range-editor.is-disabled:hover{border-color:var(--el-disabled-border-color)}.el-range-editor.is-disabled input{background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input::placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled .el-range-separator{color:var(--el-disabled-text-color)}.el-picker-panel{background:var(--el-bg-color-overlay);border-radius:var(--el-border-radius-base);color:var(--el-text-color-regular);line-height:30px}.el-picker-panel .el-time-panel{background-color:var(--el-bg-color-overlay);border:1px solid var(--el-datepicker-border-color);box-shadow:var(--el-box-shadow-light);margin:5px 0}.el-picker-panel__body-wrapper:after,.el-picker-panel__body:after{clear:both;content:"";display:table}.el-picker-panel__content{margin:15px;position:relative}.el-picker-panel__footer{background-color:var(--el-bg-color-overlay);border-top:1px solid var(--el-datepicker-inner-border-color);font-size:0;padding:4px 12px;position:relative;text-align:right}.el-picker-panel__shortcut{background-color:transparent;border:0;color:var(--el-datepicker-text-color);cursor:pointer;display:block;font-size:14px;line-height:28px;outline:none;padding-left:12px;text-align:left;width:100%}.el-picker-panel__shortcut:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__shortcut.active{background-color:#e6f1fe;color:var(--el-datepicker-active-color)}.el-picker-panel__btn{background-color:transparent;border:1px solid var(--el-fill-color-darker);border-radius:2px;color:var(--el-text-color-primary);cursor:pointer;font-size:12px;line-height:24px;outline:none;padding:0 20px}.el-picker-panel__btn[disabled]{color:var(--el-text-color-disabled);cursor:not-allowed}.el-picker-panel__icon-btn{background:transparent;border:0;color:var(--el-datepicker-icon-color);cursor:pointer;font-size:12px;margin-top:8px;outline:none}.el-picker-panel__icon-btn:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn:focus-visible{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn.is-disabled{color:var(--el-text-color-disabled)}.el-picker-panel__icon-btn.is-disabled:hover{cursor:not-allowed}.el-picker-panel__icon-btn .el-icon{cursor:pointer;font-size:inherit}.el-picker-panel__link-btn{vertical-align:middle}.el-picker-panel [slot=sidebar],.el-picker-panel__sidebar{background-color:var(--el-bg-color-overlay);border-right:1px solid var(--el-datepicker-inner-border-color);bottom:0;box-sizing:border-box;overflow:auto;padding-top:6px;position:absolute;top:0;width:110px}.el-picker-panel [slot=sidebar]+.el-picker-panel__body,.el-picker-panel__sidebar+.el-picker-panel__body{margin-left:110px}.el-time-spinner.has-seconds .el-time-spinner__wrapper{width:33.3%}.el-time-spinner__wrapper{display:inline-block;max-height:192px;overflow:auto;position:relative;vertical-align:top;width:50%}.el-time-spinner__wrapper.el-scrollbar__wrap:not(.el-scrollbar__wrap--hidden-default){padding-bottom:15px}.el-time-spinner__wrapper.is-arrow{box-sizing:border-box;overflow:hidden;text-align:center}.el-time-spinner__wrapper.is-arrow .el-time-spinner__list{transform:translateY(-32px)}.el-time-spinner__wrapper.is-arrow .el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:default}.el-time-spinner__arrow{color:var(--el-text-color-secondary);cursor:pointer;font-size:12px;height:30px;left:0;line-height:30px;position:absolute;text-align:center;width:100%;z-index:var(--el-index-normal)}.el-time-spinner__arrow:hover{color:var(--el-color-primary)}.el-time-spinner__arrow.arrow-up{top:10px}.el-time-spinner__arrow.arrow-down{bottom:10px}.el-time-spinner__input.el-input{width:70%}.el-time-spinner__input.el-input .el-input__inner,.el-time-spinner__list{padding:0;text-align:center}.el-time-spinner__list{list-style:none;margin:0}.el-time-spinner__list:after,.el-time-spinner__list:before{content:"";display:block;height:80px;width:100%}.el-time-spinner__item{color:var(--el-text-color-regular);font-size:12px;height:32px;line-height:32px}.el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:pointer}.el-time-spinner__item.is-active:not(.is-disabled){color:var(--el-text-color-primary);font-weight:700}.el-time-spinner__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-time-panel{border-radius:2px;box-sizing:content-box;left:0;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:180px;z-index:var(--el-index-top)}.el-time-panel__content{font-size:0;overflow:hidden;position:relative}.el-time-panel__content:after,.el-time-panel__content:before{box-sizing:border-box;content:"";height:32px;left:0;margin-top:-16px;padding-top:6px;position:absolute;right:0;text-align:left;top:50%;z-index:-1}.el-time-panel__content:after{left:50%;margin-left:12%;margin-right:12%}.el-time-panel__content:before{border-bottom:1px solid var(--el-border-color-light);border-top:1px solid var(--el-border-color-light);margin-left:12%;margin-right:12%;padding-left:50%}.el-time-panel__content.has-seconds:after{left:66.6666666667%}.el-time-panel__content.has-seconds:before{padding-left:33.3333333333%}.el-time-panel__footer{border-top:1px solid var(--el-timepicker-inner-border-color,var(--el-border-color-light));box-sizing:border-box;height:36px;line-height:25px;padding:4px;text-align:right}.el-time-panel__btn{background-color:transparent;border:none;color:var(--el-text-color-primary);cursor:pointer;font-size:12px;line-height:28px;margin:0 5px;outline:none;padding:0 5px}.el-time-panel__btn.confirm{color:var(--el-timepicker-active-color,var(--el-color-primary));font-weight:800}.el-time-range-picker{overflow:visible;width:354px}.el-time-range-picker__content{padding:10px;position:relative;text-align:center;z-index:1}.el-time-range-picker__cell{box-sizing:border-box;display:inline-block;margin:0;padding:4px 7px 7px;width:50%}.el-time-range-picker__header{font-size:14px;margin-bottom:5px;text-align:center}.el-time-range-picker__body{border:1px solid var(--el-datepicker-border-color);border-radius:2px}.filter-bar[data-v-fc9f5b4e]{margin-bottom:20px}.markdown-container[data-v-65b48a9b]{padding:16px;background-color:#f9f9f9;border-radius:8px;font-family:Arial,sans-serif;line-height:1.6;color:#333}.markdown-container h1[data-v-65b48a9b]{font-size:2em;margin-bottom:.5em;color:#222}.markdown-container h2[data-v-65b48a9b]{font-size:1.5em;margin-bottom:.5em;color:#333}.markdown-container h3[data-v-65b48a9b]{font-size:1.25em;margin-bottom:.5em;color:#444}.markdown-container p[data-v-65b48a9b]{margin:.5em 0}.markdown-container ul[data-v-65b48a9b]{padding-left:20px;list-style-type:disc}.markdown-container ol[data-v-65b48a9b]{padding-left:20px;list-style-type:decimal}.markdown-container li[data-v-65b48a9b]{margin:.5em 0}.markdown-container code[data-v-65b48a9b]{background-color:#f4f4f4;padding:.2em .4em;border-radius:4px;font-family:Courier New,Courier,monospace}.markdown-container pre[data-v-65b48a9b]{background-color:#f4f4f4;padding:16px;border-radius:8px;overflow-x:auto}.markdown-container blockquote[data-v-65b48a9b]{margin:1em 0;padding:.5em 1em;background-color:#f9f9f9;border-left:4px solid #ccc;color:#666;font-style:italic}.show-component[data-v-7e162cfe]{padding:20px} `);

System.addImportMap({ imports: {"vue":"user:vue","pinia":"user:pinia","element-plus":"user:element-plus","protobufjs":"user:protobufjs","event-source-polyfill":"user:event-source-polyfill"} });
System.set("user:vue", (()=>{const _=Vue;('default' in _)||(_.default=_);return _})());
System.set("user:pinia", (()=>{const _=Pinia;('default' in _)||(_.default=_);return _})());
System.set("user:element-plus", (()=>{const _=ElementPlus;('default' in _)||(_.default=_);return _})());
System.set("user:protobufjs", (()=>{const _=protobuf;('default' in _)||(_.default=_);return _})());
System.set("user:event-source-polyfill", (()=>{const _=EventSourcePolyfill;('default' in _)||(_.default=_);return _})());

System.register("./__entry.js", ['./__monkey.entry-Ca4ph1Aa.js'], (function (exports, module) {
	'use strict';
	return {
		setters: [null],
		execute: (function () {



		})
	};
}));

System.register("./__monkey.entry-Ca4ph1Aa.js", ['vue', 'protobufjs', 'pinia', 'element-plus'], (function (exports, module) {
  'use strict';
  var ref, reactive, createApp, defineComponent, openBlock, createBlock, inject, shallowRef, resolveDynamicComponent, protobuf, defineStore, createPinia, ElMessage$1, ElementPlus;
  return {
    setters: [module => {
      ref = module.ref;
      reactive = module.reactive;
      createApp = module.createApp;
      defineComponent = module.defineComponent;
      openBlock = module.openBlock;
      createBlock = module.createBlock;
      inject = module.inject;
      shallowRef = module.shallowRef;
      resolveDynamicComponent = module.resolveDynamicComponent;
    }, module => {
      protobuf = module.default;
    }, module => {
      defineStore = module.defineStore;
      createPinia = module.createPinia;
    }, module => {
      ElMessage$1 = module.ElMessage;
      ElementPlus = module.default;
    }],
    execute: (function () {

      exports("f", fetchWithGM_request);

      var __defProp = Object.defineProperty;
      var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __publicField = (obj, key, value) => {
        __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
        return value;
      };
      const cssLoader = (e) => {
        const t = GM_getResourceText(e);
        return GM_addStyle(t), t;
      };
      cssLoader("element-plus/dist/index.css");
      const scriptRel = function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      }();
      const assetsURL = function(dep) {
        return "/" + dep;
      };
      const seen = {};
      const __vitePreload = function preload(baseModule, deps, importerUrl) {
        let promise = Promise.resolve();
        if (deps && deps.length > 0) {
          const links = document.getElementsByTagName("link");
          const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
          const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
          promise = Promise.all(deps.map((dep) => {
            dep = assetsURL(dep);
            if (dep in seen)
              return;
            seen[dep] = true;
            const isCss = dep.endsWith(".css");
            const cssSelector = isCss ? '[rel="stylesheet"]' : "";
            const isBaseRelative = !!importerUrl;
            if (isBaseRelative) {
              for (let i = links.length - 1; i >= 0; i--) {
                const link2 = links[i];
                if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
                  return;
                }
              }
            } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
              return;
            }
            const link = document.createElement("link");
            link.rel = isCss ? "stylesheet" : scriptRel;
            if (!isCss) {
              link.as = "script";
              link.crossOrigin = "";
            }
            link.href = dep;
            if (cspNonce) {
              link.setAttribute("nonce", cspNonce);
            }
            document.head.appendChild(link);
            if (isCss) {
              return new Promise((res, rej) => {
                link.addEventListener("load", res);
                link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
              });
            }
          }));
        }
        return promise.then(() => baseModule()).catch((err) => {
          const e = new Event("vite:preloadError", { cancelable: true });
          e.payload = err;
          window.dispatchEvent(e);
          if (!e.defaultPrevented) {
            throw err;
          }
        });
      };
      class AIJobHuntingError extends Error {
        constructor(message) {
          super(message);
        }
      }
      class PlatformError extends AIJobHuntingError {
        constructor(platformType, message) {
          super(message);
          __publicField(this, "platform");
          this.platform = platformType;
        }
      }
      class PushException extends AIJobHuntingError {
      }
      class NotMatchException extends PushException {
        constructor(jobTitle, data, message = "") {
          super(message);
          __publicField(this, "jobTitle");
          __publicField(this, "data");
          this.jobTitle = jobTitle;
          this.data = data;
        }
      }
      class PushReqException extends PushException {
        constructor(jobTitle, message = "") {
          super(message);
          __publicField(this, "jobTitle");
          this.jobTitle = jobTitle;
        }
      }
      class FetchJobBossFailExp extends PushException {
        constructor(jobTitle, message = "") {
          super(message);
          __publicField(this, "jobTitle");
          this.jobTitle = jobTitle;
        }
      }
      class PublishStopExp extends PushException {
      }
      class PublishLimitExp extends PushException {
      }
      var _GM_addValueChangeListener = /* @__PURE__ */ (() => typeof GM_addValueChangeListener != "undefined" ? GM_addValueChangeListener : void 0)();
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_notification = /* @__PURE__ */ (() => typeof GM_notification != "undefined" ? GM_notification : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      var _unsafeWindow = /* @__PURE__ */ (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)();
      class Tools {
        /**
         * 模糊匹配
         * @param arr
         * @param input
         * @param emptyStatus
         * @returns {boolean|*}
         */
        static fuzzyMatch(arr, input, emptyStatus) {
          if (arr.length === 0) {
            return emptyStatus;
          }
          input = input.toLowerCase();
          let emptyEle = false;
          for (let i = 0; i < arr.length; i++) {
            let arrEleStr = arr[i].toLowerCase();
            if (arrEleStr.length === 0) {
              emptyEle = true;
              continue;
            }
            if (arrEleStr.includes(input) || input.includes(arrEleStr)) {
              return true;
            }
          }
          if (emptyEle) {
            return emptyStatus;
          }
          return false;
        }
        // 范围匹配
        static isRangeOverlap(range, input) {
          const parseRange = (str2) => {
            const match = str2.match(/(\d+)(?:\s*-\s*(\d+))?/);
            if (!match) {
              throw new Error("Invalid range format");
            }
            const start = parseFloat(match[1]);
            const end = match[2] ? parseFloat(match[2]) : Number.POSITIVE_INFINITY;
            return [start, end];
          };
          const [rangeStart, rangeEnd] = parseRange(range);
          const [inputStart, inputEnd] = parseRange(input);
          return !(rangeEnd < inputStart || inputEnd < rangeStart);
        }
        static getRandomNumber(startMs, endMs) {
          return Math.floor(Math.random() * (endMs - startMs + 1)) + startMs;
        }
        static getCookieValue(key) {
          const cookies2 = document.cookie.split(";");
          for (const cookie of cookies2) {
            const [cookieKey, cookieValue] = cookie.trim().split("=");
            if (cookieKey === key) {
              return decodeURIComponent(cookieValue);
            }
          }
          return null;
        }
        static parseURL(url) {
          const urlObj = new URL(url);
          const pathSegments = urlObj.pathname.split("/");
          const jobId = pathSegments[2].replace(".html", "");
          const lid = urlObj.searchParams.get("lid");
          const securityId = urlObj.searchParams.get("securityId");
          return {
            securityId,
            jobId,
            lid
          };
        }
        static queryString(baseURL, queryParams) {
          const queryString = Object.entries(queryParams).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
          return `${baseURL}?${queryString}`;
        }
        static getCurDay() {
          const currentDate = /* @__PURE__ */ new Date();
          const year = currentDate.getFullYear();
          const month = String(currentDate.getMonth() + 1).padStart(2, "0");
          const day = String(currentDate.getDate()).padStart(2, "0");
          return `${year}-${month}-${day}`;
        }
        // 等待一段时间的函数
        static sleep(ms) {
          return new Promise((resolve) => setTimeout(resolve, ms));
        }
        static getEndChar() {
          return String.fromCharCode(0);
        }
      } exports("T", Tools);
      __publicField(Tools, "window", _unsafeWindow);
      const _TampermonkeyApi = class _TampermonkeyApi {
        constructor() {
          _TampermonkeyApi.CUR_CK = _GM_getValue("ck_cur", "");
        }
        static GmSetValue(key, val) {
          return _GM_setValue(_TampermonkeyApi.CUR_CK + key, val);
        }
        static GmGetValue(key, defVal) {
          return _GM_getValue(_TampermonkeyApi.CUR_CK + key, defVal);
        }
        static GMXmlHttpRequest(options) {
          return _GM_xmlhttpRequest(options);
        }
        static GmAddValueChangeListener(key, func) {
          return _GM_addValueChangeListener(_TampermonkeyApi.CUR_CK + key, func);
        }
        static GmNotification(content) {
          _GM_notification({
            title: "Boss直聘批量投简历",
            image: "https://img.bosszhipin.com/beijin/mcs/banner/3e9d37e9effaa2b6daf43f3f03f7cb15cfcd208495d565ef66e7dff9f98764da.jpg",
            text: content,
            highlight: true,
            // 布尔值，是否突出显示发送通知的选项卡
            silent: true,
            // 布尔值，是否播放声音
            timeout: 1e4,
            // 设置通知隐藏时间
            onclick: function() {
            },
            ondone() {
            }
            // 在通知关闭（无论这是由超时还是单击触发）或突出显示选项卡时调用
          });
        }
      };
      __publicField(_TampermonkeyApi, "CUR_CK", "");
      __publicField(_TampermonkeyApi, "LOCAL_CONFIG", "config");
      __publicField(_TampermonkeyApi, "PUSH_SUCCESS_COUNT", "pushSuccessCount:" + Tools.getCurDay());
      __publicField(_TampermonkeyApi, "PUSH_FAIL_COUNT", "pushFailCount:" + Tools.getCurDay());
      __publicField(_TampermonkeyApi, "ACTIVE_ENABLE", "activeEnable");
      __publicField(_TampermonkeyApi, "PUSH_LIMIT", "push_limit" + Tools.getCurDay());
      // 投递锁是否被占用，可重入；value表示当前正在投递的job
      __publicField(_TampermonkeyApi, "PUSH_LOCK", "push_lock");
      // 公司名包含输入框lab
      __publicField(_TampermonkeyApi, "cnInKey", "companyNameInclude");
      // 公司名排除输入框lab
      __publicField(_TampermonkeyApi, "cnExKey", "companyNameExclude");
      // job名称包含输入框lab
      __publicField(_TampermonkeyApi, "jnInKey", "jobNameInclude");
      // job内容排除输入框lab
      __publicField(_TampermonkeyApi, "jcExKey", "jobContentExclude");
      // 薪资范围输入框lab
      __publicField(_TampermonkeyApi, "srInKey", "salaryRange");
      // 公司规模范围输入框lab
      __publicField(_TampermonkeyApi, "csrInKey", "companyScaleRange");
      // 自定义招呼语输入框
      __publicField(_TampermonkeyApi, "sgInKey", "sendSelfGreet");
      __publicField(_TampermonkeyApi, "SEND_SELF_GREET_MEMORY", "sendSelfGreetMemory");
      let TampermonkeyApi = _TampermonkeyApi;
      const _MessageCache = class _MessageCache {
        // GM存储键
        /**
         * 获取当前缓存数据
         */
        getCache() {
          const rawCache = _GM_getValue(_MessageCache.CACHE_KEY, "{}");
          return JSON.parse(rawCache);
        }
        /**
         * 保存缓存数据
         */
        saveCache(cache) {
          _GM_setValue(_MessageCache.CACHE_KEY, JSON.stringify(cache));
        }
        /**
         * 清理过期的缓存
         */
        cleanExpiredCache(cache) {
          const now = Date.now();
          const validCache = {};
          Object.entries(cache).forEach(([key, entry]) => {
            if (entry.expiration > now) {
              validCache[key] = entry;
            }
          });
          return validCache;
        }
        /**
         * 检查是否处理过消息
         * @param bossId - Boss ID
         * @param text - 消息内容，仅前 10 位参与计算
         * @returns 是否已处理
         */
        isMessageProcessed(bossId, text) {
          const key = this.generateKey(bossId, text);
          const cache = this.getCache();
          const validCache = this.cleanExpiredCache(cache);
          this.saveCache(validCache);
          return key in validCache;
        }
        /**
         * 标记消息为已处理
         * @param bossId - Boss ID
         * @param text - 消息内容，仅前 10 位参与计算
         * @param expiration - 过期时间，单位毫秒（可选，默认 1 分钟）
         */
        markMessageAsProcessed(bossId, text, expiration) {
          const key = this.generateKey(bossId, text);
          const cache = this.getCache();
          cache[key] = {
            expiration: Date.now() + (expiration || _MessageCache.DEFAULT_EXPIRATION)
          };
          this.saveCache(cache);
        }
        /**
         * 生成唯一键
         * @param bossId - Boss ID
         * @param text - 消息内容
         * @returns 唯一键
         */
        generateKey(bossId, text) {
          const trimmedText = text.slice(0, 10);
          return `${bossId}:${trimmedText}`;
        }
      };
      __publicField(_MessageCache, "DEFAULT_EXPIRATION", 60 * 1e3);
      // 默认过期时间：1分钟
      __publicField(_MessageCache, "CACHE_KEY", "messageCache");
      let MessageCache = _MessageCache;
      var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
        LogLevel2[LogLevel2["Error"] = 1] = "Error";
        LogLevel2[LogLevel2["Warn"] = 2] = "Warn";
        LogLevel2[LogLevel2["Info"] = 3] = "Info";
        LogLevel2[LogLevel2["Debug"] = 4] = "Debug";
        LogLevel2[LogLevel2["Trace"] = 5] = "Trace";
        LogLevel2[LogLevel2["OriginalTrace"] = 6] = "OriginalTrace";
        return LogLevel2;
      })(LogLevel || {});
      let globalLogLevel = 3;
      const loggerInstances = [];
      const logStyles = {
        // 30 - 黑色
        // 31 - 红色
        // 32 - 绿色
        // 33 - 黄色
        // 34 - 蓝色
        // 35 - 紫色
        // 36 - 青色
        // 37 - 白色
        error: "\x1B[31m%s\x1B[0m",
        // 红色
        warn: "\x1B[33m%s\x1B[0m",
        // 黄色
        info: "\x1B[32m%s\x1B[0m",
        // 绿色
        debug: "\x1B[36m%s\x1B[0m",
        // 青色
        trace: "\x1B[34m%s\x1B[0m"
        // 蓝色
      };
      const _Logger = class _Logger {
        constructor(name = "", logLevel = globalLogLevel) {
          __publicField(this, "name");
          __publicField(this, "logLevel");
          this.name = name;
          this.logLevel = logLevel;
          loggerInstances.push(this);
        }
        static setGlobalLogLevel(logLevel) {
          globalLogLevel = logLevel;
          loggerInstances.forEach((logger2) => logger2.setLogLevel(logLevel));
        }
        setLogLevel(logLevel) {
          this.logLevel = logLevel;
        }
        getLogLevel() {
          return this.logLevel;
        }
        error(...messages) {
          if (this.logLevel >= 1) {
            console.error(logStyles.error, `[${this.name}][ERROR]`, ...messages);
          }
        }
        warn(...messages) {
          if (this.logLevel >= 2) {
            console.warn(logStyles.warn, `[${this.name}][WARN]`, ...messages);
          }
        }
        info(...messages) {
          if (this.logLevel >= 3) {
            console.log(logStyles.info, `[${this.name}][INFO]`, ...messages);
          }
        }
        debug(...messages) {
          if (this.logLevel >= 4) {
            console.debug(logStyles.debug, `[${this.name}][DEBUG]`, ...messages);
          }
        }
        trace(...messages) {
          if (this.logLevel >= 5) {
            console.debug(logStyles.trace, `[${this.name}][TRACE]`, ...messages);
          }
        }
        originalTrace(...messages) {
          if (this.logLevel >= 6) {
            console.trace(logStyles.trace, `[${this.name}][ORIGINAL_TRACE]`, ...messages);
          }
        }
      };
      __publicField(_Logger, "rootLogger", new _Logger("root"));
      let Logger = _Logger;
      const logger$1 = exports("l", Logger.rootLogger);
      function bind(fn, thisArg) {
        return function wrap() {
          return fn.apply(thisArg, arguments);
        };
      }
      const { toString } = Object.prototype;
      const { getPrototypeOf } = Object;
      const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
        const str2 = toString.call(thing);
        return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
      })(/* @__PURE__ */ Object.create(null));
      const kindOfTest = (type) => {
        type = type.toLowerCase();
        return (thing) => kindOf(thing) === type;
      };
      const typeOfTest = (type) => (thing) => typeof thing === type;
      const { isArray } = Array;
      const isUndefined = typeOfTest("undefined");
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
      }
      const isArrayBuffer = kindOfTest("ArrayBuffer");
      function isArrayBufferView(val) {
        let result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && isArrayBuffer(val.buffer);
        }
        return result;
      }
      const isString = typeOfTest("string");
      const isFunction = typeOfTest("function");
      const isNumber = typeOfTest("number");
      const isObject = (thing) => thing !== null && typeof thing === "object";
      const isBoolean = (thing) => thing === true || thing === false;
      const isPlainObject = (val) => {
        if (kindOf(val) !== "object") {
          return false;
        }
        const prototype2 = getPrototypeOf(val);
        return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
      };
      const isDate = kindOfTest("Date");
      const isFile = kindOfTest("File");
      const isBlob = kindOfTest("Blob");
      const isFileList = kindOfTest("FileList");
      const isStream = (val) => isObject(val) && isFunction(val.pipe);
      const isFormData = (thing) => {
        let kind;
        return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
        kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
      };
      const isURLSearchParams = kindOfTest("URLSearchParams");
      const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      function forEach(obj, fn, { allOwnKeys = false } = {}) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        let i;
        let l;
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray(obj)) {
          for (i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
          const len = keys.length;
          let key;
          for (i = 0; i < len; i++) {
            key = keys[i];
            fn.call(null, obj[key], key, obj);
          }
        }
      }
      function findKey(obj, key) {
        key = key.toLowerCase();
        const keys = Object.keys(obj);
        let i = keys.length;
        let _key;
        while (i-- > 0) {
          _key = keys[i];
          if (key === _key.toLowerCase()) {
            return _key;
          }
        }
        return null;
      }
      const _global = (() => {
        if (typeof globalThis !== "undefined")
          return globalThis;
        return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
      })();
      const isContextDefined = (context) => !isUndefined(context) && context !== _global;
      function merge() {
        const { caseless } = isContextDefined(this) && this || {};
        const result = {};
        const assignValue = (val, key) => {
          const targetKey = caseless && findKey(result, key) || key;
          if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
            result[targetKey] = merge(result[targetKey], val);
          } else if (isPlainObject(val)) {
            result[targetKey] = merge({}, val);
          } else if (isArray(val)) {
            result[targetKey] = val.slice();
          } else {
            result[targetKey] = val;
          }
        };
        for (let i = 0, l = arguments.length; i < l; i++) {
          arguments[i] && forEach(arguments[i], assignValue);
        }
        return result;
      }
      const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
        forEach(b, (val, key) => {
          if (thisArg && isFunction(val)) {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        }, { allOwnKeys });
        return a;
      };
      const stripBOM = (content) => {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      };
      const inherits = (constructor, superConstructor, props, descriptors2) => {
        constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
        constructor.prototype.constructor = constructor;
        Object.defineProperty(constructor, "super", {
          value: superConstructor.prototype
        });
        props && Object.assign(constructor.prototype, props);
      };
      const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
        let props;
        let i;
        let prop;
        const merged = {};
        destObj = destObj || {};
        if (sourceObj == null)
          return destObj;
        do {
          props = Object.getOwnPropertyNames(sourceObj);
          i = props.length;
          while (i-- > 0) {
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
              destObj[prop] = sourceObj[prop];
              merged[prop] = true;
            }
          }
          sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
        } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
        return destObj;
      };
      const endsWith = (str2, searchString, position) => {
        str2 = String(str2);
        if (position === void 0 || position > str2.length) {
          position = str2.length;
        }
        position -= searchString.length;
        const lastIndex = str2.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      };
      const toArray = (thing) => {
        if (!thing)
          return null;
        if (isArray(thing))
          return thing;
        let i = thing.length;
        if (!isNumber(i))
          return null;
        const arr = new Array(i);
        while (i-- > 0) {
          arr[i] = thing[i];
        }
        return arr;
      };
      const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
        return (thing) => {
          return TypedArray && thing instanceof TypedArray;
        };
      })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
      const forEachEntry = (obj, fn) => {
        const generator = obj && obj[Symbol.iterator];
        const iterator = generator.call(obj);
        let result;
        while ((result = iterator.next()) && !result.done) {
          const pair = result.value;
          fn.call(obj, pair[0], pair[1]);
        }
      };
      const matchAll = (regExp, str2) => {
        let matches;
        const arr = [];
        while ((matches = regExp.exec(str2)) !== null) {
          arr.push(matches);
        }
        return arr;
      };
      const isHTMLForm = kindOfTest("HTMLFormElement");
      const toCamelCase = (str2) => {
        return str2.toLowerCase().replace(
          /[-_\s]([a-z\d])(\w*)/g,
          function replacer(m, p1, p2) {
            return p1.toUpperCase() + p2;
          }
        );
      };
      const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
      const isRegExp = kindOfTest("RegExp");
      const reduceDescriptors = (obj, reducer) => {
        const descriptors2 = Object.getOwnPropertyDescriptors(obj);
        const reducedDescriptors = {};
        forEach(descriptors2, (descriptor, name) => {
          let ret;
          if ((ret = reducer(descriptor, name, obj)) !== false) {
            reducedDescriptors[name] = ret || descriptor;
          }
        });
        Object.defineProperties(obj, reducedDescriptors);
      };
      const freezeMethods = (obj) => {
        reduceDescriptors(obj, (descriptor, name) => {
          if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
            return false;
          }
          const value = obj[name];
          if (!isFunction(value))
            return;
          descriptor.enumerable = false;
          if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
          }
          if (!descriptor.set) {
            descriptor.set = () => {
              throw Error("Can not rewrite read-only method '" + name + "'");
            };
          }
        });
      };
      const toObjectSet = (arrayOrString, delimiter) => {
        const obj = {};
        const define = (arr) => {
          arr.forEach((value) => {
            obj[value] = true;
          });
        };
        isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
        return obj;
      };
      const noop = () => {
      };
      const toFiniteNumber = (value, defaultValue) => {
        value = +value;
        return Number.isFinite(value) ? value : defaultValue;
      };
      const ALPHA = "abcdefghijklmnopqrstuvwxyz";
      const DIGIT = "0123456789";
      const ALPHABET = {
        DIGIT,
        ALPHA,
        ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
      };
      const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
        let str2 = "";
        const { length } = alphabet;
        while (size--) {
          str2 += alphabet[Math.random() * length | 0];
        }
        return str2;
      };
      function isSpecCompliantForm(thing) {
        return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
      }
      const toJSONObject = (obj) => {
        const stack = new Array(10);
        const visit = (source, i) => {
          if (isObject(source)) {
            if (stack.indexOf(source) >= 0) {
              return;
            }
            if (!("toJSON" in source)) {
              stack[i] = source;
              const target = isArray(source) ? [] : {};
              forEach(source, (value, key) => {
                const reducedValue = visit(value, i + 1);
                !isUndefined(reducedValue) && (target[key] = reducedValue);
              });
              stack[i] = void 0;
              return target;
            }
          }
          return source;
        };
        return visit(obj, 0);
      };
      const isAsyncFn = kindOfTest("AsyncFunction");
      const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
      const utils$1 = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isBoolean,
        isObject,
        isPlainObject,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isRegExp,
        isFunction,
        isStream,
        isURLSearchParams,
        isTypedArray,
        isFileList,
        forEach,
        merge,
        extend,
        trim,
        stripBOM,
        inherits,
        toFlatObject,
        kindOf,
        kindOfTest,
        endsWith,
        toArray,
        forEachEntry,
        matchAll,
        isHTMLForm,
        hasOwnProperty,
        hasOwnProp: hasOwnProperty,
        // an alias to avoid ESLint no-prototype-builtins detection
        reduceDescriptors,
        freezeMethods,
        toObjectSet,
        toCamelCase,
        noop,
        toFiniteNumber,
        findKey,
        global: _global,
        isContextDefined,
        ALPHABET,
        generateString,
        isSpecCompliantForm,
        toJSONObject,
        isAsyncFn,
        isThenable
      };
      function AxiosError(message, code2, config, request2, response) {
        Error.call(this);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error().stack;
        }
        this.message = message;
        this.name = "AxiosError";
        code2 && (this.code = code2);
        config && (this.config = config);
        request2 && (this.request = request2);
        response && (this.response = response);
      }
      utils$1.inherits(AxiosError, Error, {
        toJSON: function toJSON() {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: utils$1.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        }
      });
      const prototype$1 = AxiosError.prototype;
      const descriptors = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL"
        // eslint-disable-next-line func-names
      ].forEach((code2) => {
        descriptors[code2] = { value: code2 };
      });
      Object.defineProperties(AxiosError, descriptors);
      Object.defineProperty(prototype$1, "isAxiosError", { value: true });
      AxiosError.from = (error, code2, config, request2, response, customProps) => {
        const axiosError = Object.create(prototype$1);
        utils$1.toFlatObject(error, axiosError, function filter2(obj) {
          return obj !== Error.prototype;
        }, (prop) => {
          return prop !== "isAxiosError";
        });
        AxiosError.call(axiosError, error.message, code2, config, request2, response);
        axiosError.cause = error;
        axiosError.name = error.name;
        customProps && Object.assign(axiosError, customProps);
        return axiosError;
      };
      const httpAdapter = null;
      function isVisitable(thing) {
        return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
      }
      function removeBrackets(key) {
        return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
      }
      function renderKey(path, key, dots) {
        if (!path)
          return key;
        return path.concat(key).map(function each(token, i) {
          token = removeBrackets(token);
          return !dots && i ? "[" + token + "]" : token;
        }).join(dots ? "." : "");
      }
      function isFlatArray(arr) {
        return utils$1.isArray(arr) && !arr.some(isVisitable);
      }
      const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
        return /^is[A-Z]/.test(prop);
      });
      function toFormData(obj, formData, options) {
        if (!utils$1.isObject(obj)) {
          throw new TypeError("target must be an object");
        }
        formData = formData || new FormData();
        options = utils$1.toFlatObject(options, {
          metaTokens: true,
          dots: false,
          indexes: false
        }, false, function defined(option, source) {
          return !utils$1.isUndefined(source[option]);
        });
        const metaTokens = options.metaTokens;
        const visitor = options.visitor || defaultVisitor;
        const dots = options.dots;
        const indexes = options.indexes;
        const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
        const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
        if (!utils$1.isFunction(visitor)) {
          throw new TypeError("visitor must be a function");
        }
        function convertValue(value) {
          if (value === null)
            return "";
          if (utils$1.isDate(value)) {
            return value.toISOString();
          }
          if (!useBlob && utils$1.isBlob(value)) {
            throw new AxiosError("Blob is not supported. Use a Buffer instead.");
          }
          if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
            return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
          }
          return value;
        }
        function defaultVisitor(value, key, path) {
          let arr = value;
          if (value && !path && typeof value === "object") {
            if (utils$1.endsWith(key, "{}")) {
              key = metaTokens ? key : key.slice(0, -2);
              value = JSON.stringify(value);
            } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
              key = removeBrackets(key);
              arr.forEach(function each(el, index) {
                !(utils$1.isUndefined(el) || el === null) && formData.append(
                  // eslint-disable-next-line no-nested-ternary
                  indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                  convertValue(el)
                );
              });
              return false;
            }
          }
          if (isVisitable(value)) {
            return true;
          }
          formData.append(renderKey(path, key, dots), convertValue(value));
          return false;
        }
        const stack = [];
        const exposedHelpers = Object.assign(predicates, {
          defaultVisitor,
          convertValue,
          isVisitable
        });
        function build(value, path) {
          if (utils$1.isUndefined(value))
            return;
          if (stack.indexOf(value) !== -1) {
            throw Error("Circular reference detected in " + path.join("."));
          }
          stack.push(value);
          utils$1.forEach(value, function each(el, key) {
            const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
              formData,
              el,
              utils$1.isString(key) ? key.trim() : key,
              path,
              exposedHelpers
            );
            if (result === true) {
              build(el, path ? path.concat(key) : [key]);
            }
          });
          stack.pop();
        }
        if (!utils$1.isObject(obj)) {
          throw new TypeError("data must be an object");
        }
        build(obj);
        return formData;
      }
      function encode$1(str2) {
        const charMap = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0"
        };
        return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
          return charMap[match];
        });
      }
      function AxiosURLSearchParams(params, options) {
        this._pairs = [];
        params && toFormData(params, this, options);
      }
      const prototype = AxiosURLSearchParams.prototype;
      prototype.append = function append(name, value) {
        this._pairs.push([name, value]);
      };
      prototype.toString = function toString2(encoder) {
        const _encode = encoder ? function(value) {
          return encoder.call(this, value, encode$1);
        } : encode$1;
        return this._pairs.map(function each(pair) {
          return _encode(pair[0]) + "=" + _encode(pair[1]);
        }, "").join("&");
      };
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      function buildURL(url, params, options) {
        if (!params) {
          return url;
        }
        const _encode = options && options.encode || encode;
        const serializeFn = options && options.serialize;
        let serializedParams;
        if (serializeFn) {
          serializedParams = serializeFn(params, options);
        } else {
          serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
        }
        if (serializedParams) {
          const hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      }
      class InterceptorManager {
        constructor() {
          this.handlers = [];
        }
        /**
         * Add a new interceptor to the stack
         *
         * @param {Function} fulfilled The function to handle `then` for a `Promise`
         * @param {Function} rejected The function to handle `reject` for a `Promise`
         *
         * @return {Number} An ID used to remove interceptor later
         */
        use(fulfilled, rejected, options) {
          this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
          });
          return this.handlers.length - 1;
        }
        /**
         * Remove an interceptor from the stack
         *
         * @param {Number} id The ID that was returned by `use`
         *
         * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
         */
        eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        }
        /**
         * Clear all interceptors from the stack
         *
         * @returns {void}
         */
        clear() {
          if (this.handlers) {
            this.handlers = [];
          }
        }
        /**
         * Iterate over all the registered interceptors
         *
         * This method is particularly useful for skipping over any
         * interceptors that may have become `null` calling `eject`.
         *
         * @param {Function} fn The function to call for each interceptor
         *
         * @returns {void}
         */
        forEach(fn) {
          utils$1.forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) {
              fn(h);
            }
          });
        }
      }
      const transitionalDefaults = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      };
      const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
      const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
      const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
      const platform$2 = {
        isBrowser: true,
        classes: {
          URLSearchParams: URLSearchParams$1,
          FormData: FormData$1,
          Blob: Blob$1
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
      };
      const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
      const hasStandardBrowserEnv = ((product) => {
        return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
      })(typeof navigator !== "undefined" && navigator.product);
      const hasStandardBrowserWebWorkerEnv = (() => {
        return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
        self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
      })();
      const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        hasBrowserEnv,
        hasStandardBrowserEnv,
        hasStandardBrowserWebWorkerEnv
      }, Symbol.toStringTag, { value: "Module" }));
      const platform$1 = {
        ...utils,
        ...platform$2
      };
      function toURLEncodedForm(data, options) {
        return toFormData(data, new platform$1.classes.URLSearchParams(), Object.assign({
          visitor: function(value, key, path, helpers) {
            if (platform$1.isNode && utils$1.isBuffer(value)) {
              this.append(key, value.toString("base64"));
              return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
          }
        }, options));
      }
      function parsePropPath(name) {
        return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
          return match[0] === "[]" ? "" : match[1] || match[0];
        });
      }
      function arrayToObject(arr) {
        const obj = {};
        const keys = Object.keys(arr);
        let i;
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          obj[key] = arr[key];
        }
        return obj;
      }
      function formDataToJSON(formData) {
        function buildPath(path, value, target, index) {
          let name = path[index++];
          if (name === "__proto__")
            return true;
          const isNumericKey = Number.isFinite(+name);
          const isLast = index >= path.length;
          name = !name && utils$1.isArray(target) ? target.length : name;
          if (isLast) {
            if (utils$1.hasOwnProp(target, name)) {
              target[name] = [target[name], value];
            } else {
              target[name] = value;
            }
            return !isNumericKey;
          }
          if (!target[name] || !utils$1.isObject(target[name])) {
            target[name] = [];
          }
          const result = buildPath(path, value, target[name], index);
          if (result && utils$1.isArray(target[name])) {
            target[name] = arrayToObject(target[name]);
          }
          return !isNumericKey;
        }
        if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
          const obj = {};
          utils$1.forEachEntry(formData, (name, value) => {
            buildPath(parsePropPath(name), value, obj, 0);
          });
          return obj;
        }
        return null;
      }
      function stringifySafely(rawValue, parser, encoder) {
        if (utils$1.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils$1.trim(rawValue);
          } catch (e) {
            if (e.name !== "SyntaxError") {
              throw e;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      const defaults = {
        transitional: transitionalDefaults,
        adapter: ["xhr", "http"],
        transformRequest: [function transformRequest(data, headers) {
          const contentType = headers.getContentType() || "";
          const hasJSONContentType = contentType.indexOf("application/json") > -1;
          const isObjectPayload = utils$1.isObject(data);
          if (isObjectPayload && utils$1.isHTMLForm(data)) {
            data = new FormData(data);
          }
          const isFormData2 = utils$1.isFormData(data);
          if (isFormData2) {
            return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
          }
          if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
            return data;
          }
          if (utils$1.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils$1.isURLSearchParams(data)) {
            headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
            return data.toString();
          }
          let isFileList2;
          if (isObjectPayload) {
            if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
              return toURLEncodedForm(data, this.formSerializer).toString();
            }
            if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
              const _FormData = this.env && this.env.FormData;
              return toFormData(
                isFileList2 ? { "files[]": data } : data,
                _FormData && new _FormData(),
                this.formSerializer
              );
            }
          }
          if (isObjectPayload || hasJSONContentType) {
            headers.setContentType("application/json", false);
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          const transitional2 = this.transitional || defaults.transitional;
          const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
          const JSONRequested = this.responseType === "json";
          if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
            const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
            const strictJSONParsing = !silentJSONParsing && JSONRequested;
            try {
              return JSON.parse(data);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
                }
                throw e;
              }
            }
          }
          return data;
        }],
        /**
         * A timeout in milliseconds to abort a request. If set to 0 (default) a
         * timeout is not created.
         */
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
          FormData: platform$1.classes.FormData,
          Blob: platform$1.classes.Blob
        },
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": void 0
          }
        }
      };
      utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
        defaults.headers[method] = {};
      });
      const defaults$1 = defaults;
      const ignoreDuplicateOf = utils$1.toObjectSet([
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ]);
      const parseHeaders = (rawHeaders) => {
        const parsed = {};
        let key;
        let val;
        let i;
        rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
          i = line.indexOf(":");
          key = line.substring(0, i).trim().toLowerCase();
          val = line.substring(i + 1).trim();
          if (!key || parsed[key] && ignoreDuplicateOf[key]) {
            return;
          }
          if (key === "set-cookie") {
            if (parsed[key]) {
              parsed[key].push(val);
            } else {
              parsed[key] = [val];
            }
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        });
        return parsed;
      };
      const $internals = Symbol("internals");
      function normalizeHeader(header) {
        return header && String(header).trim().toLowerCase();
      }
      function normalizeValue(value) {
        if (value === false || value == null) {
          return value;
        }
        return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
      }
      function parseTokens(str2) {
        const tokens = /* @__PURE__ */ Object.create(null);
        const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
        let match;
        while (match = tokensRE.exec(str2)) {
          tokens[match[1]] = match[2];
        }
        return tokens;
      }
      const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
      function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
        if (utils$1.isFunction(filter2)) {
          return filter2.call(this, value, header);
        }
        if (isHeaderNameFilter) {
          value = header;
        }
        if (!utils$1.isString(value))
          return;
        if (utils$1.isString(filter2)) {
          return value.indexOf(filter2) !== -1;
        }
        if (utils$1.isRegExp(filter2)) {
          return filter2.test(value);
        }
      }
      function formatHeader(header) {
        return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
          return char.toUpperCase() + str2;
        });
      }
      function buildAccessors(obj, header) {
        const accessorName = utils$1.toCamelCase(" " + header);
        ["get", "set", "has"].forEach((methodName) => {
          Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
              return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
          });
        });
      }
      class AxiosHeaders {
        constructor(headers) {
          headers && this.set(headers);
        }
        set(header, valueOrRewrite, rewrite) {
          const self2 = this;
          function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) {
              throw new Error("header name must be a non-empty string");
            }
            const key = utils$1.findKey(self2, lHeader);
            if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
              self2[key || _header] = normalizeValue(_value);
            }
          }
          const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
          if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
            setHeaders(header, valueOrRewrite);
          } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
            setHeaders(parseHeaders(header), valueOrRewrite);
          } else {
            header != null && setHeader(valueOrRewrite, header, rewrite);
          }
          return this;
        }
        get(header, parser) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils$1.findKey(this, header);
            if (key) {
              const value = this[key];
              if (!parser) {
                return value;
              }
              if (parser === true) {
                return parseTokens(value);
              }
              if (utils$1.isFunction(parser)) {
                return parser.call(this, value, key);
              }
              if (utils$1.isRegExp(parser)) {
                return parser.exec(value);
              }
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(header, matcher) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils$1.findKey(this, header);
            return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
          }
          return false;
        }
        delete(header, matcher) {
          const self2 = this;
          let deleted = false;
          function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
              const key = utils$1.findKey(self2, _header);
              if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
                delete self2[key];
                deleted = true;
              }
            }
          }
          if (utils$1.isArray(header)) {
            header.forEach(deleteHeader);
          } else {
            deleteHeader(header);
          }
          return deleted;
        }
        clear(matcher) {
          const keys = Object.keys(this);
          let i = keys.length;
          let deleted = false;
          while (i--) {
            const key = keys[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
              delete this[key];
              deleted = true;
            }
          }
          return deleted;
        }
        normalize(format) {
          const self2 = this;
          const headers = {};
          utils$1.forEach(this, (value, header) => {
            const key = utils$1.findKey(headers, header);
            if (key) {
              self2[key] = normalizeValue(value);
              delete self2[header];
              return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) {
              delete self2[header];
            }
            self2[normalized] = normalizeValue(value);
            headers[normalized] = true;
          });
          return this;
        }
        concat(...targets) {
          return this.constructor.concat(this, ...targets);
        }
        toJSON(asStrings) {
          const obj = /* @__PURE__ */ Object.create(null);
          utils$1.forEach(this, (value, header) => {
            value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
          });
          return obj;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(thing) {
          return thing instanceof this ? thing : new this(thing);
        }
        static concat(first, ...targets) {
          const computed = new this(first);
          targets.forEach((target) => computed.set(target));
          return computed;
        }
        static accessor(header) {
          const internals = this[$internals] = this[$internals] = {
            accessors: {}
          };
          const accessors = internals.accessors;
          const prototype2 = this.prototype;
          function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
              buildAccessors(prototype2, _header);
              accessors[lHeader] = true;
            }
          }
          utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
          return this;
        }
      }
      AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
      utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
        let mapped = key[0].toUpperCase() + key.slice(1);
        return {
          get: () => value,
          set(headerValue) {
            this[mapped] = headerValue;
          }
        };
      });
      utils$1.freezeMethods(AxiosHeaders);
      const AxiosHeaders$1 = AxiosHeaders;
      function transformData(fns, response) {
        const config = this || defaults$1;
        const context = response || config;
        const headers = AxiosHeaders$1.from(context.headers);
        let data = context.data;
        utils$1.forEach(fns, function transform(fn) {
          data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
        });
        headers.normalize();
        return data;
      }
      function isCancel(value) {
        return !!(value && value.__CANCEL__);
      }
      function CanceledError(message, config, request2) {
        AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request2);
        this.name = "CanceledError";
      }
      utils$1.inherits(CanceledError, AxiosError, {
        __CANCEL__: true
      });
      function settle(resolve, reject, response) {
        const validateStatus2 = response.config.validateStatus;
        if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
          resolve(response);
        } else {
          reject(new AxiosError(
            "Request failed with status code " + response.status,
            [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
            response.config,
            response.request,
            response
          ));
        }
      }
      const cookies = platform$1.hasStandardBrowserEnv ? (
        // Standard browser envs support document.cookie
        {
          write(name, value, expires, path, domain, secure) {
            const cookie = [name + "=" + encodeURIComponent(value)];
            utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
            utils$1.isString(path) && cookie.push("path=" + path);
            utils$1.isString(domain) && cookie.push("domain=" + domain);
            secure === true && cookie.push("secure");
            document.cookie = cookie.join("; ");
          },
          read(name) {
            const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        }
      ) : (
        // Non-standard browser env (web workers, react-native) lack needed support.
        {
          write() {
          },
          read() {
            return null;
          },
          remove() {
          }
        }
      );
      function isAbsoluteURL(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      }
      function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      }
      function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      }
      const isURLSameOrigin = platform$1.hasStandardBrowserEnv ? (
        // Standard browser envs have full support of the APIs needed to test
        // whether the request URL is of the same origin as current location.
        function standardBrowserEnv() {
          const msie = /(msie|trident)/i.test(navigator.userAgent);
          const urlParsingNode = document.createElement("a");
          let originURL;
          function resolveURL(url) {
            let href = url;
            if (msie) {
              urlParsingNode.setAttribute("href", href);
              href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute("href", href);
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            };
          }
          originURL = resolveURL(window.location.href);
          return function isURLSameOrigin2(requestURL) {
            const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
            return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
          };
        }()
      ) : (
        // Non standard browser envs (web workers, react-native) lack needed support.
        /* @__PURE__ */ function nonStandardBrowserEnv() {
          return function isURLSameOrigin2() {
            return true;
          };
        }()
      );
      function parseProtocol(url) {
        const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
        return match && match[1] || "";
      }
      function speedometer(samplesCount, min) {
        samplesCount = samplesCount || 10;
        const bytes = new Array(samplesCount);
        const timestamps = new Array(samplesCount);
        let head = 0;
        let tail = 0;
        let firstSampleTS;
        min = min !== void 0 ? min : 1e3;
        return function push(chunkLength) {
          const now = Date.now();
          const startedAt = timestamps[tail];
          if (!firstSampleTS) {
            firstSampleTS = now;
          }
          bytes[head] = chunkLength;
          timestamps[head] = now;
          let i = tail;
          let bytesCount = 0;
          while (i !== head) {
            bytesCount += bytes[i++];
            i = i % samplesCount;
          }
          head = (head + 1) % samplesCount;
          if (head === tail) {
            tail = (tail + 1) % samplesCount;
          }
          if (now - firstSampleTS < min) {
            return;
          }
          const passed = startedAt && now - startedAt;
          return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
        };
      }
      function progressEventReducer(listener, isDownloadStream) {
        let bytesNotified = 0;
        const _speedometer = speedometer(50, 250);
        return (e) => {
          const loaded = e.loaded;
          const total = e.lengthComputable ? e.total : void 0;
          const progressBytes = loaded - bytesNotified;
          const rate = _speedometer(progressBytes);
          const inRange = loaded <= total;
          bytesNotified = loaded;
          const data = {
            loaded,
            total,
            progress: total ? loaded / total : void 0,
            bytes: progressBytes,
            rate: rate ? rate : void 0,
            estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
            event: e
          };
          data[isDownloadStream ? "download" : "upload"] = true;
          listener(data);
        };
      }
      const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
      const xhrAdapter = isXHRAdapterSupported && function(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          let requestData = config.data;
          const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
          let { responseType, withXSRFToken } = config;
          let onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }
          let contentType;
          if (utils$1.isFormData(requestData)) {
            if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
              requestHeaders.setContentType(false);
            } else if ((contentType = requestHeaders.getContentType()) !== false) {
              const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
              requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
            }
          }
          let request2 = new XMLHttpRequest();
          if (config.auth) {
            const username = config.auth.username || "";
            const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
          }
          const fullPath = buildFullPath(config.baseURL, config.url);
          request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
          request2.timeout = config.timeout;
          function onloadend() {
            if (!request2) {
              return;
            }
            const responseHeaders = AxiosHeaders$1.from(
              "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
            );
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
            const response = {
              data: responseData,
              status: request2.status,
              statusText: request2.statusText,
              headers: responseHeaders,
              config,
              request: request2
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request2 = null;
          }
          if ("onloadend" in request2) {
            request2.onloadend = onloadend;
          } else {
            request2.onreadystatechange = function handleLoad() {
              if (!request2 || request2.readyState !== 4) {
                return;
              }
              if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request2.onabort = function handleAbort() {
            if (!request2) {
              return;
            }
            reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
            request2 = null;
          };
          request2.onerror = function handleError() {
            reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2));
            request2 = null;
          };
          request2.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional2 = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(new AxiosError(
              timeoutErrorMessage,
              transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              request2
            ));
            request2 = null;
          };
          if (platform$1.hasStandardBrowserEnv) {
            withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
            if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
              const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
              if (xsrfValue) {
                requestHeaders.set(config.xsrfHeaderName, xsrfValue);
              }
            }
          }
          requestData === void 0 && requestHeaders.setContentType(null);
          if ("setRequestHeader" in request2) {
            utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
              request2.setRequestHeader(key, val);
            });
          }
          if (!utils$1.isUndefined(config.withCredentials)) {
            request2.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request2.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request2.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
          }
          if (typeof config.onUploadProgress === "function" && request2.upload) {
            request2.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
          }
          if (config.cancelToken || config.signal) {
            onCanceled = (cancel) => {
              if (!request2) {
                return;
              }
              reject(!cancel || cancel.type ? new CanceledError(null, config, request2) : cancel);
              request2.abort();
              request2 = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
          }
          const protocol = parseProtocol(fullPath);
          if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
            reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
            return;
          }
          request2.send(requestData || null);
        });
      };
      const knownAdapters = {
        http: httpAdapter,
        xhr: xhrAdapter
      };
      utils$1.forEach(knownAdapters, (fn, value) => {
        if (fn) {
          try {
            Object.defineProperty(fn, "name", { value });
          } catch (e) {
          }
          Object.defineProperty(fn, "adapterName", { value });
        }
      });
      const renderReason = (reason) => `- ${reason}`;
      const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
      const adapters = {
        getAdapter: (adapters2) => {
          adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
          const { length } = adapters2;
          let nameOrAdapter;
          let adapter;
          const rejectedReasons = {};
          for (let i = 0; i < length; i++) {
            nameOrAdapter = adapters2[i];
            let id;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
              adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
              if (adapter === void 0) {
                throw new AxiosError(`Unknown adapter '${id}'`);
              }
            }
            if (adapter) {
              break;
            }
            rejectedReasons[id || "#" + i] = adapter;
          }
          if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(
              ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
            );
            let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new AxiosError(
              `There is no suitable adapter to dispatch the request ` + s,
              "ERR_NOT_SUPPORT"
            );
          }
          return adapter;
        },
        adapters: knownAdapters
      };
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
        if (config.signal && config.signal.aborted) {
          throw new CanceledError(null, config);
        }
      }
      function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = AxiosHeaders$1.from(config.headers);
        config.data = transformData.call(
          config,
          config.transformRequest
        );
        if (["post", "put", "patch"].indexOf(config.method) !== -1) {
          config.headers.setContentType("application/x-www-form-urlencoded", false);
        }
        const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(
            config,
            config.transformResponse,
            response
          );
          response.headers = AxiosHeaders$1.from(response.headers);
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(
                config,
                config.transformResponse,
                reason.response
              );
              reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
            }
          }
          return Promise.reject(reason);
        });
      }
      const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
      function mergeConfig(config1, config2) {
        config2 = config2 || {};
        const config = {};
        function getMergedValue(target, source, caseless) {
          if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
            return utils$1.merge.call({ caseless }, target, source);
          } else if (utils$1.isPlainObject(source)) {
            return utils$1.merge({}, source);
          } else if (utils$1.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(a, b, caseless) {
          if (!utils$1.isUndefined(b)) {
            return getMergedValue(a, b, caseless);
          } else if (!utils$1.isUndefined(a)) {
            return getMergedValue(void 0, a, caseless);
          }
        }
        function valueFromConfig2(a, b) {
          if (!utils$1.isUndefined(b)) {
            return getMergedValue(void 0, b);
          }
        }
        function defaultToConfig2(a, b) {
          if (!utils$1.isUndefined(b)) {
            return getMergedValue(void 0, b);
          } else if (!utils$1.isUndefined(a)) {
            return getMergedValue(void 0, a);
          }
        }
        function mergeDirectKeys(a, b, prop) {
          if (prop in config2) {
            return getMergedValue(a, b);
          } else if (prop in config1) {
            return getMergedValue(void 0, a);
          }
        }
        const mergeMap = {
          url: valueFromConfig2,
          method: valueFromConfig2,
          data: valueFromConfig2,
          baseURL: defaultToConfig2,
          transformRequest: defaultToConfig2,
          transformResponse: defaultToConfig2,
          paramsSerializer: defaultToConfig2,
          timeout: defaultToConfig2,
          timeoutMessage: defaultToConfig2,
          withCredentials: defaultToConfig2,
          withXSRFToken: defaultToConfig2,
          adapter: defaultToConfig2,
          responseType: defaultToConfig2,
          xsrfCookieName: defaultToConfig2,
          xsrfHeaderName: defaultToConfig2,
          onUploadProgress: defaultToConfig2,
          onDownloadProgress: defaultToConfig2,
          decompress: defaultToConfig2,
          maxContentLength: defaultToConfig2,
          maxBodyLength: defaultToConfig2,
          beforeRedirect: defaultToConfig2,
          transport: defaultToConfig2,
          httpAgent: defaultToConfig2,
          httpsAgent: defaultToConfig2,
          cancelToken: defaultToConfig2,
          socketPath: defaultToConfig2,
          responseEncoding: defaultToConfig2,
          validateStatus: mergeDirectKeys,
          headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
        };
        utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
          const merge2 = mergeMap[prop] || mergeDeepProperties;
          const configValue = merge2(config1[prop], config2[prop], prop);
          utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
        });
        return config;
      }
      const VERSION = "1.6.8";
      const validators$1 = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
        validators$1[type] = function validator2(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      const deprecatedWarnings = {};
      validators$1.transitional = function transitional(validator2, version, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return (value, opt, opts) => {
          if (validator2 === false) {
            throw new AxiosError(
              formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
              AxiosError.ERR_DEPRECATED
            );
          }
          if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" + version + " and will be removed in the near future"
              )
            );
          }
          return validator2 ? validator2(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
        }
        const keys = Object.keys(options);
        let i = keys.length;
        while (i-- > 0) {
          const opt = keys[i];
          const validator2 = schema[opt];
          if (validator2) {
            const value = options[opt];
            const result = value === void 0 || validator2(value, opt, options);
            if (result !== true) {
              throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
          }
        }
      }
      const validator = {
        assertOptions,
        validators: validators$1
      };
      const validators = validator.validators;
      class Axios {
        constructor(instanceConfig) {
          this.defaults = instanceConfig;
          this.interceptors = {
            request: new InterceptorManager(),
            response: new InterceptorManager()
          };
        }
        /**
         * Dispatch a request
         *
         * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
         * @param {?Object} config
         *
         * @returns {Promise} The Promise to be fulfilled
         */
        async request(configOrUrl, config) {
          try {
            return await this._request(configOrUrl, config);
          } catch (err) {
            if (err instanceof Error) {
              let dummy;
              Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
              const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            }
            throw err;
          }
        }
        _request(configOrUrl, config) {
          if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
          } else {
            config = configOrUrl || {};
          }
          config = mergeConfig(this.defaults, config);
          const { transitional: transitional2, paramsSerializer, headers } = config;
          if (transitional2 !== void 0) {
            validator.assertOptions(transitional2, {
              silentJSONParsing: validators.transitional(validators.boolean),
              forcedJSONParsing: validators.transitional(validators.boolean),
              clarifyTimeoutError: validators.transitional(validators.boolean)
            }, false);
          }
          if (paramsSerializer != null) {
            if (utils$1.isFunction(paramsSerializer)) {
              config.paramsSerializer = {
                serialize: paramsSerializer
              };
            } else {
              validator.assertOptions(paramsSerializer, {
                encode: validators.function,
                serialize: validators.function
              }, true);
            }
          }
          config.method = (config.method || this.defaults.method || "get").toLowerCase();
          let contextHeaders = headers && utils$1.merge(
            headers.common,
            headers[config.method]
          );
          headers && utils$1.forEach(
            ["delete", "get", "head", "post", "put", "patch", "common"],
            (method) => {
              delete headers[method];
            }
          );
          config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
          const requestInterceptorChain = [];
          let synchronousRequestInterceptors = true;
          this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
              return;
            }
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
          });
          const responseInterceptorChain = [];
          this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
          });
          let promise;
          let i = 0;
          let len;
          if (!synchronousRequestInterceptors) {
            const chain = [dispatchRequest.bind(this), void 0];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while (i < len) {
              promise = promise.then(chain[i++], chain[i++]);
            }
            return promise;
          }
          len = requestInterceptorChain.length;
          let newConfig = config;
          i = 0;
          while (i < len) {
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
              newConfig = onFulfilled(newConfig);
            } catch (error) {
              onRejected.call(this, error);
              break;
            }
          }
          try {
            promise = dispatchRequest.call(this, newConfig);
          } catch (error) {
            return Promise.reject(error);
          }
          i = 0;
          len = responseInterceptorChain.length;
          while (i < len) {
            promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
          }
          return promise;
        }
        getUri(config) {
          config = mergeConfig(this.defaults, config);
          const fullPath = buildFullPath(config.baseURL, config.url);
          return buildURL(fullPath, config.params, config.paramsSerializer);
        }
      }
      utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        function generateHTTPMethod(isForm) {
          return function httpMethod(url, data, config) {
            return this.request(mergeConfig(config || {}, {
              method,
              headers: isForm ? {
                "Content-Type": "multipart/form-data"
              } : {},
              url,
              data
            }));
          };
        }
        Axios.prototype[method] = generateHTTPMethod();
        Axios.prototype[method + "Form"] = generateHTTPMethod(true);
      });
      const Axios$1 = Axios;
      class CancelToken {
        constructor(executor) {
          if (typeof executor !== "function") {
            throw new TypeError("executor must be a function.");
          }
          let resolvePromise;
          this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
          });
          const token = this;
          this.promise.then((cancel) => {
            if (!token._listeners)
              return;
            let i = token._listeners.length;
            while (i-- > 0) {
              token._listeners[i](cancel);
            }
            token._listeners = null;
          });
          this.promise.then = (onfulfilled) => {
            let _resolve;
            const promise = new Promise((resolve) => {
              token.subscribe(resolve);
              _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
              token.unsubscribe(_resolve);
            };
            return promise;
          };
          executor(function cancel(message, config, request2) {
            if (token.reason) {
              return;
            }
            token.reason = new CanceledError(message, config, request2);
            resolvePromise(token.reason);
          });
        }
        /**
         * Throws a `CanceledError` if cancellation has been requested.
         */
        throwIfRequested() {
          if (this.reason) {
            throw this.reason;
          }
        }
        /**
         * Subscribe to the cancel signal
         */
        subscribe(listener) {
          if (this.reason) {
            listener(this.reason);
            return;
          }
          if (this._listeners) {
            this._listeners.push(listener);
          } else {
            this._listeners = [listener];
          }
        }
        /**
         * Unsubscribe from the cancel signal
         */
        unsubscribe(listener) {
          if (!this._listeners) {
            return;
          }
          const index = this._listeners.indexOf(listener);
          if (index !== -1) {
            this._listeners.splice(index, 1);
          }
        }
        /**
         * Returns an object that contains a new `CancelToken` and a function that, when called,
         * cancels the `CancelToken`.
         */
        static source() {
          let cancel;
          const token = new CancelToken(function executor(c) {
            cancel = c;
          });
          return {
            token,
            cancel
          };
        }
      }
      const CancelToken$1 = CancelToken;
      function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      }
      function isAxiosError(payload) {
        return utils$1.isObject(payload) && payload.isAxiosError === true;
      }
      const HttpStatusCode = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
      };
      Object.entries(HttpStatusCode).forEach(([key, value]) => {
        HttpStatusCode[value] = key;
      });
      const HttpStatusCode$1 = HttpStatusCode;
      function createInstance(defaultConfig) {
        const context = new Axios$1(defaultConfig);
        const instance = bind(Axios$1.prototype.request, context);
        utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
        utils$1.extend(instance, context, null, { allOwnKeys: true });
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig(defaultConfig, instanceConfig));
        };
        return instance;
      }
      const axios = exports("c", createInstance(defaults$1));
      axios.Axios = Axios$1;
      axios.CanceledError = CanceledError;
      axios.CancelToken = CancelToken$1;
      axios.isCancel = isCancel;
      axios.VERSION = VERSION;
      axios.toFormData = toFormData;
      axios.AxiosError = AxiosError;
      axios.Cancel = axios.CanceledError;
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = spread;
      axios.isAxiosError = isAxiosError;
      axios.mergeConfig = mergeConfig;
      axios.AxiosHeaders = AxiosHeaders$1;
      axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
      axios.getAdapter = adapters.getAdapter;
      axios.HttpStatusCode = HttpStatusCode$1;
      axios.default = axios;
      var PushStatus = exports("P", /* @__PURE__ */ ((PushStatus2) => {
        PushStatus2[PushStatus2["NOT_START"] = 0] = "NOT_START";
        PushStatus2[PushStatus2["PUSHING"] = 1] = "PUSHING";
        PushStatus2[PushStatus2["PAUSE"] = 2] = "PAUSE";
        PushStatus2[PushStatus2["LIMIT"] = 3] = "LIMIT";
        return PushStatus2;
      })(PushStatus || {}));
      var PushResultStatus = /* @__PURE__ */ ((PushResultStatus2) => {
        PushResultStatus2[PushResultStatus2["NOT_START"] = -1] = "NOT_START";
        PushResultStatus2[PushResultStatus2["SUCCESS"] = 0] = "SUCCESS";
        PushResultStatus2[PushResultStatus2["FAIL"] = 1] = "FAIL";
        return PushResultStatus2;
      })(PushResultStatus || {});
      let protoDefinition = Tools.window.__PROTO_FILE_VAR__;
      const root = protobuf.parse(protoDefinition).root;
      const protobufType = root.lookupType("TechwolfChatProtocol");
      class Message {
        constructor({
          form_uid,
          to_uid,
          to_name,
          content,
          image
        }) {
          __publicField(this, "msg");
          __publicField(this, "hex");
          const r = (/* @__PURE__ */ new Date()).getTime();
          const d = r + 68256432452609;
          const data = {
            messages: [
              {
                from: {
                  uid: form_uid,
                  source: 0
                },
                to: {
                  uid: to_uid,
                  name: to_name,
                  source: 0
                },
                type: 1,
                mid: d.toString(),
                time: r.toString(),
                body: {
                  type: image ? 3 : 1,
                  templateId: 1,
                  text: image ? null : content,
                  image: image ? {
                    originImage: {
                      url: image.originImage
                    },
                    tinyImage: {
                      url: image.tinyImage
                    }
                  } : {}
                },
                cmid: d.toString()
              }
            ],
            type: 1
          };
          this.msg = protobufType.encode(data).finish().slice();
          this.hex = [...this.msg].map((b) => b.toString(16).padStart(2, "0")).join("");
        }
        toArrayBuffer() {
          return this.msg.buffer.slice(0, this.msg.byteLength);
        }
        send() {
          Tools.window.ChatWebsocket.send(this);
        }
      }
      class MessageRead {
        constructor({ userId, messageId }) {
          __publicField(this, "msg");
          __publicField(this, "hex");
          const r = (/* @__PURE__ */ new Date()).getTime();
          const data = {
            messageRead: [
              {
                messageId,
                readTime: r,
                userId,
                userSource: 0
              }
            ],
            type: 6
          };
          this.msg = protobufType.encode(data).finish().slice();
          this.hex = [...this.msg].map((b) => b.toString(16).padStart(2, "0")).join("");
        }
        toArrayBuffer() {
          return this.msg.buffer.slice(0, this.msg.byteLength);
        }
        send() {
          Tools.window.ChatWebsocket.send(this);
        }
      }
      const _LogRecorder = class _LogRecorder extends Logger {
        constructor() {
          super(...arguments);
          // 设置日志存储的最大条数
          __publicField(this, "maxLogs", 1e3);
        }
        addLog(level, message) {
          const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
          _LogRecorder.logs.push({ level, message, timestamp });
          if (_LogRecorder.logs.length > this.maxLogs) {
            _LogRecorder.logs.shift();
          }
        }
        error(...messages) {
          const msg = messages.join(" ");
          this.addLog("error", msg);
          super.error(msg);
        }
        warn(...messages) {
          const msg = messages.join(" ");
          this.addLog("warn", msg);
          super.warn(msg);
        }
        info(...messages) {
          const msg = messages.join(" ");
          this.addLog("info", msg);
          super.info(msg);
        }
        debug(...messages) {
          const msg = messages.join(" ");
          this.addLog("debug", msg);
          super.debug(msg);
        }
        trace(...messages) {
          const msg = messages.join(" ");
          this.addLog("trace", msg);
          super.trace(msg);
        }
        // 获取日志数据，支持分页
        getLogs(page, pageSize) {
          const start = (page - 1) * pageSize;
          return _LogRecorder.logs.slice(start, start + pageSize);
        }
        // 获取日志总条数
        getLogCount() {
          return _LogRecorder.logs.length;
        }
      };
      __publicField(_LogRecorder, "logs", []);
      let LogRecorder = exports("a", _LogRecorder);
      const pushResultCount = exports("p", defineStore("pushResultCount", () => {
        const notMatchCount = ref(0);
        const successCount = ref(TampermonkeyApi.GmGetValue(TampermonkeyApi.PUSH_SUCCESS_COUNT, 0));
        const onceSuccessCount = ref(0);
        const failCount = ref(TampermonkeyApi.GmGetValue(TampermonkeyApi.PUSH_FAIL_COUNT, 0));
        function notMatchIncr() {
          notMatchCount.value++;
        }
        function successIncr() {
          successCount.value++;
          onceSuccessCount.value++;
          TampermonkeyApi.GmSetValue(TampermonkeyApi.PUSH_SUCCESS_COUNT, successCount.value);
        }
        function failIncr() {
          failCount.value++;
          TampermonkeyApi.GmSetValue(TampermonkeyApi.PUSH_FAIL_COUNT, failCount.value);
        }
        function clearOnceSuccessCount() {
          onceSuccessCount.value = 0;
        }
        return { notMatchIncr, successIncr, notMatchCount, successCount, failCount, failIncr, onceSuccessCount, clearOnceSuccessCount };
      }));
      const UserStore = exports("U", defineStore("ai-user", () => {
        const platformType = ref();
        const user = reactive(getLocalUser());
        return {
          user,
          platformType
        };
      }));
      const LoginStore = exports("L", defineStore("LoginStore", () => {
        const login = ref();
        const loginFailStatus = ref();
        function loginSuccess() {
          login.value = true;
        }
        function loginFail() {
          loginFailStatus.value = true;
        }
        return {
          login,
          loginSuccess,
          loginFailStatus,
          loginFail
        };
      }));
      function getLocalUser() {
        let jsonData = localStorage.getItem("ai-job-user");
        if (jsonData === null) {
          jsonData = '{"phone":"","email":"","preference":{},"preferenceMap":{}}';
        }
        let user = JSON.parse(jsonData);
        logger$1.debug("获取本地用户配置", user);
        return user;
      }
      const request = axios.create({
        // 超时时间
        timeout: 1e4,
        // 格式为json数据；字符编码utf-8
        headers: {
          "Content-Type": "application/json; charset=utf-8"
        }
      });
      {
        request.defaults.baseURL = "https://43.138.246.37/";
      }
      request.interceptors.request.use(
        (req) => {
          let authorization = localStorage.getItem("Authorization");
          if (authorization) {
            req.headers["Authorization"] = authorization;
          }
          return req;
        }
      );
      request.interceptors.response.use(
        (resp) => {
          let result = resp.data;
          if (result.code === 200) {
            return resp;
          }
          if (result.code >= 2e3) {
            return resp;
          }
          if (result.code === 401) {
            let authorization = localStorage.getItem("Authorization");
            if (authorization) {
              ElMessage({
                type: "error",
                message: "登录过期，请刷新页面重试"
              });
              return;
            }
            return Promise.reject(result.message);
          }
          if (!result.code || result.code === 500) {
            ElMessage({
              type: "error",
              message: result.message ? result.message : "系统异常"
            });
          }
          return Promise.reject(result.message);
        },
        /**
         * 当
         * http的状态码不为200时
         * @param error
         */
        (error) => {
          if (error.code === "ECONNABORTED") {
            ElMessage({
              message: "网络超时",
              type: "error",
              grouping: true,
              duration: 2e3
            });
            return Promise.reject("time out");
          }
          if (error.code === "ERR_NETWORK") {
            ElMessage({
              message: "系统异常,请稍后重试",
              type: "error",
              grouping: true,
              duration: 2e3
            });
            return Promise.reject(() => {
            });
          }
          if (error.response.data) {
            error.message = error.response.data.message;
          }
          if (error.response.status === 404) {
            error.message = "资源未找到";
          }
          ElMessage({
            message: error.message,
            type: "error",
            grouping: true,
            duration: 3e3
          });
          return Promise.reject(error);
        }
      );
      const logRecorder$2 = new LogRecorder();
      let loginIng = false;
      const silentlyLogin = exports("s", async (bossUserId) => {
        var _a, _b, _c, _d, _e, _f;
        let loginCount = 0;
        while (loginIng && loginCount < 6) {
          logger$1.info("login... ", loginCount);
          await Tools.sleep(500);
          loginCount++;
        }
        loginIng = true;
        let loginStore = LoginStore();
        let token = (_b = (_a = Tools.window) == null ? void 0 : _a._PAGE) == null ? void 0 : _b.token;
        let count = 0;
        while (!token && count < 3) {
          await Tools.sleep(300);
          token = (_d = (_c = Tools.window) == null ? void 0 : _c._PAGE) == null ? void 0 : _d.token;
          count++;
        }
        if (!token) {
          logRecorder$2.info("未登录Boss，静默登录结束");
          return Promise.reject(new Error("未登录Boss，静默登录失败"));
        }
        if (!bossUserId) {
          bossUserId = (_f = (_e = Tools.window) == null ? void 0 : _e._PAGE) == null ? void 0 : _f.uid;
        }
        if (loginStore.login) {
          logger$1.info("已经登录，静默登录结束");
          loginIng = false;
          return Promise.resolve();
        }
        return await request.post("/api/user/silently/login?uniqueId=" + bossUserId).then(async (resp) => {
          if (resp.data.code === 2e3) {
            logRecorder$2.info("开始自动注册");
            await handlerImport({ value: false });
            loginStore.loginSuccess();
            return;
          }
          localStorage.setItem("Authorization", resp.data.data);
          loginStore.loginSuccess();
          logRecorder$2.info("静默登录成功");
        }).catch((e) => {
          logRecorder$2.error("静默登录失败", e);
          loginStore.loginFail();
          return Promise.reject(e);
        }).finally(() => {
          loginIng = false;
        });
      });
      const isProdEnv = exports("i", () => {
        return true;
      });
      const ElMessage = exports("E", (options) => {
        if (options && options.message) {
          options.message = "[AI助理] " + options.message;
        }
        ElMessage$1(options);
      });
      async function fetchWithGM_request(url, options) {
        return new Promise((resolve, reject) => {
          _GM_xmlhttpRequest({
            method: options.method || "GET",
            url,
            headers: options.headers,
            responseType: options.responseType || "json",
            // 默认为json，根据需要修改
            data: options.data,
            onload: (response) => {
              if (response.status === 200) {
                resolve(response);
              } else {
                reject(new Error(`Request failed with status: ${response.status}`));
              }
            },
            onerror: () => {
              reject(new Error("Network error"));
            },
            ontimeout: () => {
              reject(new Error("Request timed out"));
            }
          });
        });
      }
      const loginInterceptor = exports("b", () => {
        var _a, _b;
        const token = (_b = (_a = Tools.window) == null ? void 0 : _a._PAGE) == null ? void 0 : _b.token;
        if (!token) {
          ElMessage({
            message: "请先登录Boss",
            type: "error",
            duration: 3e3
          });
          return false;
        }
        return true;
      });
      const handlerImport = async (importResumeLoading) => {
        var _a, _b, _c, _d;
        if (!loginInterceptor()) {
          return;
        }
        const token = (_b = (_a = Tools.window) == null ? void 0 : _a._PAGE) == null ? void 0 : _b.token;
        let bossUserId = (_d = (_c = Tools.window) == null ? void 0 : _c._PAGE) == null ? void 0 : _d.uid;
        if (!bossUserId) {
          ElMessage({
            message: "未获取到Boss userId 请刷新页面重试",
            type: "error",
            duration: 3e3
          });
          return;
        }
        importResumeLoading.value = true;
        let resumeInfoResp = await axios.get("https://www.zhipin.com/wapi/zpgeek/resume/sidebar.json", { headers: { "Zp_token": token } });
        let zpData = resumeInfoResp.data.zpData;
        if (!zpData.attachmentList) {
          importResumeLoading.value = false;
          throw Error("请先在BOSS个人中心上传附件简历");
        }
        let resumeId = zpData.attachmentList[0].resumeId;
        let resumeFileResp = await fetchWithGM_request(
          "https://docdownload.zhipin.com/wflow/zpgeek/download/download4geek?resumeId=" + resumeId,
          { headers: { "Zp_token": token }, responseType: "arraybuffer" }
        );
        let fileBlob = new Blob([resumeFileResp.response], { type: "application/pdf" });
        let formData = new FormData();
        formData.append("file", fileBlob);
        formData.append("resumeId", resumeId);
        formData.append("uniqueId", bossUserId);
        let importResp = await request.post("/api/user/import/resume", formData, { headers: { "Content-Type": "multipart/form-data" } });
        if (importResp.data.code != 200) {
          ElMessage({
            message: "导入简历失败" + importResp.data.data.msg,
            type: "error",
            duration: 3e3
          });
          importResumeLoading.value = false;
          return;
        }
        let loginResp = await request.post("/api/user/silently/login?uniqueId=" + bossUserId);
        localStorage.setItem("Authorization", loginResp.data.data);
        if (!importResp.data.data.email) {
          importResumeLoading.value = false;
          return;
        }
        ElMessage({
          message: "导入简历成功",
          type: "success",
          duration: 3e3
        });
        importResumeLoading.value = false;
      };
      const logRecorder$1 = new LogRecorder();
      function userRemoteLoad() {
        logRecorder$1.info("加载用户偏好配置");
        const userStore2 = UserStore();
        const loginStore = LoginStore();
        if (loginStore.loginFailStatus) {
          return;
        }
        silentlyLogin("").then((_) => {
          logger$1.debug("调用接口加载用户偏好配置");
          return request.post("/api/user/userinfo", {});
        }).then((resp) => {
          var _a;
          userStore2.user = (_a = resp == null ? void 0 : resp.data) == null ? void 0 : _a.data;
          if (!(userStore2 == null ? void 0 : userStore2.user)) {
            userStore2.user = {};
            throw new Error("用户偏好配置为空");
          }
          logRecorder$1.info("加载用户偏好配置成功");
        }).catch((error) => {
          loginStore.loginFail();
          logRecorder$1.error("加载用户偏好配置失败", error.message);
        }).finally(() => {
          if (!userStore2.user.preference) {
            userStore2.user.preference = {};
          }
        });
      }
      let pushResultCounter;
      let userStore$2;
      class AbsPlatform {
        constructor() {
          __publicField(this, "logRecorder", new LogRecorder("recorder"));
          __publicField(this, "pushStatus", PushStatus.NOT_START);
          __publicField(this, "_pushMock", false);
          __publicField(this, "_selfDefPushCountLimit", -1);
          __publicField(this, "next", async () => {
            let next = this.hasNext();
            if (!next) {
              return false;
            }
            this.acquireDataPre();
            await Tools.sleep(3e3);
            return next;
          });
        }
        set pushMock(value) {
          this._pushMock = value;
        }
        set selfDefPushCountLimit(value) {
          this._selfDefPushCountLimit = value;
        }
        get selfDefPushCountLimit() {
          return this._selfDefPushCountLimit;
        }
        async startPush() {
          this.logRecorder.info("开始投递");
          pushResultCounter.clearOnceSuccessCount();
          this.pushStatus = PushStatus.PUSHING;
          do {
            let jobList = this.getJobList();
            for (const jobDetail of jobList) {
              try {
                this.preMatchJob();
                await this.matchJob(jobDetail);
                this.pushPreHandler(jobDetail);
                const pushResult = await this.push(jobDetail);
                await this.pushAfterHandler(pushResult, jobDetail);
              } catch (error) {
                switch (true) {
                  case error instanceof NotMatchException:
                    if (this.logRecorder.getLogLevel() === LogLevel.Debug) {
                      this.logRecorder.info(`工作【${error.jobTitle}】被过滤 原因：${error.message} 当前值:${error.data}`);
                    } else {
                      this.logRecorder.info(`工作【${error.jobTitle}】被过滤 原因：${error.message}`);
                    }
                    pushResultCounter.notMatchIncr();
                    break;
                  case error instanceof PushReqException:
                    this.logRecorder.warn(`工作【${error.jobTitle}】投递失败 原因：${error.message}`);
                    pushResultCounter.failIncr();
                    break;
                  case error instanceof FetchJobBossFailExp:
                    this.logRecorder.warn(`工作【${error.jobTitle}】发送自定义招呼语失败 原因：${error.message}`);
                    break;
                  case error instanceof PublishStopExp:
                    this.logRecorder.info("手动暂停投递 " + error.message);
                    return;
                  case error instanceof PublishLimitExp:
                    this.logRecorder.info("停止投递 " + error.message);
                    return;
                  default:
                    logger$1.error("未捕获异常--->", error);
                }
              }
            }
          } while (await this.next());
          this.logRecorder.info("结束投递");
        }
        pausePush() {
        }
        preMatchJob() {
          if (this._selfDefPushCountLimit !== -1 && pushResultCounter.onceSuccessCount >= this._selfDefPushCountLimit) {
            throw new PublishLimitExp("自定义投递次数限制");
          }
          if (this.pushStatus == PushStatus.PAUSE) {
            throw new PublishStopExp("手动暂停投递");
          }
        }
        async push(jobDetail) {
          if (this.pushStatus == PushStatus.PAUSE) {
            throw new PublishStopExp("手动暂停投递");
          }
          if (this._selfDefPushCountLimit !== -1 && pushResultCounter.onceSuccessCount >= this._selfDefPushCountLimit) {
            throw new PublishLimitExp("自定义投递次数限制");
          }
          let limitResult = this.isLimit(jobDetail);
          if (limitResult.limit) {
            throw new PublishLimitExp(limitResult.msg);
          }
          if (this._pushMock) {
            let jobTitle = this.getJobKey(jobDetail);
            logger$1.debug("mock投递 ", jobTitle);
            return {
              message: "Success",
              code: 0
            };
          }
          return await this.doPush(jobDetail);
        }
        isLimit(jobDetail) {
          return {
            limit: false,
            msg: this.getJobKey(jobDetail)
          };
        }
      }
      class BossPlatform extends AbsPlatform {
        constructor(curUrl) {
          super();
          __publicField(this, "curUrl");
          __publicField(this, "name", "Boss");
          __publicField(this, "urlList", ["/web/geek"]);
          __publicField(this, "bossDataCache", /* @__PURE__ */ new Map());
          this.curUrl = curUrl;
        }
        getPlatformType() {
          return 0;
        }
        getMountEle() {
          return new Promise((resolve) => {
            let count = 0;
            let interval = setInterval(() => {
              let element = null;
              if (this.curUrl.includes("www.zhipin.com/web/geek/chat")) {
                element = document.querySelector(".chat-conversation");
              }
              if (this.curUrl.includes("www.zhipin.com/web/geek/job")) {
                element = document.querySelector(".page-job-inner");
              }
              if (element !== null) {
                clearInterval(interval);
                return resolve(element);
              }
              if (count >= 3) {
                throw new PlatformError(0, "获取平台挂载元素失败");
              }
              count++;
            }, 300);
          });
        }
        async getRenderComponent() {
          if (this.curUrl.includes("www.zhipin.com/web/geek/chat")) {
            let promise = __vitePreload(() => module.import('./BossMessage-Di7vIFfl-CoSXCAVS.js'), void 0 );
            return promise.then((item) => item.default);
          }
          if (this.curUrl.includes("www.zhipin.com/web/geek/job")) {
            let promise = __vitePreload(() => module.import('./BossJobList-BEaFNNqn-CPEjjk-D.js'), void 0 );
            return promise.then((item) => item.default);
          }
        }
        getJobList() {
          let elementNodeList = document.querySelectorAll(".job-card-wrapper");
          return Array.from(elementNodeList).map((item) => item.__vue__.data);
        }
        hasNext() {
          logger$1.debug("hasNext");
          let nextPageBtn = document.querySelector(".ui-icon-arrow-right");
          if (nextPageBtn === null) {
            return false;
          }
          return nextPageBtn.parentElement.className !== "disabled";
        }
        acquireDataPre() {
          document.querySelector(".ui-icon-arrow-right").click();
        }
        async matchJob(jobDetail) {
          const jobTitle = this.getJobKey(jobDetail);
          if (jobDetail.contact) {
            throw new NotMatchException(jobTitle, jobDetail.contact, "已经沟通过");
          }
          if (userStore$2.user.preference.fhE && jobDetail.goldHunter === 1) {
            throw new NotMatchException(jobTitle, jobDetail.goldHunter, "过滤猎头");
          }
          let companyNameInclude = userStore$2.user.preference.cni;
          if (userStore$2.user.preference.cniE && !Tools.fuzzyMatch(companyNameInclude, jobDetail.brandName, true)) {
            throw new NotMatchException(jobTitle, jobDetail.brandName, "不满足配置公司名");
          }
          let companyNameExclude = userStore$2.user.preference.cne;
          if (userStore$2.user.preference.cneE && Tools.fuzzyMatch(companyNameExclude, jobDetail.brandName, false)) {
            throw new NotMatchException(jobTitle, jobDetail.brandName, "满足排除公司名");
          }
          let jobNameInclude = userStore$2.user.preference.jni;
          if (userStore$2.user.preference.jniE && !Tools.fuzzyMatch(jobNameInclude, jobDetail.jobName, true)) {
            throw new NotMatchException(jobTitle, jobDetail.jobName, "不满足配置工作名");
          }
          let pageSalaryRange = jobDetail.salaryDesc.split(".")[0];
          if (userStore$2.user.preference.srE && !Tools.isRangeOverlap(userStore$2.user.preference.sr, pageSalaryRange)) {
            throw new NotMatchException(jobTitle, pageSalaryRange, "不满足薪资范围");
          }
          let pageCompanyScaleRange = userStore$2.user.preference.csr;
          if (userStore$2.user.preference.csrE && !Tools.isRangeOverlap(pageCompanyScaleRange, jobDetail.brandScaleName)) {
            throw new NotMatchException(jobTitle, jobDetail.brandScaleName, "不满足公司规模范围");
          }
          let jobDetailExt = await this.obtainBossJobDetailExt(jobDetail);
          logger$1.debug(`获取工作【${jobTitle}】详情扩展信息用于过滤 `, jobDetail);
          let activeTimeDesc = jobDetailExt.activeTimeDesc;
          if (!this.bossIsActive(activeTimeDesc)) {
            throw new NotMatchException(jobTitle, activeTimeDesc, "不满足活跃度检查");
          }
          let jobContent = jobDetailExt.postDescription;
          let jobContentExclude = userStore$2.user.preference.jce;
          if (userStore$2.user.preference.jceE && Tools.fuzzyMatch(jobContentExclude, jobContent, false)) {
            throw new NotMatchException(jobTitle, jobContent, "不满足工作内容");
          }
          if (this.isCommunication(jobDetailExt)) {
            throw new NotMatchException(jobTitle, jobDetailExt.friendStatus, "已经沟通过");
          }
          return true;
        }
        pausePush() {
          this.pushStatus = PushStatus.PAUSE;
        }
        getJobKey(jobDetail) {
          return jobDetail.jobName + "-" + jobDetail.cityName + jobDetail.areaDistrict + jobDetail.businessDistrict;
        }
        isLimit(jobDetail) {
          return {
            limit: TampermonkeyApi.GmGetValue(TampermonkeyApi.PUSH_LIMIT, false),
            msg: "Boss投递限制每天100次"
          };
        }
        async doPush(jobDetail, errorMsg = "", retries = 3) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          const jobTitle = this.getJobKey(jobDetail);
          if (retries === 3) {
            logger$1.debug("正在投递：" + jobTitle);
          }
          if (retries === 0) {
            throw new PushReqException(jobTitle, errorMsg);
          }
          let publishUrl = `https://www.zhipin.com/wapi/zpgeek/friend/add.json?securityId=${jobDetail.securityId}&jobId=${jobDetail.encryptJobId}&lid=${jobDetail.lid}`;
          let pushResp = { code: PushResultStatus.NOT_START, message: "" };
          try {
            pushResp = await axios.post(publishUrl, null, { headers: { "Zp_token": Tools.getCookieValue("bst") } });
          } catch (error) {
            logger$1.debug(`工作【${jobTitle}】投递失败; 正在等待重试; 原因：${error.message}`);
            await Tools.sleep(800);
            return await this.doPush(jobDetail, error.message, retries - 1);
          }
          if (pushResp.data.code === PushResultStatus.FAIL && ((_d = (_c = (_b = (_a = pushResp.data) == null ? void 0 : _a.zpData) == null ? void 0 : _b.bizData) == null ? void 0 : _c.chatRemindDialog) == null ? void 0 : _d.content)) {
            return {
              code: 1,
              message: (_h = (_g = (_f = (_e = pushResp.data) == null ? void 0 : _e.zpData) == null ? void 0 : _f.bizData) == null ? void 0 : _g.chatRemindDialog) == null ? void 0 : _h.content
            };
          }
          await Tools.sleep(800);
          return pushResp.data;
        }
        async requestBossDataByCache(jobDetail) {
          let cacheKey = `${jobDetail.encryptBossId}-${jobDetail.securityId}`;
          if (this.bossDataCache.has(cacheKey)) {
            return this.bossDataCache.get(cacheKey);
          }
          const result = await this.requestBossData(jobDetail);
          this.bossDataCache.set(cacheKey, result);
          return result;
        }
        async requestBossData(jobDetail, errorMsg = "", retries = 3) {
          let jobTitle = this.getJobKey(jobDetail);
          if (retries === 0) {
            throw new FetchJobBossFailExp(jobTitle, errorMsg || "获取boss数据重试多次失败");
          }
          const url = "https://www.zhipin.com/wapi/zpchat/geek/getBossData";
          const token = Tools.getCookieValue("bst");
          if (!token) {
            throw new FetchJobBossFailExp(jobTitle, "未获取到zp-token");
          }
          const data = new FormData();
          data.append("bossId", jobDetail.encryptBossId);
          data.append("securityId", jobDetail.securityId);
          data.append("bossSrc", "0");
          let resp;
          try {
            resp = await axios({ url, data, method: "POST", headers: { Zp_token: token } });
          } catch (e) {
            return this.requestBossData(jobDetail, e.message, retries - 1);
          }
          if (resp.data.code !== 0) {
            throw new FetchJobBossFailExp(jobTitle, resp.data.message);
          }
          return resp.data.zpData;
        }
        async pushAfterHandler(pushResult, jobDetail) {
          const jobTitle = this.getJobKey(jobDetail);
          if (pushResult.message === "Success" && pushResult.code === 0) {
            pushResultCounter.successIncr();
            this.logRecorder.info(`工作【${jobTitle}】 投递成功`);
            await this.pushAfterSendImage(jobDetail);
            await this.pushAfterSendMsg(jobDetail);
            return jobDetail;
          }
          if (pushResult.message.includes("今日沟通人数已达上限")) {
            throw new PublishLimitExp(pushResult.message);
          }
          throw new PushReqException(jobTitle, pushResult.message);
        }
        /**
         * 投递后发送自定义消息
         */
        async pushAfterSendMsg(jobDetail) {
          if (!userStore$2.user.preference.cgE || this._pushMock) {
            return;
          }
          let bossData = await this.requestBossDataByCache(jobDetail);
          let customGreeting = userStore$2.user.preference.cg;
          let message = new Message({
            form_uid: Tools.window._PAGE.uid.toString(),
            to_uid: bossData.data.bossId.toString(),
            to_name: jobDetail.encryptBossId,
            content: customGreeting,
            image: void 0
          });
          message.send();
        }
        /**
         * 投递后发送自定义图片
         */
        async pushAfterSendImage(jobDetail) {
          if (!userStore$2.user.preference.cIE || this._pushMock) {
            return;
          }
          let bossData = await this.requestBossDataByCache(jobDetail);
          let customerImageSet = userStore$2.user.preference.cI;
          if (!customerImageSet) {
            return;
          }
          let message = new Message({
            form_uid: Tools.window._PAGE.uid.toString(),
            to_uid: bossData.data.bossId.toString(),
            to_name: jobDetail.encryptBossId,
            content: "",
            image: {
              originImage: customerImageSet.split("===")[0],
              tinyImage: customerImageSet.split("===")[1]
            }
          });
          message.send();
        }
        pushPreHandler(jobDetail) {
          return jobDetail;
        }
        async obtainBossJobDetailExt(jobDetail, message = "", retries = 3) {
          if (retries === 0) {
            logger$1.warn(`获取工作详情扩展信息异常,用于活跃度过滤以及工作内容过滤; 原因：${message}`);
            throw new NotMatchException(this.getJobKey(jobDetail), message, "获取工作详情扩展信息异常");
          }
          let params = `lid=${jobDetail.lid}&securityId=${jobDetail.securityId}&sessionId=`;
          try {
            let resp = await axios.get("https://www.zhipin.com/wapi/zpgeek/job/card.json?" + params, { timeout: 5e3 });
            return resp.data.zpData.jobCard;
          } catch (error) {
            logger$1.debug("获取详情页异常正在重试:", error);
            return this.obtainBossJobDetailExt(jobDetail, error.message, retries - 1);
          }
        }
        bossIsActive(activeText) {
          return !(activeText.includes("月") || activeText.includes("年") || activeText.includes("周"));
        }
        isCommunication(jobCardJson) {
          return (jobCardJson == null ? void 0 : jobCardJson.friendStatus) === 1;
        }
      }
      class Test_BaiDu extends AbsPlatform {
        constructor(curUrl) {
          super();
          __publicField(this, "curUrl");
          __publicField(this, "name", "Test_BaiDu");
          __publicField(this, "urlList", ["baidu"]);
          this.curUrl = curUrl;
        }
        acquireDataPre() {
        }
        doPush(jobDetail) {
          return Promise.resolve(void 0);
        }
        getJobKey(jobDetail) {
          return "";
        }
        getJobList() {
          return [];
        }
        getMountEle() {
          return Promise.resolve(document.body);
        }
        getPlatformType() {
          return 1;
        }
        getRenderComponent() {
          let promise = __vitePreload(() => module.import('./BossJobList-BEaFNNqn-CPEjjk-D.js'), void 0 );
          return promise.then((item) => item.default);
        }
        hasNext() {
          return false;
        }
        matchJob(jobDetail) {
          return Promise.resolve(false);
        }
        pushAfterHandler(pushResult, jobDetail) {
          return Promise.resolve(void 0);
        }
        pushPreHandler(jobDetail) {
          return jobDetail;
        }
      }
      class LiePin extends AbsPlatform {
        constructor(curUrl) {
          super();
          __publicField(this, "curUrl");
          __publicField(this, "name", "LiePin");
          __publicField(this, "urlList", ["liepin.com/zhaopin"]);
          this.curUrl = curUrl;
        }
        acquireDataPre() {
        }
        doPush(jobDetail) {
          return Promise.resolve(void 0);
        }
        getJobKey(jobDetail) {
          return "";
        }
        getJobList() {
          return [];
        }
        getMountEle() {
          return Promise.resolve(document.body);
        }
        getPlatformType() {
          return 1;
        }
        getRenderComponent() {
        }
        hasNext() {
          return false;
        }
        matchJob(jobDetail) {
          return Promise.resolve(false);
        }
        pushAfterHandler(pushResult, jobDetail) {
          return Promise.resolve(void 0);
        }
        pushPreHandler(jobDetail) {
          return jobDetail;
        }
      }
      const platformList = [BossPlatform, LiePin, Test_BaiDu];
      class PlatformFactory {
        static getInstance(url) {
          for (const PlatformClass of platformList) {
            const platformInstance = new PlatformClass(url);
            if (platformInstance.urlList.some((platformUrl) => url.includes(platformUrl))) {
              pushResultCounter = pushResultCount();
              userStore$2 = UserStore();
              userStore$2.platformType = platformInstance.getPlatformType();
              userRemoteLoad();
              return platformInstance;
            }
          }
          throw new PlatformError(3, "错误的平台");
        }
      }
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "ViewRouter",
        setup(__props) {
          const platform2 = inject("$platform");
          const renderComponent = shallowRef(null);
          platform2.getRenderComponent().then((data) => {
            renderComponent.value = data;
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(renderComponent.value));
          };
        }
      });
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "App",
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createBlock(_sfc_main$1);
          };
        }
      });
      const logger = new Logger();
      logger.setLogLevel(LogLevel.Debug);
      function encodeLength(len) {
        const output = [];
        let x = len;
        do {
          let encodedByte = x % 128;
          x = Math.floor(x / 128);
          if (x > 0) {
            encodedByte |= 128;
          }
          output.push(encodedByte);
        } while (x > 0);
        return output;
      }
      function encodeUTF8String(str2, encoder) {
        const bytes = encoder.encode(str2);
        return [bytes.length >> 8, bytes.length & 255, ...bytes];
      }
      function decodeUTF8String(buffer, startIndex, utf8Decoder) {
        const bytes = decodeUint8Array(buffer, startIndex);
        if (bytes === void 0) {
          return void 0;
        }
        const value = utf8Decoder.decode(bytes);
        return {
          length: bytes.length + 2,
          value
        };
      }
      const mqtt = {
        encode(packet) {
          const utf8 = new TextEncoder();
          const variableHeader = [...encodeUTF8String("chat", utf8)];
          if (packet.messageId) {
            variableHeader.push(packet.messageId >> 8, packet.messageId & 255);
          }
          let { payload } = packet;
          if (typeof payload === "string") {
            payload = utf8.encode(payload);
          }
          const fixedHeader = [
            3 << 4 | 3,
            // 0x00110011 qos1消息，非重传、保留消息
            ...encodeLength(variableHeader.length + payload.length)
          ];
          return Uint8Array.from([...fixedHeader, ...variableHeader, ...payload]);
        },
        decode(buffer, flags = 3) {
          const dup = !!(flags & 8);
          const qos = (flags & 6) >> 1;
          const { length: remainingLength, bytesUsedToEncodeLength } = decodeLength(
            buffer,
            1
          );
          const retain = !!(flags & 1);
          const utf = new TextDecoder("utf-8");
          const topicStart = bytesUsedToEncodeLength + 1;
          let decodedTopic = decodeUTF8String(buffer, topicStart, utf);
          if (decodedTopic === void 0) {
            logger.trace("空主题");
            decodedTopic = { length: 0, value: "" };
          }
          const topic = decodedTopic.value;
          let id = 0;
          let payloadStart = topicStart + decodedTopic.length;
          if (qos > 0) {
            const idStart = payloadStart;
            try {
              id = parseMessageId(buffer, idStart);
            } catch {
              logger.trace(`错的id?: `, {
                payloadStart,
                topicStart,
                topic,
                dup,
                qos,
                remainingLength,
                retain
              });
            }
            payloadStart += 2;
          }
          const payload = buffer.subarray(payloadStart);
          return {
            topic,
            payload,
            dup,
            retain,
            qos,
            messageId: id
          };
        }
      };
      function decodeLength(buffer, startIndex) {
        let i = startIndex;
        let encodedByte = 0;
        let value = 0;
        let multiplier = 1;
        do {
          encodedByte = buffer[i];
          i += 1;
          value += (encodedByte & 127) * multiplier;
          if (multiplier > 128 * 128 * 128) {
            throw Error("malformed length");
          }
          multiplier *= 128;
        } while ((encodedByte & 128) !== 0);
        return { length: value, bytesUsedToEncodeLength: i - startIndex };
      }
      function parseMessageId(buffer, startIndex) {
        if (startIndex + 2 > buffer.length) {
          throw new Error("Cannot parse messageId");
        }
        return buffer[startIndex] << 8 | buffer[startIndex + 1];
      }
      function decodeUint8Array(buffer, startIndex) {
        if (startIndex >= buffer.length || startIndex + 2 > buffer.length) {
          return void 0;
        }
        const length = (buffer[startIndex] << 8) + buffer[startIndex + 1];
        const bytes = buffer.subarray(startIndex + 2, startIndex + 2 + length);
        return bytes;
      }
      function decodeMqttAndProtobuf(data, caller) {
        let uint8Array = new Uint8Array(data);
        let mqttDecodeResult;
        try {
          mqttDecodeResult = mqtt.decode(uint8Array);
          if (mqttDecodeResult.topic !== "chat") {
            logger$1.trace("过滤【非chat】主题", mqttDecodeResult);
            return;
          }
          let chatProtocolObj = protobufType.decode(mqttDecodeResult.payload);
          if ((chatProtocolObj == null ? void 0 : chatProtocolObj.messages.length) !== 0) {
            logger$1.debug(caller + "【消息mqtt】：", mqttDecodeResult);
            logger$1.debug(caller + "【消息对象】：", chatProtocolObj);
            if (chatProtocolObj.messages[0].body.type === 7) {
              chatProtocolObj.messages[0].body.text = new TextDecoder().decode(mqttDecodeResult.payload);
            }
            if (!chatProtocolObj.messages[0].body.text && caller !== "发送") {
              chatProtocolObj.messages[0].body.text = new TextDecoder().decode(mqttDecodeResult.payload);
            }
          } else {
            logger$1.debug(caller + "【非消息协议对象】", chatProtocolObj);
          }
          return chatProtocolObj;
        } catch (e) {
          logger$1.debug("解码失败", mqttDecodeResult, e);
        }
      }
      function getMsgBody(data) {
        var _a, _b;
        let messages = data == null ? void 0 : data.messages;
        if (!messages) {
          return "";
        }
        return (_b = (_a = messages == null ? void 0 : messages[0]) == null ? void 0 : _a.body) == null ? void 0 : _b.text;
      }
      function normalizeNumber(number) {
        if (typeof number === "string" || typeof number === "number") {
          return number;
        } else if ("low" in number) {
          return number.toNumber();
        }
        return 0;
      }
      var JobSeekerClonedAnswerTypeEnum = /* @__PURE__ */ ((JobSeekerClonedAnswerTypeEnum2) => {
        JobSeekerClonedAnswerTypeEnum2[JobSeekerClonedAnswerTypeEnum2["MSG_TEXT"] = 1] = "MSG_TEXT";
        JobSeekerClonedAnswerTypeEnum2[JobSeekerClonedAnswerTypeEnum2["BOSS_OPERATION"] = 2] = "BOSS_OPERATION";
        JobSeekerClonedAnswerTypeEnum2[JobSeekerClonedAnswerTypeEnum2["STOP"] = 3] = "STOP";
        JobSeekerClonedAnswerTypeEnum2[JobSeekerClonedAnswerTypeEnum2["AI_SERVICE_EXCEPTION"] = 4] = "AI_SERVICE_EXCEPTION";
        return JobSeekerClonedAnswerTypeEnum2;
      })(JobSeekerClonedAnswerTypeEnum || {});
      var BossOperationTypeEnum = /* @__PURE__ */ ((BossOperationTypeEnum2) => {
        BossOperationTypeEnum2[BossOperationTypeEnum2["SEND_RESUME"] = 1] = "SEND_RESUME";
        return BossOperationTypeEnum2;
      })(BossOperationTypeEnum || {});
      class AiPower {
        static async ask(question, jobKey, bossUserInfo) {
          return request.post(
            "/api/job/seeker/cloned/ask",
            {
              question,
              jobKey,
              jobInfo: {
                // 完整的title需要调用getBossData接口获取，代价较大; 这暂时用jobTitle代替
                jobTitle: bossUserInfo.jobTitle
              }
            },
            {
              // ask接口超时时间设为30s；部分ai回复较慢
              timeout: 9e4
            }
          );
        }
        static async updateAskStatus(jobKey, stop) {
          return request.post(`/api/job/seeker/cloned/change/session/status?jobKey=${jobKey}&stop=${stop}`);
        }
      } exports("A", AiPower);
      let userStore$1 = null;
      const _BossOption = class _BossOption {
        constructor() {
          if (!userStore$1) {
            userStore$1 = UserStore();
          }
        }
        /**
         * 前置回复boss消息
         * 针对boss发起的简历，联系方式，微信等需求，用于回复简历，联系方式，微信等
         */
        async preReplyMsg(msgObj, bossUserInfo, text) {
          let type;
          if (text.includes("交换微信")) {
            type = 2;
          } else if (text.includes("交换联系方式") || text.includes("我想要一个您的电话号码，您是否同意")) {
            type = 1;
          } else if (text.includes("我想要一份您的附件简历，您是否同意")) {
            type = 4;
          } else if (text.includes("是否接受此工作地点")) {
            return;
          } else if (text.includes("您对本职位的求职过程满意吗")) {
            return;
          } else {
            logger$1.info("【处理Boss消息-失败】未知类型消息", text);
          }
          let mid = msgObj.messages[0].mid;
          axios.post("https://www.zhipin.com/wapi/zpchat/exchange/accept", {
            securityId: bossUserInfo.securityId,
            type,
            mid: mid.toString(),
            ...type === 4 ? { encryptResumeId: userStore$1.user.resumeId } : {}
          }, {
            headers: {
              "Zp_token": Tools.getCookieValue("bst"),
              "content-type": "application/x-www-form-urlencoded;charset=UTF-8"
            }
          }).then((_) => {
          }).catch((_) => {
          });
        }
        preHandlerMsgByBodyType(msgObj, bossUserInfo, text) {
          const bodyType = msgObj.messages[0].body.type;
          switch (bodyType) {
            case 7:
              logger$1.debug("【处理Boss消息】boss索要简历，联系方式，微信", text, msgObj);
              this.preReplyMsg(msgObj, bossUserInfo, text).then();
              return false;
            case 12:
            case 4:
            case 8:
            case 14:
              logger$1.debug("【处理Boss消息】系统消息", text, msgObj);
              return false;
            case 1:
              if (text.includes("&lt;/phone&gt;") || text.includes("&lt;/copy&gt;")) {
                logger$1.debug("【处理Boss消息】过滤处理过的索要联系方式消息", text, msgObj);
                return false;
              }
              if (text.includes("对方拒绝了您的发送请求")) {
                logger$1.debug("【处理Boss消息】hr拒绝简历的普通消息", text, msgObj);
                return false;
              }
              if (text === "方便发一份简历过来吗？") {
                return false;
              }
          }
          return !!text;
        }
        preHandlerMsgByMsgType(msgObj, text) {
          const msgType = msgObj.messages[0].type;
          switch (msgType) {
            case 1:
              return true;
            case 3:
              return true;
            case 4:
              logger$1.debug("【处理Boss消息-忽略】boss系统提示消息", text);
              return false;
            default:
              return true;
          }
        }
        async handlerBossMessage(msgObj, bossId, text) {
          if (_BossOption.messageCache.isMessageProcessed(bossId, text)) {
            logger$1.trace("【跳过重复消息】:", bossId, text);
            return;
          }
          _BossOption.messageCache.markMessageAsProcessed(bossId, text);
          if (!userStore$1.user.aiSeatStatus) {
            logger$1.info("AI坐席未开启，不处理消息");
            return;
          }
          if (!this.preHandlerMsgByMsgType(msgObj, text)) {
            return;
          }
          const bossUserInfo = await this.getBossUserInfoByBossId(bossId);
          if (!bossUserInfo) {
            const bodyType = msgObj.messages[0].body.type;
            if (bodyType === 15) {
              return;
            }
            _BossOption.logRecorder.error("【处理Boss消息-失败】无法获取联系人信息", text);
            return;
          }
          if (!this.preHandlerMsgByBodyType(msgObj, bossUserInfo, text)) {
            return;
          }
          logger$1.debug("接收消息解码内容：", text);
          const jobKey = _BossOption.buildJobKey(bossUserInfo);
          return AiPower.ask(text, jobKey, bossUserInfo).then((resp) => {
            var _a;
            let data = resp.data.data;
            let answerTypeList = data == null ? void 0 : data.answerTypeList;
            if (answerTypeList.includes(JobSeekerClonedAnswerTypeEnum.STOP)) {
              logger$1.info("【处理Boss消息-忽略】停止交互");
              return Promise.resolve();
            }
            if (answerTypeList.includes(JobSeekerClonedAnswerTypeEnum.AI_SERVICE_EXCEPTION)) {
              logger$1.info("AI服务异常，暂时无法处理消息");
              ElMessage({
                type: "error",
                message: "AI服务异常，暂时无法处理消息（请联系管理员处理）"
              });
              return Promise.resolve();
            }
            if (answerTypeList.includes(JobSeekerClonedAnswerTypeEnum.MSG_TEXT)) {
              this.sendMsg(bossId, data.answerContent + Tools.getEndChar(), void 0);
            }
            if (answerTypeList.includes(JobSeekerClonedAnswerTypeEnum.BOSS_OPERATION)) {
              (_a = data == null ? void 0 : data.operationTypeList) == null ? void 0 : _a.includes(BossOperationTypeEnum.SEND_RESUME);
              {
                this.sendResumeFile(bossId).then((_) => {
                });
              }
            }
            new MessageRead({
              userId: bossUserInfo.bossId,
              messageId: msgObj.messages[0].mid
            }).send();
            setTimeout(() => {
              const bossEleList = Array.from(document.querySelectorAll(".friend-content"));
              bossEleList.filter((bossEle) => {
                var _a2, _b, _c;
                return bossUserInfo.bossId === ((_c = (_b = (_a2 = bossEle == null ? void 0 : bossEle.__vue__) == null ? void 0 : _a2._props) == null ? void 0 : _b.source) == null ? void 0 : _c.uid);
              }).forEach((bossEle) => {
                bossEle.querySelectorAll(".notice-badge").forEach((badgeEle) => {
                  badgeEle.remove();
                  return;
                });
              });
            }, 500);
          });
        }
        sendMsg(bossId, msg, image) {
          this.getBossUserInfoByBossId(bossId).then((bossUserInfo) => {
            if (!bossUserInfo) {
              _BossOption.logRecorder.error("发送消息失败，联系人信息获取失败");
              return;
            }
            let message = new Message({
              form_uid: Tools.window._PAGE.uid.toString(),
              to_uid: bossId.toString(),
              to_name: bossUserInfo.encryptBossId,
              content: msg,
              image: void 0
            });
            message.send();
          });
        }
        async sendResumeFile(bossId) {
          let resumeId = userStore$1.user.resumeId;
          if (!resumeId) {
            return;
          }
          return this.getBossUserInfoByBossId(bossId).then((bossUserInfo) => {
            if (!bossUserInfo) {
              _BossOption.logRecorder.error("发送简历失败，联系人信息获取失败");
              return;
            }
            axios.post("https://www.zhipin.com/wapi/zpchat/exchange/request", {
              securityId: bossUserInfo.securityId,
              type: 3,
              encryptResumeId: resumeId
            }, {
              headers: {
                "Zp_token": Tools.getCookieValue("bst"),
                "content-type": "application/x-www-form-urlencoded;charset=UTF-8"
              }
            }).then((_) => {
            }).catch((_) => {
            });
          });
        }
        static getJobKeyByCache(bossId) {
          let bossUserInfo = _BossOption.getBossUserInfoByCache(bossId);
          if (!bossUserInfo) {
            return "";
          }
          return this.buildJobKey(bossUserInfo);
        }
        static getBossUserInfoByCache(bossId) {
          return _BossOption.bossUserInfoMap.get(bossId);
        }
        static buildJobKey(bossUserInfo) {
          if (!bossUserInfo) {
            return "";
          }
          return bossUserInfo.encryptJobId + ":" + Tools.window._PAGE.uid;
        }
        static async loadRecentContact() {
          this.obtainRecentContactBossId().then((bossIdList) => this.obtainBossUserInfo(bossIdList)).then((bossUserInfoList) => {
            bossUserInfoList.forEach((bossUserInfo) => {
              this.bossUserInfoMap.set(bossUserInfo.bossId, bossUserInfo);
            });
          }).catch((e) => {
            logger$1.error("加载最近联系人失败", e);
          });
        }
        async getBossUserInfoByBossId(bossId) {
          let bossUserInfo = _BossOption.bossUserInfoMap.get(bossId);
          if (bossUserInfo) {
            return bossUserInfo;
          }
          let bossUserInfoList = await _BossOption.obtainBossUserInfo([bossId]);
          if (bossUserInfoList.length === 0) {
            return void 0;
          }
          _BossOption.bossUserInfoMap.set(bossId, bossUserInfoList[0]);
          return bossUserInfoList[0];
        }
        static async obtainRecentContactBossId() {
          var _a;
          let resp = await axios.get("https://www.zhipin.com/wapi/zprelation/friend/geekFilterByLabel?labelId=0");
          if (resp.data.message === "当前登录状态已失效") {
            throw new Error("未登录Boss");
          }
          let friendList = (_a = resp.data.zpData) == null ? void 0 : _a.friendList;
          if (!friendList || !(friendList == null ? void 0 : friendList.length) || (friendList == null ? void 0 : friendList.length) === 0) {
            return [];
          }
          return friendList.map((friend) => friend.friendId);
        }
        static async obtainBossUserInfo(bossIdList) {
          var _a;
          let bossIdListStr = bossIdList.map((bossId) => bossId.toString()).join(",");
          let resp = await axios.get("https://www.zhipin.com/wapi/zprelation/friend/getGeekFriendList.json?friendIds=" + bossIdListStr);
          let friendList = (_a = resp.data.zpData) == null ? void 0 : _a.result;
          if (friendList.length === 0) {
            return [];
          }
          return friendList.map((friend) => {
            return {
              bossId: friend.uid,
              encryptBossId: friend.encryptBossId,
              securityId: friend.securityId,
              encryptJobId: friend.encryptJobId,
              jobTitle: friend.brandName + "-" + friend.title + "-" + friend.name
            };
          });
        }
      };
      __publicField(_BossOption, "bossUserInfoMap", /* @__PURE__ */ new Map());
      __publicField(_BossOption, "logRecorder", new LogRecorder("recorder"));
      __publicField(_BossOption, "messageCache", new MessageCache());
      _BossOption.loadRecentContact().then((_) => {
      });
      let BossOption = exports("B", _BossOption);
      logger$1.info("websocketHook执行");
      const originalWebSocket = window.WebSocket;
      const TARGET_URL = "chat";
      const logRecorder = new LogRecorder("recorder");
      let sendInterceptor = null;
      let receiveInterceptor = null;
      let hookSuccess = false;
      let hookMap = /* @__PURE__ */ new Map();
      class WebSocketProxy extends originalWebSocket {
        constructor(url, protocols) {
          super(url, protocols);
          const shouldHook = url.includes(TARGET_URL);
          if (!shouldHook) {
            return this;
          }
          if (hookMap.has(shouldHook)) {
            logger$1.info("重复Hook WebSocket:", url);
            hookSuccess = true;
            return;
          }
          hookMap.set(shouldHook, this);
          logger$1.info("Hook WebSocket:", url);
          logRecorder.info("WS Hook成功");
          hookSuccess = true;
          const originalOnMessage = this.onmessage;
          Object.defineProperty(this, "onmessage", {
            set: (fn) => {
              this.addEventListener("message", (event) => {
                if (receiveInterceptor) {
                  const modifiedData = receiveInterceptor(event.data);
                  const clonedEvent = new MessageEvent("message", {
                    data: modifiedData
                  });
                  fn.call(this, clonedEvent);
                } else {
                  fn.call(this, event);
                }
              });
            },
            get: () => originalOnMessage
          });
          const originalSend = this.send;
          this.send = (data) => {
            if (sendInterceptor) {
              data = sendInterceptor(data);
            }
            return originalSend.call(this, data);
          };
        }
      }
      Tools.window.WebSocket = WebSocketProxy;
      function wsReConnection() {
        setTimeout(() => {
          if (!hookSuccess) {
            logger$1.info("重连Hook WS");
            try {
              Tools.window.ChatWebsocket.close();
              Tools.window.ChatWebsocket.connection();
            } catch (e) {
              if (e.message.includes("disconnect")) {
                logger$1.info("无WS连接");
                return;
              }
              logger$1.error("重连Hook WS失败", e);
            }
          }
        }, 2e3);
      }
      if (Tools.window.ChatWebsocket) {
        wsReConnection();
      } else {
        setChatWebsocket().then(() => {
          setTimeout(() => {
            Tools.window.ChatWebsocket.init();
          }, 1e3);
        });
      }
      function setSendInterceptor(interceptor) {
        sendInterceptor = interceptor;
      }
      function setReceiveInterceptor(interceptor) {
        receiveInterceptor = interceptor;
      }
      setSendInterceptor((data) => {
        logger$1.trace("发送消息原始数据：", data);
        let wsData = decodeMqttAndProtobuf(data, "发送");
        if (!(wsData && (wsData == null ? void 0 : wsData.messages.length) >= 1)) {
          return data;
        }
        let msgText = getMsgBody(wsData);
        let toUid = normalizeNumber(wsData.messages[0].to.uid);
        if (!toUid) {
          return data;
        }
        logger$1.debug("发送消息解码内容：", msgText);
        if (msgText.endsWith(Tools.getEndChar()) || isCustomerMsg(msgText, wsData)) {
          return data;
        }
        let bossUserCache = BossOption.getBossUserInfoByCache(toUid);
        if (!bossUserCache) {
          return data;
        }
        if (msgText === "start") {
          let bossUserCache2 = BossOption.getBossUserInfoByCache(toUid);
          if (!bossUserCache2) {
            return;
          }
          AiPower.updateAskStatus(BossOption.buildJobKey(bossUserCache2), false).then((resp) => logRecorder.info(`[${bossUserCache2 == null ? void 0 : bossUserCache2.jobTitle}] 命令启动AI交流：${resp.data.data}`));
          return;
        }
        AiPower.updateAskStatus(BossOption.buildJobKey(bossUserCache), true).then((resp) => logRecorder.info(`[${bossUserCache == null ? void 0 : bossUserCache.jobTitle}] 手动介入关闭AI交流：${resp.data.data}`));
        return data;
      });
      setReceiveInterceptor((data) => {
        logger$1.trace("接收消息原始数据：", data);
        let wsData = decodeMqttAndProtobuf(data, "接收");
        if (!(wsData && (wsData == null ? void 0 : wsData.messages.length) >= 1)) {
          return data;
        }
        let msgBody = getMsgBody(wsData);
        let fromUid = normalizeNumber(wsData.messages[0].from.uid);
        if (!fromUid) {
          return data;
        }
        if (Tools.window._PAGE.uid === fromUid) {
          logger$1.debug("接收到自己的消息='" + msgBody + "'");
          return data;
        }
        if (!userStore) {
          userStore = UserStore();
        }
        if (!userStore.user.aiSeatStatus) {
          logger$1.info("AI坐席未开启结束-前置");
          return data;
        }
        let bossOption = new BossOption();
        bossOption.handlerBossMessage(wsData, fromUid, msgBody).then();
        return data;
      });
      let userStore;
      function isCustomerMsg(msg, wsData) {
        var _a, _b, _c, _d;
        if (!userStore) {
          userStore = UserStore();
        }
        if (msg === ((_b = (_a = userStore == null ? void 0 : userStore.user) == null ? void 0 : _a.preference) == null ? void 0 : _b.cg)) {
          return true;
        }
        return (_d = (_c = wsData.messages[0]) == null ? void 0 : _c.body) == null ? void 0 : _d.image;
      }
      async function setChatWebsocket() {
        return fetch("https://static.zhipin.com/assets/zhipin/geek/socket.js?v=20250313").then((res) => res.text()).then((code) => {
          let str = '\nTools.window.ChatWebsocket = ChatWebsocket;\nconsole.log("set ChatWebsocket 成功", ChatWebsocket);\n})();\n';
          let startIdx = code.lastIndexOf("\n})();\n");
          let modifiedCode = code.slice(0, startIdx) + str;
          eval(modifiedCode);
          logger$1.info("window 挂载 ChatWebsocket", Tools.window.ChatWebsocket);
          return Promise.resolve();
        }).catch((err) => {
          logger$1.info("window 挂载 ChatWebsocket 失败", err);
        });
      }
      var zhCn = {
        name: "zh-cn",
        el: {
          breadcrumb: {
            label: "面包屑"
          },
          colorpicker: {
            confirm: "确定",
            clear: "清空"
          },
          datepicker: {
            now: "此刻",
            today: "今天",
            cancel: "取消",
            clear: "清空",
            confirm: "确定",
            selectDate: "选择日期",
            selectTime: "选择时间",
            startDate: "开始日期",
            startTime: "开始时间",
            endDate: "结束日期",
            endTime: "结束时间",
            prevYear: "前一年",
            nextYear: "后一年",
            prevMonth: "上个月",
            nextMonth: "下个月",
            year: "年",
            month1: "1 月",
            month2: "2 月",
            month3: "3 月",
            month4: "4 月",
            month5: "5 月",
            month6: "6 月",
            month7: "7 月",
            month8: "8 月",
            month9: "9 月",
            month10: "10 月",
            month11: "11 月",
            month12: "12 月",
            weeks: {
              sun: "日",
              mon: "一",
              tue: "二",
              wed: "三",
              thu: "四",
              fri: "五",
              sat: "六"
            },
            months: {
              jan: "一月",
              feb: "二月",
              mar: "三月",
              apr: "四月",
              may: "五月",
              jun: "六月",
              jul: "七月",
              aug: "八月",
              sep: "九月",
              oct: "十月",
              nov: "十一月",
              dec: "十二月"
            }
          },
          select: {
            loading: "加载中",
            noMatch: "无匹配数据",
            noData: "无数据",
            placeholder: "请选择"
          },
          cascader: {
            noMatch: "无匹配数据",
            loading: "加载中",
            placeholder: "请选择",
            noData: "暂无数据"
          },
          pagination: {
            goto: "前往",
            pagesize: "条/页",
            total: "共 {total} 条",
            pageClassifier: "页",
            page: "页",
            prev: "上一页",
            next: "下一页",
            currentPage: "第 {pager} 页",
            prevPages: "向前 {pager} 页",
            nextPages: "向后 {pager} 页",
            deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档"
          },
          messagebox: {
            title: "提示",
            confirm: "确定",
            cancel: "取消",
            error: "输入的数据不合法!"
          },
          upload: {
            deleteTip: "按 delete 键可删除",
            delete: "删除",
            preview: "查看图片",
            continue: "继续上传"
          },
          table: {
            emptyText: "暂无数据",
            confirmFilter: "筛选",
            resetFilter: "重置",
            clearFilter: "全部",
            sumText: "合计"
          },
          tour: {
            next: "下一步",
            previous: "上一步",
            finish: "结束导览"
          },
          tree: {
            emptyText: "暂无数据"
          },
          transfer: {
            noMatch: "无匹配数据",
            noData: "无数据",
            titles: ["列表 1", "列表 2"],
            filterPlaceholder: "请输入搜索内容",
            noCheckedFormat: "共 {total} 项",
            hasCheckedFormat: "已选 {checked}/{total} 项"
          },
          image: {
            error: "加载失败"
          },
          pageHeader: {
            title: "返回"
          },
          popconfirm: {
            confirmButtonText: "确定",
            cancelButtonText: "取消"
          },
          carousel: {
            leftArrow: "上一张幻灯片",
            rightArrow: "下一张幻灯片",
            indicator: "幻灯片切换至索引 {index}"
          }
        }
      };
      const app = createApp(_sfc_main);
      app.use(createPinia());
      app.use(ElementPlus, {
        locale: zhCn
      });
      const platform = PlatformFactory.getInstance(location.href);
      app.provide("$platform", platform);
      app.provide("$axios", request);
      const rootApp = document.createElement("div");
      rootApp.id = "ai-job";
      rootApp.classList.add("page-job-content");
      window.onload = () => {
        app.mount(
          (() => {
            platform.getMountEle().then((containerEle) => {
              containerEle.insertBefore(
                rootApp,
                containerEle.firstElementChild
              );
            });
            return rootApp;
          })()
        );
      };

    })
  };
}));

System.register("./BossMessage-Di7vIFfl-CoSXCAVS.js", ['./el-button-BjSbSE-J-CBPRPyOw.js', 'vue', './__monkey.entry-Ca4ph1Aa.js', 'protobufjs', 'pinia', 'element-plus'], (function (exports, module) {
  'use strict';
  var ElButton, defineComponent, openBlock, createElementBlock, Fragment, createVNode, withCtx, createTextVNode, createElementVNode, ElMessage, BossOption, AiPower;
  return {
    setters: [module => {
      ElButton = module.E;
    }, module => {
      defineComponent = module.defineComponent;
      openBlock = module.openBlock;
      createElementBlock = module.createElementBlock;
      Fragment = module.Fragment;
      createVNode = module.createVNode;
      withCtx = module.withCtx;
      createTextVNode = module.createTextVNode;
      createElementVNode = module.createElementVNode;
    }, module => {
      ElMessage = module.E;
      BossOption = module.B;
      AiPower = module.A;
    }, null, null, null],
    execute: (function () {

      const _hoisted_1 = /* @__PURE__ */ createElementVNode("br", null, null, -1);
      const _sfc_main = exports("default", /* @__PURE__ */ defineComponent({
        __name: "BossMessage",
        setup(__props) {
          const handlerClick = () => {
            var _a, _b, _c;
            const element = document.querySelector(".friend-content.selected");
            const encryptJobId = (_c = (_b = (_a = element == null ? void 0 : element.__vue__) == null ? void 0 : _a._props) == null ? void 0 : _b.source) == null ? void 0 : _c.encryptJobId;
            if (!encryptJobId) {
              ElMessage({
                type: "info",
                message: "请先进入聊天窗口"
              });
              return;
            }
            const jobKey = BossOption.buildJobKey({ encryptJobId });
            AiPower.updateAskStatus(jobKey, false).then((_) => {
              ElMessage({
                type: "success",
                message: "已重新触发AI坐席"
              });
            });
          };
          return (_ctx, _cache) => {
            const _component_el_button = ElButton;
            return openBlock(), createElementBlock(Fragment, null, [
              _hoisted_1,
              createVNode(_component_el_button, {
                style: { "margin-left": "10px" },
                type: "success",
                onClick: handlerClick
              }, {
                default: withCtx(() => [
                  createTextVNode("重启当前会话AI坐席")
                ]),
                _: 1
              })
            ], 64);
          };
        }
      }));

    })
  };
}));

System.register("./BossJobList-BEaFNNqn-CPEjjk-D.js", ['vue', './el-button-BjSbSE-J-CBPRPyOw.js', './__monkey.entry-Ca4ph1Aa.js', 'event-source-polyfill', 'element-plus', 'protobufjs', 'pinia'], (function (exports, module) {
  'use strict';
  var ref, defineComponent, computed$1, watch, provide, reactive, toRefs, openBlock, createElementBlock, normalizeClass, unref, renderSlot, inject, onMounted, onBeforeUnmount, onUpdated, createVNode, Fragment, useSlots, withCtx, createBlock, resolveDynamicComponent, normalizeStyle, createTextVNode, toDisplayString, createCommentVNode, createElementVNode, TransitionGroup, useAttrs$1, shallowRef, nextTick, toRef, mergeProps, withModifiers, withDirectives, cloneVNode, Text$1, Comment, Teleport, Transition, vShow, readonly, onDeactivated, isRef, vModelCheckbox, toHandlers, h$1, createSlots, markRaw, effectScope, renderList, withKeys, getCurrentInstance, watchEffect, onUnmounted, onBeforeMount, isVNode, toRaw$1, onScopeDispose, resolveComponent, resolveDirective, vModelText, render, pushScopeId, popScopeId, createStaticVNode, isSymbol$1, buildProp, buildProps, definePropType, useFormSize, useNamespace, formContextKey, formItemContextKey, useId, refDebounced, addUnit, isBoolean, isString, withInstall, withNoopInstall, useFormItem, useFormItemInputId, useFormDisabled, ValidateComponentsMap, view_default, hide_default, isNil, ElIcon, NOOP, circle_close_default, isObject$1, isElement, useSizeProp, isArray$1, clock_default, calendar_default, isClient, close_default, isNumber, useDeprecated, full_screen_default, scale_to_original_default, arrow_left_default, arrow_right_default, zoom_out_default, zoom_in_default, refresh_left_default, refresh_right_default, isUndefined$1, arrow_down_default, minus_default, arrow_up_default, plus_default, iconPropType, d_arrow_left_default, more_filled_default, d_arrow_right_default, warning_filled_default, circle_check_default, check_default, isFunction$1, loading_default, addClass, removeClass, document_default, delete_default, resolveUnref, isString$1, noop$1, tryOnScopeDispose, isIOS, identity$1, fromPairs, useGetDerivedNamespace, useIdInjection, useGlobalConfig, componentSizes, _export_sfc$1, isEmpty, isPropAbsent, CloseComponents, hasClass, useTimeoutFn, more_default, toRawType, isPromise, hasOwn, isPlainObject$1, tryOnMounted, getStyle, isDate, defaultNamespace, useThrottleFn, TinyColor, isFunction$1$1, isDef, hasChanged, ElButton, PushStatus, LoginStore, pushResultCount, UserStore, logger$1, silentlyLogin, isProdEnv, Tools, LogRecorder, loginInterceptor, ElMessage, axios, fetchWithGM_request, EventSourcePolyfill, ElNotification;
  return {
    setters: [module => {
      ref = module.ref;
      defineComponent = module.defineComponent;
      computed$1 = module.computed;
      watch = module.watch;
      provide = module.provide;
      reactive = module.reactive;
      toRefs = module.toRefs;
      openBlock = module.openBlock;
      createElementBlock = module.createElementBlock;
      normalizeClass = module.normalizeClass;
      unref = module.unref;
      renderSlot = module.renderSlot;
      inject = module.inject;
      onMounted = module.onMounted;
      onBeforeUnmount = module.onBeforeUnmount;
      onUpdated = module.onUpdated;
      createVNode = module.createVNode;
      Fragment = module.Fragment;
      useSlots = module.useSlots;
      withCtx = module.withCtx;
      createBlock = module.createBlock;
      resolveDynamicComponent = module.resolveDynamicComponent;
      normalizeStyle = module.normalizeStyle;
      createTextVNode = module.createTextVNode;
      toDisplayString = module.toDisplayString;
      createCommentVNode = module.createCommentVNode;
      createElementVNode = module.createElementVNode;
      TransitionGroup = module.TransitionGroup;
      useAttrs$1 = module.useAttrs;
      shallowRef = module.shallowRef;
      nextTick = module.nextTick;
      toRef = module.toRef;
      mergeProps = module.mergeProps;
      withModifiers = module.withModifiers;
      withDirectives = module.withDirectives;
      cloneVNode = module.cloneVNode;
      Text$1 = module.Text;
      Comment = module.Comment;
      Teleport = module.Teleport;
      Transition = module.Transition;
      vShow = module.vShow;
      readonly = module.readonly;
      onDeactivated = module.onDeactivated;
      isRef = module.isRef;
      vModelCheckbox = module.vModelCheckbox;
      toHandlers = module.toHandlers;
      h$1 = module.h;
      createSlots = module.createSlots;
      markRaw = module.markRaw;
      effectScope = module.effectScope;
      renderList = module.renderList;
      withKeys = module.withKeys;
      getCurrentInstance = module.getCurrentInstance;
      watchEffect = module.watchEffect;
      onUnmounted = module.onUnmounted;
      onBeforeMount = module.onBeforeMount;
      isVNode = module.isVNode;
      toRaw$1 = module.toRaw;
      onScopeDispose = module.onScopeDispose;
      resolveComponent = module.resolveComponent;
      resolveDirective = module.resolveDirective;
      vModelText = module.vModelText;
      render = module.render;
      pushScopeId = module.pushScopeId;
      popScopeId = module.popScopeId;
      createStaticVNode = module.createStaticVNode;
    }, module => {
      isSymbol$1 = module.i;
      buildProp = module.b;
      buildProps = module.a;
      definePropType = module.d;
      useFormSize = module.u;
      useNamespace = module.c;
      formContextKey = module.f;
      formItemContextKey = module.e;
      useId = module.g;
      refDebounced = module.r;
      addUnit = module.h;
      isBoolean = module.j;
      isString = module.k;
      withInstall = module.w;
      withNoopInstall = module.l;
      useFormItem = module.m;
      useFormItemInputId = module.n;
      useFormDisabled = module.o;
      ValidateComponentsMap = module.V;
      view_default = module.v;
      hide_default = module.p;
      isNil = module.q;
      ElIcon = module.s;
      NOOP = module.N;
      circle_close_default = module.t;
      isObject$1 = module.x;
      isElement = module.y;
      useSizeProp = module.z;
      isArray$1 = module.A;
      clock_default = module.B;
      calendar_default = module.C;
      isClient = module.D;
      close_default = module.F;
      isNumber = module.G;
      useDeprecated = module.H;
      full_screen_default = module.I;
      scale_to_original_default = module.J;
      arrow_left_default = module.K;
      arrow_right_default = module.L;
      zoom_out_default = module.M;
      zoom_in_default = module.O;
      refresh_left_default = module.P;
      refresh_right_default = module.Q;
      isUndefined$1 = module.R;
      arrow_down_default = module.S;
      minus_default = module.T;
      arrow_up_default = module.U;
      plus_default = module.W;
      iconPropType = module.X;
      d_arrow_left_default = module.Y;
      more_filled_default = module.Z;
      d_arrow_right_default = module._;
      warning_filled_default = module.$;
      circle_check_default = module.a0;
      check_default = module.a1;
      isFunction$1 = module.a2;
      loading_default = module.a3;
      addClass = module.a4;
      removeClass = module.a5;
      document_default = module.a6;
      delete_default = module.a7;
      resolveUnref = module.a8;
      isString$1 = module.a9;
      noop$1 = module.aa;
      tryOnScopeDispose = module.ab;
      isIOS = module.ac;
      identity$1 = module.ad;
      fromPairs = module.ae;
      useGetDerivedNamespace = module.af;
      useIdInjection = module.ag;
      useGlobalConfig = module.ah;
      componentSizes = module.ai;
      _export_sfc$1 = module.aj;
      isEmpty = module.ak;
      isPropAbsent = module.al;
      CloseComponents = module.am;
      hasClass = module.an;
      useTimeoutFn = module.ao;
      more_default = module.ap;
      toRawType = module.aq;
      isPromise = module.ar;
      hasOwn = module.as;
      isPlainObject$1 = module.at;
      tryOnMounted = module.au;
      getStyle = module.av;
      isDate = module.aw;
      defaultNamespace = module.ax;
      useThrottleFn = module.ay;
      TinyColor = module.az;
      isFunction$1$1 = module.aA;
      isDef = module.aB;
      hasChanged = module.aC;
      ElButton = module.E;
    }, module => {
      PushStatus = module.P;
      LoginStore = module.L;
      pushResultCount = module.p;
      UserStore = module.U;
      logger$1 = module.l;
      silentlyLogin = module.s;
      isProdEnv = module.i;
      Tools = module.T;
      LogRecorder = module.a;
      loginInterceptor = module.b;
      ElMessage = module.E;
      axios = module.c;
      fetchWithGM_request = module.f;
    }, module => {
      EventSourcePolyfill = module.default;
    }, module => {
      ElNotification = module.ElNotification;
    }, null, null],
    execute: (function () {

      var __defProp = Object.defineProperty;
      var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __publicField = (obj, key, value) => {
        __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
        return value;
      };
      const triggerEvent = function(elm, name, ...opts) {
        let eventName;
        if (name.includes("mouse") || name.includes("click")) {
          eventName = "MouseEvents";
        } else if (name.includes("key")) {
          eventName = "KeyboardEvent";
        } else {
          eventName = "HTMLEvents";
        }
        const evt = document.createEvent(eventName);
        evt.initEvent(name, ...opts);
        elm.dispatchEvent(evt);
        return elm;
      };
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      function unrefElement(elRef) {
        var _a;
        const plain = resolveUnref(elRef);
        return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      function useEventListener(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (isString$1(args[0]) || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop$1;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register2 = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          cleanups.push(...events.flatMap((event) => {
            return listeners.map((listener) => register2(el, event, listener, options2));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$1));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener(window2, "click", listener, { passive: true, capture }),
          useEventListener(window2, "pointerdown", (e) => {
            const el = unrefElement(target);
            if (el)
              shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
          }, { passive: true }),
          detectIframe && useEventListener(window2, "blur", (event) => {
            var _a;
            const el = unrefElement(target);
            if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useSupported(callback, sync = false) {
        const isSupported = ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted(update, sync);
        return isSupported;
      }
      function cloneFnJSON(source) {
        return JSON.parse(JSON.stringify(source));
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      _global[globalKey] = _global[globalKey] || {};
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver(target, callback, options = {}) {
        const _a = options, { window: window2 = defaultWindow } = _a, observerOptions = __objRest$2(_a, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
      var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
      var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
      var __objRest$1 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$8)
          for (var prop of __getOwnPropSymbols$8(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useMutationObserver(target, callback, options = {}) {
        const _a = options, { window: window2 = defaultWindow } = _a, mutationOptions = __objRest$1(_a, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new MutationObserver(callback);
            observer.observe(el, mutationOptions);
          }
        }, { immediate: true });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp2 = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b2)) {
            if (__propIsEnum.call(b2, prop))
              __defNormalProp2(a2, prop, b2[prop]);
          }
        return a2;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity$1
      }, _TransitionPresets);
      function useVModel(props, key, emit, options = {}) {
        var _a, _b, _c;
        const {
          clone: clone2 = false,
          passive = false,
          eventName,
          deep = false,
          defaultValue
        } = options;
        const vm = getCurrentInstance();
        const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
        let event = eventName;
        if (!key) {
          {
            key = "modelValue";
          }
        }
        event = eventName || event || `update:${key.toString()}`;
        const cloneFn = (val) => !clone2 ? val : isFunction$1$1(clone2) ? clone2(val) : cloneFnJSON(val);
        const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
        if (passive) {
          const initialValue = getValue2();
          const proxy = ref(initialValue);
          watch(() => props[key], (v2) => proxy.value = cloneFn(v2));
          watch(proxy, (v2) => {
            if (v2 !== props[key] || deep)
              _emit(event, v2);
          }, { deep });
          return proxy;
        } else {
          return computed$1({
            get() {
              return getValue2();
            },
            set(value) {
              _emit(event, value);
            }
          });
        }
      }
      const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
      const isInContainer = (el, container) => {
        if (!isClient || !el || !container)
          return false;
        const elRect = el.getBoundingClientRect();
        let containerRect;
        if (container instanceof Element) {
          containerRect = container.getBoundingClientRect();
        } else {
          containerRect = {
            top: 0,
            right: window.innerWidth,
            bottom: window.innerHeight,
            left: 0
          };
        }
        return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
      };
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = root.Symbol;
      var objectProto$f = Object.prototype;
      var hasOwnProperty$c = objectProto$f.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$f.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$e = Object.prototype;
      var nativeObjectToString = objectProto$e.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$3 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
      }
      function arrayMap(array4, iteratee) {
        var index = -1, length = array4 == null ? 0 : array4.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array4[index], index, array4);
        }
        return result;
      }
      var isArray = Array.isArray;
      var INFINITY$3 = 1 / 0;
      var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string3) {
        var index = string3.length;
        while (index-- && reWhitespace.test(string3.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string3) {
        return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
      }
      function isObject(value) {
        var type4 = typeof value;
        return value != null && (type4 == "object" || type4 == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      var INFINITY$2 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY$2 || value === -INFINITY$2) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$2 = Function.prototype;
      var funcToString$2 = funcProto$2.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
      var funcToString$1 = funcProto$1.toString;
      var hasOwnProperty$b = objectProto$d.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern4 = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern4.test(toSource(value));
      }
      function getValue$1(object4, key) {
        return object4 == null ? void 0 : object4[key];
      }
      function getNative(object4, key) {
        var value = getValue$1(object4, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap = getNative(root, "WeakMap");
      var objectCreate = Object.create;
      var baseCreate = /* @__PURE__ */ function() {
        function object4() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object4.prototype = proto;
          var result = new object4();
          object4.prototype = void 0;
          return result;
        };
      }();
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function noop() {
      }
      function copyArray(source, array4) {
        var index = -1, length = source.length;
        array4 || (array4 = Array(length));
        while (++index < length) {
          array4[index] = source[index];
        }
        return array4;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var baseSetToString = !defineProperty ? identity : function(func, string3) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string3),
          "writable": true
        });
      };
      const baseSetToString$1 = baseSetToString;
      var setToString = shortOut(baseSetToString$1);
      function arrayEach(array4, iteratee) {
        var index = -1, length = array4 == null ? 0 : array4.length;
        while (++index < length) {
          if (iteratee(array4[index], index, array4) === false) {
            break;
          }
        }
        return array4;
      }
      function baseFindIndex(array4, predicate, fromIndex, fromRight) {
        var length = array4.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array4[index], index, array4)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function strictIndexOf(array4, value, fromIndex) {
        var index = fromIndex - 1, length = array4.length;
        while (++index < length) {
          if (array4[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array4, value, fromIndex) {
        return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
      }
      function arrayIncludes(array4, value) {
        var length = array4 == null ? 0 : array4.length;
        return !!length && baseIndexOf(array4, value, 0) > -1;
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type4 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object4, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object4, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object4[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$c = Object.prototype;
      var hasOwnProperty$a = objectProto$c.hasOwnProperty;
      function assignValue(object4, key, value) {
        var objValue = object4[key];
        if (!(hasOwnProperty$a.call(object4, key) && eq(objValue, value)) || value === void 0 && !(key in object4)) {
          baseAssignValue(object4, key, value);
        }
      }
      function copyObject(source, props, object4, customizer) {
        var isNew = !object4;
        object4 || (object4 = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object4[key], source[key], key, object4, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object4, key, newValue);
          } else {
            assignValue(object4, key, newValue);
          }
        }
        return object4;
      }
      var nativeMax$2 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$2(args.length - start, 0), array4 = Array(length);
          while (++index < length) {
            array4[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array4);
          return apply(func, this, otherArgs);
        };
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isIterateeCall(value, index, object4) {
        if (!isObject(object4)) {
          return false;
        }
        var type4 = typeof index;
        if (type4 == "number" ? isArrayLike(object4) && isIndex(index, object4.length) : type4 == "string" && index in object4) {
          return eq(object4[index], value);
        }
        return false;
      }
      function createAssigner(assigner) {
        return baseRest(function(object4, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object4 = Object(object4);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object4, source, index, customizer);
            }
          }
          return object4;
        });
      }
      var objectProto$b = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$b;
        return value === proto;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$3 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$3;
      }
      var objectProto$a = Object.prototype;
      var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
      var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
      typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      function baseKeys(object4) {
        if (!isPrototype(object4)) {
          return nativeKeys(object4);
        }
        var result = [];
        for (var key in Object(object4)) {
          if (hasOwnProperty$7.call(object4, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object4) {
        return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
      }
      function nativeKeysIn(object4) {
        var result = [];
        if (object4 != null) {
          for (var key in Object(object4)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function baseKeysIn(object4) {
        if (!isObject(object4)) {
          return nativeKeysIn(object4);
        }
        var isProto = isPrototype(object4), result = [];
        for (var key in object4) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object4, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object4) {
        return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object4) {
        if (isArray(value)) {
          return false;
        }
        var type4 = typeof value;
        if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object(object4);
      }
      var nativeCreate = getNative(Object, "create");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
      }
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$4.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array4, key) {
        var length = array4.length;
        while (length--) {
          if (eq(array4[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root, "Map");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$1 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type4 = typeof value;
        return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$2 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string3) {
        var result = [];
        if (string3.charCodeAt(0) === 46) {
          result.push("");
        }
        string3.replace(rePropName, function(match, number4, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match);
        });
        return result;
      });
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object4) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object4) ? [value] : stringToPath(toString(value));
      }
      var INFINITY$1 = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
      }
      function baseGet(object4, path) {
        path = castPath(path, object4);
        var index = 0, length = path.length;
        while (object4 != null && index < length) {
          object4 = object4[toKey(path[index++])];
        }
        return index && index == length ? object4 : void 0;
      }
      function get(object4, path, defaultValue) {
        var result = object4 == null ? void 0 : baseGet(object4, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array4, values) {
        var index = -1, length = values.length, offset = array4.length;
        while (++index < length) {
          array4[offset + index] = values[index];
        }
        return array4;
      }
      var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array4, depth, predicate, isStrict, result) {
        var index = -1, length = array4.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array4[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      function flatten(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseFlatten(array4, 1) : [];
      }
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten), func + "");
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      const getPrototype$1 = getPrototype;
      var objectTag$3 = "[object Object]";
      var funcProto = Function.prototype, objectProto$4 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
          return false;
        }
        var proto = getPrototype$1(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE$1 = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function baseAssign(object4, source) {
        return object4 && copyObject(source, keys(source), object4);
      }
      function baseAssignIn(object4, source) {
        return object4 && copyObject(source, keysIn(source), object4);
      }
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function arrayFilter(array4, predicate) {
        var index = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array4[index];
          if (predicate(value, index, array4)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$3 = Object.prototype;
      var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
      var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object4) {
        if (object4 == null) {
          return [];
        }
        object4 = Object(object4);
        return arrayFilter(nativeGetSymbols$1(object4), function(symbol) {
          return propertyIsEnumerable.call(object4, symbol);
        });
      };
      function copySymbols(source, object4) {
        return copyObject(source, getSymbols(source), object4);
      }
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object4) {
        var result = [];
        while (object4) {
          arrayPush(result, getSymbols(object4));
          object4 = getPrototype$1(object4);
        }
        return result;
      };
      function copySymbolsIn(source, object4) {
        return copyObject(source, getSymbolsIn(source), object4);
      }
      function baseGetAllKeys(object4, keysFunc, symbolsFunc) {
        var result = keysFunc(object4);
        return isArray(object4) ? result : arrayPush(result, symbolsFunc(object4));
      }
      function getAllKeys(object4) {
        return baseGetAllKeys(object4, keys, getSymbols);
      }
      function getAllKeysIn(object4) {
        return baseGetAllKeys(object4, keysIn, getSymbolsIn);
      }
      var DataView = getNative(root, "DataView");
      var Promise$1 = getNative(root, "Promise");
      var Set$1 = getNative(root, "Set");
      var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
      var dataViewTag$3 = "[object DataView]";
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap);
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$3;
              case mapCtorString:
                return mapTag$4;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$4;
              case weakMapCtorString:
                return weakMapTag$1;
            }
          }
          return result;
        };
      }
      const getTag$1 = getTag;
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
      function initCloneArray(array4) {
        var length = array4.length, result = new array4.constructor(length);
        if (length && typeof array4[0] == "string" && hasOwnProperty$2.call(array4, "index")) {
          result.index = array4.index;
          result.input = array4.input;
        }
        return result;
      }
      var Uint8Array$1 = root.Uint8Array;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var reFlags = /\w*$/;
      function cloneRegExp(regexp4) {
        var result = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
        result.lastIndex = regexp4.lastIndex;
        return result;
      }
      var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
      var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag(object4, tag, isDeep) {
        var Ctor = object4.constructor;
        switch (tag) {
          case arrayBufferTag$2:
            return cloneArrayBuffer(object4);
          case boolTag$2:
          case dateTag$2:
            return new Ctor(+object4);
          case dataViewTag$2:
            return cloneDataView(object4, isDeep);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray(object4, isDeep);
          case mapTag$3:
            return new Ctor();
          case numberTag$2:
          case stringTag$2:
            return new Ctor(object4);
          case regexpTag$2:
            return cloneRegExp(object4);
          case setTag$3:
            return new Ctor();
          case symbolTag$2:
            return cloneSymbol(object4);
        }
      }
      function initCloneObject(object4) {
        return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate(getPrototype$1(object4)) : {};
      }
      var mapTag$2 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag$1(value) == mapTag$2;
      }
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      var setTag$2 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag$1(value) == setTag$2;
      }
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$2 = 4;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object4, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
        if (customizer) {
          result = object4 ? customizer(value, key, object4, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object4) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object4 ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      var CLONE_SYMBOLS_FLAG$1 = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG$1);
      }
      var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array4, predicate) {
        var index = -1, length = array4 == null ? 0 : array4.length;
        while (++index < length) {
          if (predicate(array4[index], index, array4)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array4, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array4.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array4);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array4;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack.set(array4, other);
        stack.set(other, array4);
        while (++index < arrLength) {
          var arrValue = array4[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array4, stack) : customizer(arrValue, othValue, index, array4, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array4);
        stack["delete"](other);
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object4, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
              return false;
            }
            object4 = object4.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object4), new Uint8Array$1(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object4, +other);
          case errorTag:
            return object4.name == other.name && object4.message == other.message;
          case regexpTag:
          case stringTag:
            return object4 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object4.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object4);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack.set(object4, other);
            var result = equalArrays(convert(object4), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object4);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object4) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function equalObjects(object4, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object4);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object4;
        }
        var result = true;
        stack.set(object4, other);
        stack.set(other, object4);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object4[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object4, stack) : customizer(objValue, othValue, key, object4, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object4.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object4);
        stack["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object4, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object4), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object4), othTag = othIsArr ? arrayTag : getTag$1(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object4)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object4, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object4, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object4 == null) {
          return !length;
        }
        object4 = Object(object4);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object4[data[0]] : !(data[0] in object4)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object4[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object4)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object4, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function getMatchData(object4) {
        var result = keys(object4), length = result.length;
        while (length--) {
          var key = result[length], value = object4[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object4) {
          if (object4 == null) {
            return false;
          }
          return object4[key] === srcValue && (srcValue !== void 0 || key in Object(object4));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object4) {
          return object4 === source || baseIsMatch(object4, source, matchData);
        };
      }
      function baseHasIn(object4, key) {
        return object4 != null && key in Object(object4);
      }
      function hasPath(object4, path, hasFunc) {
        path = castPath(path, object4);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object4 != null && hasFunc(object4, key))) {
            break;
          }
          object4 = object4[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object4 == null ? 0 : object4.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object4) || isArguments(object4));
      }
      function hasIn(object4, path) {
        return object4 != null && hasPath(object4, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object4) {
          var objValue = get(object4, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object4, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object4) {
          return object4 == null ? void 0 : object4[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object4) {
          return baseGet(object4, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function createBaseFor(fromRight) {
        return function(object4, iteratee, keysFunc) {
          var index = -1, iterable = Object(object4), props = keysFunc(object4), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object4;
        };
      }
      var baseFor = createBaseFor();
      function baseForOwn(object4, iteratee) {
        return object4 && baseFor(object4, iteratee, keys);
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      var baseEach = createBaseEach(baseForOwn);
      var now = function() {
        return root.Date.now();
      };
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function assignMergeValue(object4, key, value) {
        if (value !== void 0 && !eq(object4[key], value) || value === void 0 && !(key in object4)) {
          baseAssignValue(object4, key, value);
        }
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function safeGet(object4, key) {
        if (key === "constructor" && typeof object4[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object4[key];
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function baseMergeDeep(object4, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object4, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object4, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object4, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object4, key, newValue);
      }
      function baseMerge(object4, source, srcIndex, customizer, stack) {
        if (object4 === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object4, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object4, key), srcValue, key + "", object4, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object4, key, newValue);
          }
        }, keysIn);
      }
      function arrayIncludesWith(array4, value, comparator) {
        var index = -1, length = array4 == null ? 0 : array4.length;
        while (++index < length) {
          if (comparator(value, array4[index])) {
            return true;
          }
        }
        return false;
      }
      var nativeMax = Math.max, nativeMin = Math.min;
      function findLastIndex(array4, predicate, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== void 0) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array4, baseIteratee(predicate), index, true);
      }
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee));
      }
      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), 1);
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isUndefined(value) {
        return value === void 0;
      }
      var merge = createAssigner(function(object4, source, srcIndex) {
        baseMerge(object4, source, srcIndex);
      });
      const merge$1 = merge;
      function baseSet(object4, path, value, customizer) {
        if (!isObject(object4)) {
          return object4;
        }
        path = castPath(path, object4);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object4;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object4;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object4;
      }
      function basePickBy(object4, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object4, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object4), value);
          }
        }
        return result;
      }
      function basePick(object4, paths) {
        return basePickBy(object4, paths, function(value, path) {
          return hasIn(object4, path);
        });
      }
      var pick = flatRest(function(object4, paths) {
        return object4 == null ? {} : basePick(object4, paths);
      });
      function set(object4, path, value) {
        return object4 == null ? object4 : baseSet(object4, path, value);
      }
      var FUNC_ERROR_TEXT = "Expected a function";
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      var INFINITY = 1 / 0;
      var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop : function(values) {
        return new Set$1(values);
      };
      var LARGE_ARRAY_SIZE = 200;
      function baseUniq(array4, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, length = array4.length, isCommon = true, result = [], seen = result;
        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee ? null : createSet(array4);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }
        outer:
          while (++index < length) {
            var value = array4[index], computed2 = iteratee ? iteratee(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed2);
              }
              result.push(value);
            } else if (!includes(seen, computed2, comparator)) {
              if (seen !== result) {
                seen.push(computed2);
              }
              result.push(value);
            }
          }
        return result;
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      const rAF = (fn2) => isClient ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
      const escapeStringRegexp = (string3 = "") => string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      const keysOf = (arr) => Object.keys(arr);
      const entriesOf = (arr) => Object.entries(arr);
      const getProp = (obj, path, defaultValue) => {
        return {
          get value() {
            return get(obj, path, defaultValue);
          },
          set value(val) {
            set(obj, path, val);
          }
        };
      };
      class ElementPlusError extends Error {
        constructor(m2) {
          super(m2);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m2) {
        throw new ElementPlusError(`[${scope}] ${m2}`);
      }
      function debugWarn(scope, message) {
      }
      const isScroll = (el, isVertical) => {
        if (!isClient)
          return false;
        const key = {
          undefined: "overflow",
          true: "overflow-y",
          false: "overflow-x"
        }[String(isVertical)];
        const overflow = getStyle(el, key);
        return ["scroll", "auto", "overlay"].some((s2) => overflow.includes(s2));
      };
      const getScrollContainer = (el, isVertical) => {
        if (!isClient)
          return;
        let parent = el;
        while (parent) {
          if ([window, document, document.documentElement].includes(parent))
            return window;
          if (isScroll(parent, isVertical))
            return parent;
          parent = parent.parentNode;
        }
        return parent;
      };
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a;
        if (!isClient)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a = outer.parentNode) == null ? void 0 : _a.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      function scrollIntoView(container, selected) {
        if (!isClient)
          return;
        if (!selected) {
          container.scrollTop = 0;
          return;
        }
        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer !== null && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;
        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$1(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const EVENT_CODE = {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        delete: "Delete",
        backspace: "Backspace",
        numpadEnter: "NumpadEnter",
        pageUp: "PageUp",
        pageDown: "PageDown",
        home: "Home",
        end: "End"
      };
      const UPDATE_MODEL_EVENT = "update:modelValue";
      const CHANGE_EVENT = "change";
      const INPUT_EVENT = "input";
      const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      const flattedChildren = (children) => {
        const vNodes = isArray$1(children) ? children : [children];
        const result = [];
        vNodes.forEach((child) => {
          var _a;
          if (isArray$1(child)) {
            result.push(...flattedChildren(child));
          } else if (isVNode(child) && isArray$1(child.children)) {
            result.push(...flattedChildren(child.children));
          } else {
            result.push(child);
            if (isVNode(child) && ((_a = child.component) == null ? void 0 : _a.subTree)) {
              result.push(...flattedChildren(child.component.subTree));
            }
          }
        });
        return result;
      };
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      const mutable = (val) => val;
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = computed$1(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = getCurrentInstance();
        if (!instance) {
          return computed$1(() => ({}));
        }
        return computed$1(() => {
          var _a;
          return fromPairs(Object.entries((_a = instance.proxy) == null ? void 0 : _a.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      const useDraggable = (targetRef, dragRef, draggable, overflow) => {
        let transform = {
          offsetX: 0,
          offsetY: 0
        };
        const onMousedown = (e) => {
          const downX = e.clientX;
          const downY = e.clientY;
          const { offsetX, offsetY } = transform;
          const targetRect = targetRef.value.getBoundingClientRect();
          const targetLeft = targetRect.left;
          const targetTop = targetRect.top;
          const targetWidth = targetRect.width;
          const targetHeight = targetRect.height;
          const clientWidth = document.documentElement.clientWidth;
          const clientHeight = document.documentElement.clientHeight;
          const minLeft = -targetLeft + offsetX;
          const minTop = -targetTop + offsetY;
          const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
          const maxTop = clientHeight - targetTop - targetHeight + offsetY;
          const onMousemove = (e2) => {
            let moveX = offsetX + e2.clientX - downX;
            let moveY = offsetY + e2.clientY - downY;
            if (!(overflow == null ? void 0 : overflow.value)) {
              moveX = Math.min(Math.max(moveX, minLeft), maxLeft);
              moveY = Math.min(Math.max(moveY, minTop), maxTop);
            }
            transform = {
              offsetX: moveX,
              offsetY: moveY
            };
            if (targetRef.value) {
              targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
            }
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
          }
        };
        onMounted(() => {
          watchEffect(() => {
            if (draggable.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        onBeforeUnmount(() => {
          offDraggable();
        });
      };
      var English = {
        name: "en",
        el: {
          breadcrumb: {
            label: "Breadcrumb"
          },
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color."
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tour: {
            next: "Next",
            previous: "Previous",
            finish: "Finish"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          },
          carousel: {
            leftArrow: "Carousel arrow left",
            rightArrow: "Carousel arrow right",
            indicator: "Carousel switch to index {index}"
          }
        }
      };
      const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
      const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a;
        return `${(_a = option == null ? void 0 : option[key]) != null ? _a : `{${key}}`}`;
      });
      const buildLocaleContext = (locale) => {
        const lang = computed$1(() => unref(locale).name);
        const localeRef = isRef(locale) ? locale : ref(locale);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = (localeOverrides) => {
        const locale = localeOverrides || inject(localeContextKey, ref());
        return buildLocaleContext(computed$1(() => locale.value || English));
      };
      /**
      * @vue/reactivity v3.4.21
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      let activeEffectScope;
      function recordEffectScope(effect2, scope = activeEffectScope) {
        if (scope && scope.active) {
          scope.effects.push(effect2);
        }
      }
      let activeEffect;
      class ReactiveEffect {
        constructor(fn2, trigger2, scheduler, scope) {
          this.fn = fn2;
          this.trigger = trigger2;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          this._dirtyLevel = 4;
          this._trackId = 0;
          this._runnings = 0;
          this._shouldSchedule = false;
          this._depsLength = 0;
          recordEffectScope(this, scope);
        }
        get dirty() {
          if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1;
            pauseTracking();
            for (let i = 0; i < this._depsLength; i++) {
              const dep = this.deps[i];
              if (dep.computed) {
                triggerComputed(dep.computed);
                if (this._dirtyLevel >= 4) {
                  break;
                }
              }
            }
            if (this._dirtyLevel === 1) {
              this._dirtyLevel = 0;
            }
            resetTracking();
          }
          return this._dirtyLevel >= 4;
        }
        set dirty(v2) {
          this._dirtyLevel = v2 ? 4 : 0;
        }
        run() {
          this._dirtyLevel = 0;
          if (!this.active) {
            return this.fn();
          }
          let lastShouldTrack = shouldTrack;
          let lastEffect = activeEffect;
          try {
            shouldTrack = true;
            activeEffect = this;
            this._runnings++;
            preCleanupEffect(this);
            return this.fn();
          } finally {
            postCleanupEffect(this);
            this._runnings--;
            activeEffect = lastEffect;
            shouldTrack = lastShouldTrack;
          }
        }
        stop() {
          var _a;
          if (this.active) {
            preCleanupEffect(this);
            postCleanupEffect(this);
            (_a = this.onStop) == null ? void 0 : _a.call(this);
            this.active = false;
          }
        }
      }
      function triggerComputed(computed2) {
        return computed2.value;
      }
      function preCleanupEffect(effect2) {
        effect2._trackId++;
        effect2._depsLength = 0;
      }
      function postCleanupEffect(effect2) {
        if (effect2.deps.length > effect2._depsLength) {
          for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
            cleanupDepEffect(effect2.deps[i], effect2);
          }
          effect2.deps.length = effect2._depsLength;
        }
      }
      function cleanupDepEffect(dep, effect2) {
        const trackId = dep.get(effect2);
        if (trackId !== void 0 && effect2._trackId !== trackId) {
          dep.delete(effect2);
          if (dep.size === 0) {
            dep.cleanup();
          }
        }
      }
      let shouldTrack = true;
      let pauseScheduleStack = 0;
      const trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function pauseScheduling() {
        pauseScheduleStack++;
      }
      function resetScheduling() {
        pauseScheduleStack--;
        while (!pauseScheduleStack && queueEffectSchedulers.length) {
          queueEffectSchedulers.shift()();
        }
      }
      function trackEffect(effect2, dep, debuggerEventExtraInfo) {
        if (dep.get(effect2) !== effect2._trackId) {
          dep.set(effect2, effect2._trackId);
          const oldDep = effect2.deps[effect2._depsLength];
          if (oldDep !== dep) {
            if (oldDep) {
              cleanupDepEffect(oldDep, effect2);
            }
            effect2.deps[effect2._depsLength++] = dep;
          } else {
            effect2._depsLength++;
          }
        }
      }
      const queueEffectSchedulers = [];
      function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
        pauseScheduling();
        for (const effect2 of dep.keys()) {
          let tracking;
          if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
            effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
            effect2._dirtyLevel = dirtyLevel;
          }
          if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
            effect2.trigger();
            if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
              effect2._shouldSchedule = false;
              if (effect2.scheduler) {
                queueEffectSchedulers.push(effect2.scheduler);
              }
            }
          }
        }
        resetScheduling();
      }
      const createDep = (cleanup, computed2) => {
        const dep = /* @__PURE__ */ new Map();
        dep.cleanup = cleanup;
        dep.computed = computed2;
        return dep;
      };
      new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
      );
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      class ComputedRefImpl {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this.getter = getter;
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this["__v_isReadonly"] = false;
          this.effect = new ReactiveEffect(
            () => getter(this._value),
            () => triggerRefValue(
              this,
              this.effect._dirtyLevel === 2 ? 2 : 3
            )
          );
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
            triggerRefValue(self2, 4);
          }
          trackRefValue(self2);
          if (self2.effect._dirtyLevel >= 2) {
            triggerRefValue(self2, 2);
          }
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
        // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
        get _dirty() {
          return this.effect.dirty;
        }
        set _dirty(v2) {
          this.effect.dirty = v2;
        }
        // #endregion
      }
      function computed(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        const onlyGetter = isFunction$1(getterOrOptions);
        if (onlyGetter) {
          getter = getterOrOptions;
          setter = NOOP;
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        return cRef;
      }
      function trackRefValue(ref2) {
        var _a;
        if (shouldTrack && activeEffect) {
          ref2 = toRaw(ref2);
          trackEffect(
            activeEffect,
            (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
              () => ref2.dep = void 0,
              ref2 instanceof ComputedRefImpl ? ref2 : void 0
            )
          );
        }
      }
      function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
        ref2 = toRaw(ref2);
        const dep = ref2.dep;
        if (dep) {
          triggerEffects(
            dep,
            dirtyLevel
          );
        }
      }
      const useLockscreen = (trigger, options = {}) => {
        if (!isRef(trigger)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options.ns || useNamespace("popup");
        const hiddenCls = computed(() => ns.bm("parent", "hidden"));
        if (!isClient || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup = () => {
          setTimeout(() => {
            removeClass(document == null ? void 0 : document.body, hiddenCls.value);
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
            }
          }, 200);
        };
        watch(trigger, (val) => {
          if (!val) {
            cleanup();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
          addClass(document.body, hiddenCls.value);
        });
        onScopeDispose(() => cleanup());
      };
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = getCurrentInstance();
          const { emit } = instance;
          const props = instance.props;
          const hasUpdateHandler = computed$1(() => isFunction$1(props[updateEventKeyRaw]));
          const isModelBindingAbsent = computed$1(() => props[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props.disabled === true || !isClient)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean(val))
              return;
            if (props.disabled && val) {
              if (hasUpdateHandler.value) {
                emit(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          watch(() => props[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          onMounted(() => {
            onChange(props[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      var E$1 = "top", R = "bottom", W = "right", P$1 = "left", me = "auto", G = [E$1, R, W, P$1], U$1 = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
        return t.concat([e + "-" + U$1, e + "-" + J]);
      }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
        return t.concat([e, e + "-" + U$1, e + "-" + J]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
      function C(t) {
        return t ? (t.nodeName || "").toLowerCase() : null;
      }
      function H(t) {
        if (t == null)
          return window;
        if (t.toString() !== "[object Window]") {
          var e = t.ownerDocument;
          return e && e.defaultView || window;
        }
        return t;
      }
      function Q(t) {
        var e = H(t).Element;
        return t instanceof e || t instanceof Element;
      }
      function B(t) {
        var e = H(t).HTMLElement;
        return t instanceof e || t instanceof HTMLElement;
      }
      function Pe(t) {
        if (typeof ShadowRoot == "undefined")
          return false;
        var e = H(t).ShadowRoot;
        return t instanceof e || t instanceof ShadowRoot;
      }
      function Mt(t) {
        var e = t.state;
        Object.keys(e.elements).forEach(function(n) {
          var r = e.styles[n] || {}, o2 = e.attributes[n] || {}, i = e.elements[n];
          !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o2).forEach(function(a2) {
            var s2 = o2[a2];
            s2 === false ? i.removeAttribute(a2) : i.setAttribute(a2, s2 === true ? "" : s2);
          }));
        });
      }
      function Rt(t) {
        var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
          Object.keys(e.elements).forEach(function(r) {
            var o2 = e.elements[r], i = e.attributes[r] || {}, a2 = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s2 = a2.reduce(function(f2, c2) {
              return f2[c2] = "", f2;
            }, {});
            !B(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i).forEach(function(f2) {
              o2.removeAttribute(f2);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
      function q(t) {
        return t.split("-")[0];
      }
      var X$1 = Math.max, ve = Math.min, Z = Math.round;
      function ee(t, e) {
        e === void 0 && (e = false);
        var n = t.getBoundingClientRect(), r = 1, o2 = 1;
        if (B(t) && e) {
          var i = t.offsetHeight, a2 = t.offsetWidth;
          a2 > 0 && (r = Z(n.width) / a2 || 1), i > 0 && (o2 = Z(n.height) / i || 1);
        }
        return { width: n.width / r, height: n.height / o2, top: n.top / o2, right: n.right / r, bottom: n.bottom / o2, left: n.left / r, x: n.left / r, y: n.top / o2 };
      }
      function ke(t) {
        var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
        return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
      }
      function it(t, e) {
        var n = e.getRootNode && e.getRootNode();
        if (t.contains(e))
          return true;
        if (n && Pe(n)) {
          var r = e;
          do {
            if (r && t.isSameNode(r))
              return true;
            r = r.parentNode || r.host;
          } while (r);
        }
        return false;
      }
      function N$1(t) {
        return H(t).getComputedStyle(t);
      }
      function Wt(t) {
        return ["table", "td", "th"].indexOf(C(t)) >= 0;
      }
      function I$1(t) {
        return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
      }
      function ge(t) {
        return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I$1(t);
      }
      function at(t) {
        return !B(t) || N$1(t).position === "fixed" ? null : t.offsetParent;
      }
      function Bt(t) {
        var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
        if (n && B(t)) {
          var r = N$1(t);
          if (r.position === "fixed")
            return null;
        }
        var o2 = ge(t);
        for (Pe(o2) && (o2 = o2.host); B(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
          var i = N$1(o2);
          if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
            return o2;
          o2 = o2.parentNode;
        }
        return null;
      }
      function se(t) {
        for (var e = H(t), n = at(t); n && Wt(n) && N$1(n).position === "static"; )
          n = at(n);
        return n && (C(n) === "html" || C(n) === "body" && N$1(n).position === "static") ? e : n || Bt(t) || e;
      }
      function Le(t) {
        return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
      }
      function fe(t, e, n) {
        return X$1(t, ve(e, n));
      }
      function St(t, e, n) {
        var r = fe(t, e, n);
        return r > n ? n : r;
      }
      function st() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft(t) {
        return Object.assign({}, st(), t);
      }
      function ct(t, e) {
        return e.reduce(function(n, r) {
          return n[r] = t, n;
        }, {});
      }
      var Tt = function(t, e) {
        return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
      };
      function Ht(t) {
        var e, n = t.state, r = t.name, o2 = t.options, i = n.elements.arrow, a2 = n.modifiersData.popperOffsets, s2 = q(n.placement), f2 = Le(s2), c2 = [P$1, W].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
        if (!(!i || !a2)) {
          var m2 = Tt(o2.padding, n), v2 = ke(i), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R : W, p2 = n.rects.reference[u2] + n.rects.reference[f2] - a2[f2] - n.rects.popper[u2], g = a2[f2] - n.rects.reference[f2], x2 = se(i), y = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d2 = m2[l2], b2 = y - v2[u2] - m2[h2], w2 = y / 2 - v2[u2] / 2 + $, O2 = fe(d2, w2, b2), j = f2;
          n.modifiersData[r] = (e = {}, e[j] = O2, e.centerOffset = O2 - w2, e);
        }
      }
      function Ct(t) {
        var e = t.state, n = t.options, r = n.element, o2 = r === void 0 ? "[data-popper-arrow]" : r;
        o2 != null && (typeof o2 == "string" && (o2 = e.elements.popper.querySelector(o2), !o2) || !it(e.elements.popper, o2) || (e.elements.arrow = o2));
      }
      var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t) {
        return t.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t) {
        var e = t.x, n = t.y, r = window, o2 = r.devicePixelRatio || 1;
        return { x: Z(e * o2) / o2 || 0, y: Z(n * o2) / o2 || 0 };
      }
      function ut(t) {
        var e, n = t.popper, r = t.popperRect, o2 = t.placement, i = t.variation, a2 = t.offsets, s2 = t.position, f2 = t.gpuAcceleration, c2 = t.adaptive, u2 = t.roundOffsets, m2 = t.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
        l2 = g.x, p2 = g.y;
        var x2 = a2.hasOwnProperty("x"), y = a2.hasOwnProperty("y"), $ = P$1, d2 = E$1, b2 = window;
        if (c2) {
          var w2 = se(n), O2 = "clientHeight", j = "clientWidth";
          if (w2 === H(n) && (w2 = I$1(n), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W) && i === J) {
            d2 = R;
            var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
            p2 -= A2 - r.height, p2 *= f2 ? 1 : -1;
          }
          if (o2 === P$1 || (o2 === E$1 || o2 === R) && i === J) {
            $ = W;
            var k = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j];
            l2 -= k - r.width, l2 *= f2 ? 1 : -1;
          }
        }
        var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
        if (l2 = S2.x, p2 = S2.y, f2) {
          var L;
          return Object.assign({}, D2, (L = {}, L[d2] = y ? "0" : "", L[$] = x2 ? "0" : "", L.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L));
        }
        return Object.assign({}, D2, (e = {}, e[d2] = y ? p2 + "px" : "", e[$] = x2 ? l2 + "px" : "", e.transform = "", e));
      }
      function Nt(t) {
        var e = t.state, n = t.options, r = n.gpuAcceleration, o2 = r === void 0 ? true : r, i = n.adaptive, a2 = i === void 0 ? true : i, s2 = n.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o2, isFixed: e.options.strategy === "fixed" };
        e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c2, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a2, roundOffsets: f2 })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c2, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
      function It(t) {
        var e = t.state, n = t.instance, r = t.options, o2 = r.scroll, i = o2 === void 0 ? true : o2, a2 = r.resize, s2 = a2 === void 0 ? true : a2, f2 = H(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
        return i && c2.forEach(function(u2) {
          u2.addEventListener("scroll", n.update, ye);
        }), s2 && f2.addEventListener("resize", n.update, ye), function() {
          i && c2.forEach(function(u2) {
            u2.removeEventListener("scroll", n.update, ye);
          }), s2 && f2.removeEventListener("resize", n.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t) {
        return t.replace(/left|right|bottom|top/g, function(e) {
          return _t[e];
        });
      }
      var zt = { start: "end", end: "start" };
      function lt(t) {
        return t.replace(/start|end/g, function(e) {
          return zt[e];
        });
      }
      function We(t) {
        var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
        return { scrollLeft: n, scrollTop: r };
      }
      function Be(t) {
        return ee(I$1(t)).left + We(t).scrollLeft;
      }
      function Ft(t) {
        var e = H(t), n = I$1(t), r = e.visualViewport, o2 = n.clientWidth, i = n.clientHeight, a2 = 0, s2 = 0;
        return r && (o2 = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r.offsetLeft, s2 = r.offsetTop)), { width: o2, height: i, x: a2 + Be(t), y: s2 };
      }
      function Ut(t) {
        var e, n = I$1(t), r = We(t), o2 = (e = t.ownerDocument) == null ? void 0 : e.body, i = X$1(n.scrollWidth, n.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X$1(n.scrollHeight, n.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r.scrollLeft + Be(t), f2 = -r.scrollTop;
        return N$1(o2 || n).direction === "rtl" && (s2 += X$1(n.clientWidth, o2 ? o2.clientWidth : 0) - i), { width: i, height: a2, x: s2, y: f2 };
      }
      function Se(t) {
        var e = N$1(t), n = e.overflow, r = e.overflowX, o2 = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + o2 + r);
      }
      function dt(t) {
        return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
      }
      function ce(t, e) {
        var n;
        e === void 0 && (e = []);
        var r = dt(t), o2 = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a2 = o2 ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s2 = e.concat(a2);
        return o2 ? s2 : s2.concat(ce(ge(a2)));
      }
      function Te(t) {
        return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
      }
      function Xt(t) {
        var e = ee(t);
        return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
      }
      function ht(t, e) {
        return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I$1(t)));
      }
      function Yt(t) {
        var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N$1(t).position) >= 0, r = n && B(t) ? se(t) : t;
        return Q(r) ? e.filter(function(o2) {
          return Q(o2) && it(o2, r) && C(o2) !== "body";
        }) : [];
      }
      function Gt(t, e, n) {
        var r = e === "clippingParents" ? Yt(t) : [].concat(e), o2 = [].concat(r, [n]), i = o2[0], a2 = o2.reduce(function(s2, f2) {
          var c2 = ht(t, f2);
          return s2.top = X$1(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X$1(c2.left, s2.left), s2;
        }, ht(t, i));
        return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
      }
      function mt(t) {
        var e = t.reference, n = t.element, r = t.placement, o2 = r ? q(r) : null, i = r ? te(r) : null, a2 = e.x + e.width / 2 - n.width / 2, s2 = e.y + e.height / 2 - n.height / 2, f2;
        switch (o2) {
          case E$1:
            f2 = { x: a2, y: e.y - n.height };
            break;
          case R:
            f2 = { x: a2, y: e.y + e.height };
            break;
          case W:
            f2 = { x: e.x + e.width, y: s2 };
            break;
          case P$1:
            f2 = { x: e.x - n.width, y: s2 };
            break;
          default:
            f2 = { x: e.x, y: e.y };
        }
        var c2 = o2 ? Le(o2) : null;
        if (c2 != null) {
          var u2 = c2 === "y" ? "height" : "width";
          switch (i) {
            case U$1:
              f2[c2] = f2[c2] - (e[u2] / 2 - n[u2] / 2);
              break;
            case J:
              f2[c2] = f2[c2] + (e[u2] / 2 - n[u2] / 2);
              break;
          }
        }
        return f2;
      }
      function ne(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = r === void 0 ? t.placement : r, i = n.boundary, a2 = i === void 0 ? Xe : i, s2 = n.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n.elementContext, u2 = c2 === void 0 ? K : c2, m2 = n.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u2 === K ? Ye : K, x2 = t.rects.popper, y = t.elements[v2 ? g : u2], $ = Gt(Q(y) ? y : y.contextElement || I$1(t.elements.popper), a2, f2), d2 = ee(t.elements.reference), b2 = mt({ reference: d2, element: x2, strategy: "absolute", placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K ? w2 : d2, j = { top: $.top - O2.top + p2.top, bottom: O2.bottom - $.bottom + p2.bottom, left: $.left - O2.left + p2.left, right: O2.right - $.right + p2.right }, A2 = t.modifiersData.offset;
        if (u2 === K && A2) {
          var k = A2[o2];
          Object.keys(j).forEach(function(D2) {
            var S2 = [W, R].indexOf(D2) >= 0 ? 1 : -1, L = [E$1, R].indexOf(D2) >= 0 ? "y" : "x";
            j[D2] += k[L] * S2;
          });
        }
        return j;
      }
      function Jt(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = n.boundary, i = n.rootBoundary, a2 = n.padding, s2 = n.flipVariations, f2 = n.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r), m2 = u2 ? s2 ? De : De.filter(function(h2) {
          return te(h2) === u2;
        }) : G, v2 = m2.filter(function(h2) {
          return c2.indexOf(h2) >= 0;
        });
        v2.length === 0 && (v2 = m2);
        var l2 = v2.reduce(function(h2, p2) {
          return h2[p2] = ne(t, { placement: p2, boundary: o2, rootBoundary: i, padding: a2 })[q(p2)], h2;
        }, {});
        return Object.keys(l2).sort(function(h2, p2) {
          return l2[h2] - l2[p2];
        });
      }
      function Kt(t) {
        if (q(t) === me)
          return [];
        var e = be(t);
        return [lt(t), e, lt(e)];
      }
      function Qt(t) {
        var e = t.state, n = t.options, r = t.name;
        if (!e.modifiersData[r]._skip) {
          for (var o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n.fallbackPlacements, c2 = n.padding, u2 = n.boundary, m2 = n.rootBoundary, v2 = n.altBoundary, l2 = n.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n.allowedAutoPlacements, g = e.options.placement, x2 = q(g), y = x2 === g, $ = f2 || (y || !h2 ? [be(g)] : Kt(g)), d2 = [g].concat($).reduce(function(z, V) {
            return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
          }, []), b2 = e.rects.reference, w2 = e.rects.popper, O2 = /* @__PURE__ */ new Map(), j = true, A2 = d2[0], k = 0; k < d2.length; k++) {
            var D2 = d2[k], S2 = q(D2), L = te(D2) === U$1, re = [E$1, R].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L ? W : P$1 : L ? R : E$1;
            b2[oe] > w2[oe] && (T2 = be(T2));
            var pe = be(T2), _2 = [];
            if (i && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z) {
              return z;
            })) {
              A2 = D2, j = false;
              break;
            }
            O2.set(D2, _2);
          }
          if (j)
            for (var ue = h2 ? 3 : 1, xe = function(z) {
              var V = d2.find(function(de) {
                var ae = O2.get(de);
                if (ae)
                  return ae.slice(0, z).every(function(Y2) {
                    return Y2;
                  });
              });
              if (V)
                return A2 = V, "break";
            }, ie = ue; ie > 0; ie--) {
              var le = xe(ie);
              if (le === "break")
                break;
            }
          e.placement !== A2 && (e.modifiersData[r]._skip = true, e.placement = A2, e.reset = true);
        }
      }
      var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt(t, e, n) {
        return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
      }
      function yt(t) {
        return [E$1, W, R, P$1].some(function(e) {
          return t[e] >= 0;
        });
      }
      function Zt(t) {
        var e = t.state, n = t.name, r = e.rects.reference, o2 = e.rects.popper, i = e.modifiersData.preventOverflow, a2 = ne(e, { elementContext: "reference" }), s2 = ne(e, { altBoundary: true }), f2 = gt(a2, r), c2 = gt(s2, o2, i), u2 = yt(f2), m2 = yt(c2);
        e.modifiersData[n] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
      }
      var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t, e, n) {
        var r = q(t), o2 = [P$1, E$1].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a2 = i[0], s2 = i[1];
        return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W].indexOf(r) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
      }
      function tn(t) {
        var e = t.state, n = t.options, r = t.name, o2 = n.offset, i = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
          return u2[m2] = en(m2, e.rects, i), u2;
        }, {}), s2 = a2[e.placement], f2 = s2.x, c2 = s2.y;
        e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f2, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = a2;
      }
      var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t) {
        var e = t.state, n = t.name;
        e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t) {
        return t === "x" ? "y" : "x";
      }
      function on(t) {
        var e = t.state, n = t.options, r = t.name, o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n.boundary, c2 = n.rootBoundary, u2 = n.altBoundary, m2 = n.padding, v2 = n.tether, l2 = v2 === void 0 ? true : v2, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q(e.placement), y = te(e.placement), $ = !y, d2 = Le(x2), b2 = rn(d2), w2 = e.modifiersData.popperOffsets, O2 = e.rects.reference, j = e.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S2 = { x: 0, y: 0 };
        if (w2) {
          if (i) {
            var L, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R : W, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g[re], _2 = T2 - g[oe], ue = l2 ? -j[M2] / 2 : 0, xe = y === U$1 ? O2[M2] : j[M2], ie = y === U$1 ? -j[M2] : -O2[M2], le = e.elements.arrow, z = l2 && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y2 = fe(0, O2[M2], z[M2]), jt = $ ? O2[M2] / 2 - ue - Y2 - de - k.mainAxis : xe - Y2 - de - k.mainAxis, Dt = $ ? -O2[M2] / 2 + ue + Y2 + ae + k.mainAxis : ie + Y2 + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D2 == null ? void 0 : D2[d2]) != null ? L : 0, Pt = T2 + jt - Ce - Et, At = T2 + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T2, l2 ? X$1(_2, At) : _2);
            w2[d2] = qe, S2[d2] = qe - T2;
          }
          if (s2) {
            var Ve, kt = d2 === "x" ? E$1 : P$1, Lt = d2 === "x" ? R : W, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g[kt], Ie = F2 - g[Lt], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j[he] - _e + k.altAxis, Fe = $e ? F2 + O2[he] + j[he] - _e - k.altAxis : Ie, Ue = l2 && $e ? St(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
            w2[b2] = Ue, S2[b2] = Ue - F2;
          }
          e.modifiersData[r] = S2;
        }
      }
      var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t) {
        return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
      }
      function sn(t) {
        return t === H(t) || !B(t) ? We(t) : an(t);
      }
      function fn(t) {
        var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
        return n !== 1 || r !== 1;
      }
      function cn(t, e, n) {
        n === void 0 && (n = false);
        var r = B(e), o2 = B(e) && fn(e), i = I$1(e), a2 = ee(t, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
        return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s2 = sn(e)), B(e) ? (f2 = ee(e, true), f2.x += e.clientLeft, f2.y += e.clientTop) : i && (f2.x = Be(i))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
      }
      function pn(t) {
        var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
        t.forEach(function(i) {
          e.set(i.name, i);
        });
        function o2(i) {
          n.add(i.name);
          var a2 = [].concat(i.requires || [], i.requiresIfExists || []);
          a2.forEach(function(s2) {
            if (!n.has(s2)) {
              var f2 = e.get(s2);
              f2 && o2(f2);
            }
          }), r.push(i);
        }
        return t.forEach(function(i) {
          n.has(i.name) || o2(i);
        }), r;
      }
      function un(t) {
        var e = pn(t);
        return ot.reduce(function(n, r) {
          return n.concat(e.filter(function(o2) {
            return o2.phase === r;
          }));
        }, []);
      }
      function ln(t) {
        var e;
        return function() {
          return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
              e = void 0, n(t());
            });
          })), e;
        };
      }
      function dn(t) {
        var e = t.reduce(function(n, r) {
          var o2 = n[r.name];
          return n[r.name] = o2 ? Object.assign({}, o2, r, { options: Object.assign({}, o2.options, r.options), data: Object.assign({}, o2.data, r.data) }) : r, n;
        }, {});
        return Object.keys(e).map(function(n) {
          return e[n];
        });
      }
      var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return !e.some(function(r) {
          return !(r && typeof r.getBoundingClientRect == "function");
        });
      }
      function we(t) {
        t === void 0 && (t = {});
        var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o2 = e.defaultOptions, i = o2 === void 0 ? Ot : o2;
        return function(a2, s2, f2) {
          f2 === void 0 && (f2 = i);
          var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p2) {
            var g = typeof p2 == "function" ? p2(c2.options) : p2;
            h2(), c2.options = Object.assign({}, i, c2.options, g), c2.scrollParents = { reference: Q(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
            var x2 = un(dn([].concat(r, c2.options.modifiers)));
            return c2.orderedModifiers = x2.filter(function(y) {
              return y.enabled;
            }), l2(), v2.update();
          }, forceUpdate: function() {
            if (!m2) {
              var p2 = c2.elements, g = p2.reference, x2 = p2.popper;
              if ($t(g, x2)) {
                c2.rects = { reference: cn(g, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j) {
                  return c2.modifiersData[j.name] = Object.assign({}, j.data);
                });
                for (var y = 0; y < c2.orderedModifiers.length; y++) {
                  if (c2.reset === true) {
                    c2.reset = false, y = -1;
                    continue;
                  }
                  var $ = c2.orderedModifiers[y], d2 = $.fn, b2 = $.options, w2 = b2 === void 0 ? {} : b2, O2 = $.name;
                  typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p2) {
              v2.forceUpdate(), p2(c2);
            });
          }), destroy: function() {
            h2(), m2 = true;
          } };
          if (!$t(a2, s2))
            return v2;
          v2.setOptions(f2).then(function(p2) {
            !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
          });
          function l2() {
            c2.orderedModifiers.forEach(function(p2) {
              var g = p2.name, x2 = p2.options, y = x2 === void 0 ? {} : x2, $ = p2.effect;
              if (typeof $ == "function") {
                var d2 = $({ state: c2, name: g, instance: v2, options: y }), b2 = function() {
                };
                u2.push(d2 || b2);
              }
            });
          }
          function h2() {
            u2.forEach(function(p2) {
              return p2();
            }), u2 = [];
          }
          return v2;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = computed$1(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = shallowRef();
        const states = ref({
          styles: {
            popper: {
              position: unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        watch(options, (newOptions) => {
          const instance = unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, unref(options));
        });
        onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: computed$1(() => {
            var _a;
            return { ...((_a = unref(instanceRef)) == null ? void 0 : _a.state) || {} };
          }),
          styles: computed$1(() => unref(states).styles),
          attributes: computed$1(() => unref(states).attributes),
          update: () => {
            var _a;
            return (_a = unref(instanceRef)) == null ? void 0 : _a.update();
          },
          forceUpdate: () => {
            var _a;
            return (_a = unref(instanceRef)) == null ? void 0 : _a.forceUpdate();
          },
          instanceRef: computed$1(() => unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const useSameTarget = (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e) => {
          mousedownTarget = e.target === e.currentTarget;
        };
        const onMouseup = (e) => {
          mouseupTarget = e.target === e.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      };
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      let registeredEscapeHandlers = [];
      const cachedHandler = (e) => {
        const event = e;
        if (event.key === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient)
            registeredEscapeHandlers.push(handler);
        });
        onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      let cachedContainer;
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id = computed$1(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = computed$1(() => `#${id.value}`);
        return {
          id,
          selector
        };
      };
      const createContainer = (id) => {
        const container = document.createElement("div");
        container.id = id;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id, selector } = usePopperContainerId();
        onBeforeMount(() => {
          if (!isClient)
            return;
          if (!cachedContainer && !document.body.querySelector(selector.value)) {
            cachedContainer = createContainer(id.value);
          }
        });
        return {
          id,
          selector
        };
      };
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open,
        close
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open(event);
            const _autoClose = unref(autoClose);
            if (isNumber(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close(event);
              }, _autoClose);
            }
          }, unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close(event);
          }, unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const initial = {
        current: 0
      };
      const zIndex = ref(0);
      const defaultInitialZIndex = 2e3;
      const ZINDEX_INJECTION_KEY = Symbol("elZIndexContextKey");
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const increasingInjection = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial;
        const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
        const initialZIndex = computed$1(() => {
          const zIndexFromInjection = unref(zIndexInjection);
          return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = computed$1(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          increasingInjection.current++;
          zIndex.value = increasingInjection.current;
          return currentZIndex.value;
        };
        if (!isClient && !inject(ZINDEX_INJECTION_KEY))
          ;
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      function useCursor(input) {
        const selectionRef = ref();
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionRef.value = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionRef.value == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      function useFocusController(target, { afterFocus, beforeBlur, afterBlur } = {}) {
        const instance = getCurrentInstance();
        const { emit } = instance;
        const wrapperRef = shallowRef();
        const isFocused = ref(false);
        const handleFocus = (event) => {
          if (isFocused.value)
            return;
          isFocused.value = true;
          emit("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a;
          const cancelBlur = isFunction$1(beforeBlur) ? beforeBlur(event) : false;
          if (cancelBlur || event.relatedTarget && ((_a = wrapperRef.value) == null ? void 0 : _a.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a;
          (_a = target.value) == null ? void 0 : _a.focus();
        };
        watch(wrapperRef, (el) => {
          if (el) {
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener(wrapperRef, "click", handleClick);
        return {
          wrapperRef,
          isFocused,
          handleFocus,
          handleBlur
        };
      }
      const DEFAULT_EMPTY_VALUES = ["", void 0, null];
      const DEFAULT_VALUE_ON_CLEAR = void 0;
      const useEmptyValuesProps = buildProps({
        emptyValues: Array,
        valueOnClear: {
          type: [String, Number, Boolean, Function],
          default: void 0,
          validator: (val) => isFunction$1(val) ? !val() : !val
        }
      });
      const useEmptyValues = (props, defaultValue) => {
        const config = useGlobalConfig();
        config.value = config.value || {};
        const emptyValues = computed$1(() => props.emptyValues || config.value.emptyValues || DEFAULT_EMPTY_VALUES);
        const valueOnClear = computed$1(() => {
          if (isFunction$1(props.valueOnClear)) {
            return props.valueOnClear();
          } else if (props.valueOnClear !== void 0) {
            return props.valueOnClear;
          } else if (isFunction$1(config.value.valueOnClear)) {
            return config.value.valueOnClear();
          } else if (config.value.valueOnClear !== void 0) {
            return config.value.valueOnClear;
          }
          return defaultValue !== void 0 ? defaultValue : DEFAULT_VALUE_ON_CLEAR;
        });
        const isEmptyValue2 = (value) => {
          return emptyValues.value.includes(value);
        };
        if (!emptyValues.value.includes(valueOnClear.value))
          ;
        return {
          emptyValues,
          valueOnClear,
          isEmptyValue: isEmptyValue2
        };
      };
      const formMetaProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        },
        disabled: Boolean
      });
      const formProps = buildProps({
        ...formMetaProps,
        model: Object,
        rules: {
          type: definePropType(Object)
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top"],
          default: "right"
        },
        requireAsteriskPosition: {
          type: String,
          values: ["left", "right"],
          default: "left"
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelSuffix: {
          type: String,
          default: ""
        },
        inline: Boolean,
        inlineMessage: Boolean,
        statusIcon: Boolean,
        showMessage: {
          type: Boolean,
          default: true
        },
        validateOnRuleChange: {
          type: Boolean,
          default: true
        },
        hideRequiredAsterisk: Boolean,
        scrollToError: Boolean,
        scrollIntoViewOptions: {
          type: [Object, Boolean]
        }
      });
      const formEmits = {
        validate: (prop, isValid, message) => (isArray$1(prop) || isString(prop)) && isBoolean(isValid) && isString(message)
      };
      function useFormLabelWidth() {
        const potentialLabelWidthArr = ref([]);
        const autoLabelWidth = computed$1(() => {
          if (!potentialLabelWidthArr.value.length)
            return "0";
          const max = Math.max(...potentialLabelWidthArr.value);
          return max ? `${max}px` : "";
        });
        function getLabelWidthIndex(width) {
          const index = potentialLabelWidthArr.value.indexOf(width);
          if (index === -1 && autoLabelWidth.value === "0")
            ;
          return index;
        }
        function registerLabelWidth(val, oldVal) {
          if (val && oldVal) {
            const index = getLabelWidthIndex(oldVal);
            potentialLabelWidthArr.value.splice(index, 1, val);
          } else if (val) {
            potentialLabelWidthArr.value.push(val);
          }
        }
        function deregisterLabelWidth(val) {
          const index = getLabelWidthIndex(val);
          if (index > -1) {
            potentialLabelWidthArr.value.splice(index, 1);
          }
        }
        return {
          autoLabelWidth,
          registerLabelWidth,
          deregisterLabelWidth
        };
      }
      const filterFields = (fields, props) => {
        const normalized = castArray(props);
        return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
      };
      const COMPONENT_NAME$9 = "ElForm";
      const __default__$D = defineComponent({
        name: COMPONENT_NAME$9
      });
      const _sfc_main$14 = /* @__PURE__ */ defineComponent({
        ...__default__$D,
        props: formProps,
        emits: formEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const fields = [];
          const formSize = useFormSize();
          const ns = useNamespace("form");
          const formClasses = computed$1(() => {
            const { labelPosition, inline } = props;
            return [
              ns.b(),
              ns.m(formSize.value || "default"),
              {
                [ns.m(`label-${labelPosition}`)]: labelPosition,
                [ns.m("inline")]: inline
              }
            ];
          });
          const getField = (prop) => {
            return fields.find((field) => field.prop === prop);
          };
          const addField = (field) => {
            fields.push(field);
          };
          const removeField = (field) => {
            if (field.prop) {
              fields.splice(fields.indexOf(field), 1);
            }
          };
          const resetFields = (properties = []) => {
            if (!props.model) {
              return;
            }
            filterFields(fields, properties).forEach((field) => field.resetField());
          };
          const clearValidate = (props2 = []) => {
            filterFields(fields, props2).forEach((field) => field.clearValidate());
          };
          const isValidatable = computed$1(() => {
            const hasModel = !!props.model;
            return hasModel;
          });
          const obtainValidateFields = (props2) => {
            if (fields.length === 0)
              return [];
            const filteredFields = filterFields(fields, props2);
            if (!filteredFields.length) {
              return [];
            }
            return filteredFields;
          };
          const validate = async (callback) => validateField(void 0, callback);
          const doValidateField = async (props2 = []) => {
            if (!isValidatable.value)
              return false;
            const fields2 = obtainValidateFields(props2);
            if (fields2.length === 0)
              return true;
            let validationErrors = {};
            for (const field of fields2) {
              try {
                await field.validate("");
              } catch (fields3) {
                validationErrors = {
                  ...validationErrors,
                  ...fields3
                };
              }
            }
            if (Object.keys(validationErrors).length === 0)
              return true;
            return Promise.reject(validationErrors);
          };
          const validateField = async (modelProps = [], callback) => {
            const shouldThrow = !isFunction$1(callback);
            try {
              const result = await doValidateField(modelProps);
              if (result === true) {
                callback == null ? void 0 : callback(result);
              }
              return result;
            } catch (e) {
              if (e instanceof Error)
                throw e;
              const invalidFields = e;
              if (props.scrollToError) {
                scrollToField(Object.keys(invalidFields)[0]);
              }
              callback == null ? void 0 : callback(false, invalidFields);
              return shouldThrow && Promise.reject(invalidFields);
            }
          };
          const scrollToField = (prop) => {
            var _a;
            const field = filterFields(fields, prop)[0];
            if (field) {
              (_a = field.$el) == null ? void 0 : _a.scrollIntoView(props.scrollIntoViewOptions);
            }
          };
          watch(() => props.rules, () => {
            if (props.validateOnRuleChange) {
              validate().catch((err) => debugWarn());
            }
          }, { deep: true });
          provide(formContextKey, reactive({
            ...toRefs(props),
            emit,
            resetFields,
            clearValidate,
            validateField,
            getField,
            addField,
            removeField,
            ...useFormLabelWidth()
          }));
          expose({
            validate,
            validateField,
            resetFields,
            clearValidate,
            scrollToField
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("form", {
              class: normalizeClass(unref(formClasses))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Form = /* @__PURE__ */ _export_sfc$1(_sfc_main$14, [["__file", "form.vue"]]);
      var define_process_env_default = {};
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o2) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
          return o22.__proto__ || Object.getPrototypeOf(o22);
        };
        return _getPrototypeOf(o2);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
          o22.__proto__ = p22;
          return o22;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn2) {
        return Function.toString.call(fn2).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      if (typeof process !== "undefined" && define_process_env_default && false) {
        warning = function warning3(type4, errors) {
          if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
            if (errors.every(function(e) {
              return typeof e === "string";
            })) {
              console.warn(type4, errors);
            }
          }
        };
      }
      function convertFieldsError(errors) {
        if (!errors || !errors.length)
          return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format(template) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i = 0;
        var len = args.length;
        if (typeof template === "function") {
          return template.apply(null, args);
        }
        if (typeof template === "string") {
          var str = template.replace(formatRegExp, function(x2) {
            if (x2 === "%%") {
              return "%";
            }
            if (i >= len) {
              return x2;
            }
            switch (x2) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_2) {
                  return "[Circular]";
                }
                break;
              default:
                return x2;
            }
          });
          return str;
        }
        return template;
      }
      function isNativeStringType(type4) {
        return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
      }
      function isEmptyValue(value, type4) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type4 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type4) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total++;
          if (total === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a2) {
          func(a2, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index = 0;
        var arrLength = arr.length;
        function next(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index;
          index = index + 1;
          if (original < arrLength) {
            func(arr[original], next);
          } else {
            callback([]);
          }
        }
        next([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k) {
          ret.push.apply(ret, objArr[k] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve, reject) {
            var next = function next2(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next);
          });
          _pending["catch"](function(e) {
            return e;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total = 0;
        var results = [];
        var pending = new Promise(function(resolve, reject) {
          var next = function next2(errors) {
            results.push.apply(results, errors);
            total++;
            if (total === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func, next);
            } else {
              asyncParallelArray(arr, func, next);
            }
          });
        });
        pending["catch"](function(e) {
          return e;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue(value, path) {
        var v2 = value;
        for (var i = 0; i < path.length; i++) {
          if (v2 == void 0) {
            return v2;
          }
          v2 = v2[path[i]];
        }
        return v2;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s2 in source) {
            if (source.hasOwnProperty(s2)) {
              var value = source[s2];
              if (typeof value === "object" && typeof target[s2] === "object") {
                target[s2] = _extends({}, target[s2], value);
              } else {
                target[s2] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required(rule, value, source, errors, options, type4) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
          errors.push(format(options.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b2 = function b22(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        // url: new RegExp(
        //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
        //   'i',
        // ),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array(value) {
          return Array.isArray(value);
        },
        regexp: function regexp(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e) {
            return false;
          }
        },
        date: function date(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options) {
        var len = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format(options.messages[key].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format(options.messages[key].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method2 = function method3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number2 = function number3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp2 = function regexp3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer2 = function integer3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array2 = function array3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object2 = function object3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable2 = function enumerable3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern2 = function pattern3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date2 = function date3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required2 = function required3(rule, value, callback, source, options) {
        var errors = [];
        var type4 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type4);
        callback(errors);
      };
      var type2 = function type3(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators = {
        string,
        method: method2,
        number: number2,
        "boolean": _boolean,
        regexp: regexp2,
        integer: integer2,
        "float": floatFn,
        array: array2,
        object: object2,
        "enum": enumerable2,
        pattern: pattern2,
        date: date2,
        url: type2,
        hex: type2,
        email: type2,
        required: required2,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone2() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o2, oc) {
          var _this2 = this;
          if (o2 === void 0) {
            o2 = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o2;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add(e) {
              if (Array.isArray(e)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e);
              } else {
                errors.push(e);
              }
            }
            for (var i = 0; i < results.length; i++) {
              add(results[i]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z) {
            var arr = _this2.rules[z];
            var value = source[z];
            arr.forEach(function(r) {
              var rule = r;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z;
              rule.fullField = rule.fullField || z;
              rule.type = _this2.getType(rule);
              series[z] = series[z] || [];
              series[z].push({
                rule,
                value,
                source,
                field: z
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e) {
              if (e === void 0) {
                e = [];
              }
              var errorList = Array.isArray(e) ? e : [e];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e) {
                return cb(e);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type4, validator) {
        if (typeof validator !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type4] = validator;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators;
      const formItemValidateStates = [
        "",
        "error",
        "validating",
        "success"
      ];
      const formItemProps = buildProps({
        label: String,
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        prop: {
          type: definePropType([String, Array])
        },
        required: {
          type: Boolean,
          default: void 0
        },
        rules: {
          type: definePropType([Object, Array])
        },
        error: String,
        validateStatus: {
          type: String,
          values: formItemValidateStates
        },
        for: String,
        inlineMessage: {
          type: [String, Boolean],
          default: ""
        },
        showMessage: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          values: componentSizes
        }
      });
      const COMPONENT_NAME$8 = "ElLabelWrap";
      var FormLabelWrap = defineComponent({
        name: COMPONENT_NAME$8,
        props: {
          isAutoWidth: Boolean,
          updateAll: Boolean
        },
        setup(props, {
          slots
        }) {
          const formContext = inject(formContextKey, void 0);
          const formItemContext = inject(formItemContextKey);
          if (!formItemContext)
            throwError(COMPONENT_NAME$8, "usage: <el-form-item><label-wrap /></el-form-item>");
          const ns = useNamespace("form");
          const el = ref();
          const computedWidth = ref(0);
          const getLabelWidth = () => {
            var _a;
            if ((_a = el.value) == null ? void 0 : _a.firstElementChild) {
              const width = window.getComputedStyle(el.value.firstElementChild).width;
              return Math.ceil(Number.parseFloat(width));
            } else {
              return 0;
            }
          };
          const updateLabelWidth = (action = "update") => {
            nextTick(() => {
              if (slots.default && props.isAutoWidth) {
                if (action === "update") {
                  computedWidth.value = getLabelWidth();
                } else if (action === "remove") {
                  formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
                }
              }
            });
          };
          const updateLabelWidthFn = () => updateLabelWidth("update");
          onMounted(() => {
            updateLabelWidthFn();
          });
          onBeforeUnmount(() => {
            updateLabelWidth("remove");
          });
          onUpdated(() => updateLabelWidthFn());
          watch(computedWidth, (val, oldVal) => {
            if (props.updateAll) {
              formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
            }
          });
          useResizeObserver(computed$1(() => {
            var _a, _b;
            return (_b = (_a = el.value) == null ? void 0 : _a.firstElementChild) != null ? _b : null;
          }), updateLabelWidthFn);
          return () => {
            var _a, _b;
            if (!slots)
              return null;
            const {
              isAutoWidth
            } = props;
            if (isAutoWidth) {
              const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
              const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
              const style = {};
              if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
                const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
                const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
                if (marginWidth) {
                  style[marginPosition] = `${marginWidth}px`;
                }
              }
              return createVNode("div", {
                "ref": el,
                "class": [ns.be("item", "label-wrap")],
                "style": style
              }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
            } else {
              return createVNode(Fragment, {
                "ref": el
              }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
            }
          };
        }
      });
      const _hoisted_1$F = ["role", "aria-labelledby"];
      const __default__$C = defineComponent({
        name: "ElFormItem"
      });
      const _sfc_main$13 = /* @__PURE__ */ defineComponent({
        ...__default__$C,
        props: formItemProps,
        setup(__props, { expose }) {
          const props = __props;
          const slots = useSlots();
          const formContext = inject(formContextKey, void 0);
          const parentFormItemContext = inject(formItemContextKey, void 0);
          const _size = useFormSize(void 0, { formItem: false });
          const ns = useNamespace("form-item");
          const labelId = useId().value;
          const inputIds = ref([]);
          const validateState = ref("");
          const validateStateDebounced = refDebounced(validateState, 100);
          const validateMessage = ref("");
          const formItemRef = ref();
          let initialValue = void 0;
          let isResettingField = false;
          const labelStyle = computed$1(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (labelWidth)
              return { width: labelWidth };
            return {};
          });
          const contentStyle = computed$1(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
              return {};
            }
            if (!props.label && !props.labelWidth && isNested) {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (!props.label && !slots.label) {
              return { marginLeft: labelWidth };
            }
            return {};
          });
          const formItemClasses = computed$1(() => [
            ns.b(),
            ns.m(_size.value),
            ns.is("error", validateState.value === "error"),
            ns.is("validating", validateState.value === "validating"),
            ns.is("success", validateState.value === "success"),
            ns.is("required", isRequired.value || props.required),
            ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
            (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
            { [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
          ]);
          const _inlineMessage = computed$1(() => isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
          const validateClasses = computed$1(() => [
            ns.e("error"),
            { [ns.em("error", "inline")]: _inlineMessage.value }
          ]);
          const propString = computed$1(() => {
            if (!props.prop)
              return "";
            return isString(props.prop) ? props.prop : props.prop.join(".");
          });
          const hasLabel = computed$1(() => {
            return !!(props.label || slots.label);
          });
          const labelFor = computed$1(() => {
            return props.for || (inputIds.value.length === 1 ? inputIds.value[0] : void 0);
          });
          const isGroup = computed$1(() => {
            return !labelFor.value && hasLabel.value;
          });
          const isNested = !!parentFormItemContext;
          const fieldValue = computed$1(() => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop) {
              return;
            }
            return getProp(model, props.prop).value;
          });
          const normalizedRules = computed$1(() => {
            const { required: required4 } = props;
            const rules2 = [];
            if (props.rules) {
              rules2.push(...castArray(props.rules));
            }
            const formRules = formContext == null ? void 0 : formContext.rules;
            if (formRules && props.prop) {
              const _rules = getProp(formRules, props.prop).value;
              if (_rules) {
                rules2.push(...castArray(_rules));
              }
            }
            if (required4 !== void 0) {
              const requiredRules = rules2.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes("required"));
              if (requiredRules.length > 0) {
                for (const [rule, i] of requiredRules) {
                  if (rule.required === required4)
                    continue;
                  rules2[i] = { ...rule, required: required4 };
                }
              } else {
                rules2.push({ required: required4 });
              }
            }
            return rules2;
          });
          const validateEnabled = computed$1(() => normalizedRules.value.length > 0);
          const getFilteredRule = (trigger) => {
            const rules2 = normalizedRules.value;
            return rules2.filter((rule) => {
              if (!rule.trigger || !trigger)
                return true;
              if (Array.isArray(rule.trigger)) {
                return rule.trigger.includes(trigger);
              } else {
                return rule.trigger === trigger;
              }
            }).map(({ trigger: trigger2, ...rule }) => rule);
          };
          const isRequired = computed$1(() => normalizedRules.value.some((rule) => rule.required));
          const shouldShowError = computed$1(() => {
            var _a;
            return validateStateDebounced.value === "error" && props.showMessage && ((_a = formContext == null ? void 0 : formContext.showMessage) != null ? _a : true);
          });
          const currentLabel = computed$1(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
          const setValidationState = (state) => {
            validateState.value = state;
          };
          const onValidationFailed = (error) => {
            var _a, _b;
            const { errors, fields } = error;
            if (!errors || !fields) {
              console.error(error);
            }
            setValidationState("error");
            validateMessage.value = errors ? (_b = (_a = errors == null ? void 0 : errors[0]) == null ? void 0 : _a.message) != null ? _b : `${props.prop} is required` : "";
            formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
          };
          const onValidationSucceeded = () => {
            setValidationState("success");
            formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
          };
          const doValidate = async (rules2) => {
            const modelName = propString.value;
            const validator = new Schema({
              [modelName]: rules2
            });
            return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
              onValidationSucceeded();
              return true;
            }).catch((err) => {
              onValidationFailed(err);
              return Promise.reject(err);
            });
          };
          const validate = async (trigger, callback) => {
            if (isResettingField || !props.prop) {
              return false;
            }
            const hasCallback = isFunction$1(callback);
            if (!validateEnabled.value) {
              callback == null ? void 0 : callback(false);
              return false;
            }
            const rules2 = getFilteredRule(trigger);
            if (rules2.length === 0) {
              callback == null ? void 0 : callback(true);
              return true;
            }
            setValidationState("validating");
            return doValidate(rules2).then(() => {
              callback == null ? void 0 : callback(true);
              return true;
            }).catch((err) => {
              const { fields } = err;
              callback == null ? void 0 : callback(false, fields);
              return hasCallback ? false : Promise.reject(fields);
            });
          };
          const clearValidate = () => {
            setValidationState("");
            validateMessage.value = "";
            isResettingField = false;
          };
          const resetField = async () => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop)
              return;
            const computedValue = getProp(model, props.prop);
            isResettingField = true;
            computedValue.value = clone(initialValue);
            await nextTick();
            clearValidate();
            isResettingField = false;
          };
          const addInputId = (id) => {
            if (!inputIds.value.includes(id)) {
              inputIds.value.push(id);
            }
          };
          const removeInputId = (id) => {
            inputIds.value = inputIds.value.filter((listId) => listId !== id);
          };
          watch(() => props.error, (val) => {
            validateMessage.value = val || "";
            setValidationState(val ? "error" : "");
          }, { immediate: true });
          watch(() => props.validateStatus, (val) => setValidationState(val || ""));
          const context = reactive({
            ...toRefs(props),
            $el: formItemRef,
            size: _size,
            validateState,
            labelId,
            inputIds,
            isGroup,
            hasLabel,
            fieldValue,
            addInputId,
            removeInputId,
            resetField,
            clearValidate,
            validate
          });
          provide(formItemContextKey, context);
          onMounted(() => {
            if (props.prop) {
              formContext == null ? void 0 : formContext.addField(context);
              initialValue = clone(fieldValue.value);
            }
          });
          onBeforeUnmount(() => {
            formContext == null ? void 0 : formContext.removeField(context);
          });
          expose({
            size: _size,
            validateMessage,
            validateState,
            validate,
            clearValidate,
            resetField
          });
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("div", {
              ref_key: "formItemRef",
              ref: formItemRef,
              class: normalizeClass(unref(formItemClasses)),
              role: unref(isGroup) ? "group" : void 0,
              "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
            }, [
              createVNode(unref(FormLabelWrap), {
                "is-auto-width": unref(labelStyle).width === "auto",
                "update-all": ((_a = unref(formContext)) == null ? void 0 : _a.labelWidth) === "auto"
              }, {
                default: withCtx(() => [
                  unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                    key: 0,
                    id: unref(labelId),
                    for: unref(labelFor),
                    class: normalizeClass(unref(ns).e("label")),
                    style: normalizeStyle(unref(labelStyle))
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                        createTextVNode(toDisplayString(unref(currentLabel)), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["is-auto-width", "update-all"]),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("content")),
                style: normalizeStyle(unref(contentStyle))
              }, [
                renderSlot(_ctx.$slots, "default"),
                createVNode(TransitionGroup, {
                  name: `${unref(ns).namespace.value}-zoom-in-top`
                }, {
                  default: withCtx(() => [
                    unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                      key: 0,
                      error: validateMessage.value
                    }, () => [
                      createElementVNode("div", {
                        class: normalizeClass(unref(validateClasses))
                      }, toDisplayString(validateMessage.value), 3)
                    ]) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ], 6)
            ], 10, _hoisted_1$F);
          };
        }
      });
      var FormItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$13, [["__file", "form-item.vue"]]);
      const ElForm = withInstall(Form, {
        FormItem
      });
      const ElFormItem = withNoopInstall(FormItem);
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style = window.getComputedStyle(targetElement);
        const boxSizing = style.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result.minHeight = `${minHeight}px`;
        }
        if (isNumber(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result.height = `${height}px`;
        (_a = hiddenTextarea.parentNode) == null ? void 0 : _a.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result;
      }
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        maxlength: {
          type: [String, Number]
        },
        minlength: {
          type: [String, Number]
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: {
          type: Boolean,
          default: false
        },
        clearable: {
          type: Boolean,
          default: false
        },
        showPassword: {
          type: Boolean,
          default: false
        },
        showWordLimit: {
          type: Boolean,
          default: false
        },
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        },
        autofocus: {
          type: Boolean,
          default: false
        }
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString(value),
        input: (value) => isString(value),
        change: (value) => isString(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const _hoisted_1$E = ["role"];
      const _hoisted_2$u = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"];
      const _hoisted_3$g = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"];
      const __default__$B = defineComponent({
        name: "ElInput",
        inheritAttrs: false
      });
      const _sfc_main$12 = /* @__PURE__ */ defineComponent({
        ...__default__$B,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const rawAttrs = useAttrs$1();
          const slots = useSlots();
          const containerAttrs = computed$1(() => {
            const comboBoxAttrs = {};
            if (props.containerRole === "combobox") {
              comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
              comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
              comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
            }
            return comboBoxAttrs;
          });
          const containerKls = computed$1(() => [
            props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.bm("group", "append")]: slots.append,
              [nsInput.bm("group", "prepend")]: slots.prepend,
              [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value,
              [nsInput.b("hidden")]: props.type === "hidden"
            },
            rawAttrs.class
          ]);
          const wrapperKls = computed$1(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const attrs = useAttrs({
            excludeKeys: computed$1(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const { form: elForm, formItem: elFormItem } = useFormItem();
          const { inputId } = useFormItemInputId(props, {
            formItemContext: elFormItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = shallowRef();
          const textarea = shallowRef();
          const hovering = ref(false);
          const isComposing = ref(false);
          const passwordVisible = ref(false);
          const countStyle = ref();
          const textareaCalcStyle = shallowRef(props.inputStyle);
          const _ref = computed$1(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            afterBlur() {
              var _a;
              if (props.validateEvent) {
                (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = computed$1(() => {
            var _a;
            return (_a = elForm == null ? void 0 : elForm.statusIcon) != null ? _a : false;
          });
          const validateState = computed$1(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
          const validateIcon = computed$1(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = computed$1(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = computed$1(() => [
            rawAttrs.style
          ]);
          const textareaStyle = computed$1(() => [
            props.inputStyle,
            textareaCalcStyle.value,
            { resize: props.resize }
          ]);
          const nativeInputValue = computed$1(() => isNil(props.modelValue) ? "" : String(props.modelValue));
          const showClear = computed$1(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = computed$1(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = computed$1(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
          const textLength = computed$1(() => nativeInputValue.value.length);
          const inputExceed = computed$1(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
          const suffixVisible = computed$1(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type: type4, autosize } = props;
            if (!isClient || type4 !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a;
              if (isInit || !props.autosize)
                return;
              const isElHidden = ((_a = textarea.value) == null ? void 0 : _a.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props.formatter) {
              value = props.parser ? props.parser(value) : value;
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit(UPDATE_MODEL_EVENT, value);
            emit("input", value);
            await nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            emit("change", event.target.value);
          };
          const handleCompositionStart = (event) => {
            emit("compositionstart", event);
            isComposing.value = true;
          };
          const handleCompositionUpdate = (event) => {
            var _a;
            emit("compositionupdate", event);
            const text = (_a = event.target) == null ? void 0 : _a.value;
            const lastCharacter = text[text.length - 1] || "";
            isComposing.value = !isKorean(lastCharacter);
          };
          const handleCompositionEnd = (event) => {
            emit("compositionend", event);
            if (isComposing.value) {
              isComposing.value = false;
              handleInput(event);
            }
          };
          const handlePasswordVisible = () => {
            passwordVisible.value = !passwordVisible.value;
            focus();
          };
          const focus = async () => {
            var _a;
            await nextTick();
            (_a = _ref.value) == null ? void 0 : _a.focus();
          };
          const blur = () => {
            var _a;
            return (_a = _ref.value) == null ? void 0 : _a.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit("keydown", evt);
          };
          const select = () => {
            var _a;
            (_a = _ref.value) == null ? void 0 : _a.select();
          };
          const clear = () => {
            emit(UPDATE_MODEL_EVENT, "");
            emit("change", "");
            emit("clear");
            emit("input", "");
          };
          watch(() => props.modelValue, () => {
            var _a;
            nextTick(() => resizeTextarea());
            if (props.validateEvent) {
              (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change").catch((err) => debugWarn());
            }
          });
          watch(nativeInputValue, () => setNativeInputValue());
          watch(() => props.type, async () => {
            await nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          onMounted(() => {
            if (!props.formatter && props.parser)
              ;
            setNativeInputValue();
            nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: toRef(props, "autosize"),
            focus,
            blur,
            select,
            clear,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
              class: unref(containerKls),
              style: unref(containerStyle),
              role: _ctx.containerRole,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }), [
              createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).be("group", "prepend"))
                }, [
                  renderSlot(_ctx.$slots, "prepend")
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: normalizeClass(unref(wrapperKls))
                }, [
                  createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("prefix"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsInput).e("prefix-inner"))
                    }, [
                      renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createElementVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: unref(nsInput).e("inner")
                  }, unref(attrs), {
                    minlength: _ctx.minlength,
                    maxlength: _ctx.maxlength,
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: unref(inputDisabled),
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.label,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: _ctx.form,
                    autofocus: _ctx.autofocus,
                    onCompositionstart: handleCompositionStart,
                    onCompositionupdate: handleCompositionUpdate,
                    onCompositionend: handleCompositionEnd,
                    onInput: handleInput,
                    onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                    onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, _hoisted_2$u),
                  createCommentVNode(" suffix slot "),
                  unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(nsInput).e("suffix"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsInput).e("suffix-inner"))
                    }, [
                      !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass(unref(nsInput).e("icon"))
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 64)) : createCommentVNode("v-if", true),
                      unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                        onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                        onClick: clear
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                      unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                        key: 3,
                        class: normalizeClass(unref(nsInput).e("count"))
                      }, [
                        createElementVNode("span", {
                          class: normalizeClass(unref(nsInput).e("count-inner"))
                        }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 3)
                      ], 2)) : createCommentVNode("v-if", true),
                      unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 4,
                        class: normalizeClass([
                          unref(nsInput).e("icon"),
                          unref(nsInput).e("validateIcon"),
                          unref(nsInput).is("loading", unref(validateState) === "validating")
                        ])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createCommentVNode(" append slot "),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).be("group", "append"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" textarea "),
                createElementVNode("textarea", mergeProps({
                  id: unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: unref(nsTextarea).e("inner")
                }, unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  tabindex: _ctx.tabindex,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: unref(textareaStyle),
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_3$g),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  style: normalizeStyle(countStyle.value),
                  class: normalizeClass(unref(nsInput).e("count"))
                }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
              ], 64))
            ], 16, _hoisted_1$E);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$12, [["__file", "input.vue"]]);
      const ElInput = withInstall(Input);
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle = ({
        move,
        size,
        bar
      }) => ({
        [bar.size]: size,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$7 = "Thumb";
      const _sfc_main$11 = /* @__PURE__ */ defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$7, "can not inject scrollbar context");
          const instance = ref();
          const thumb = ref();
          const thumbState = ref({});
          const visible = ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient ? document.onselectstart : null;
          const bar = computed$1(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = computed$1(() => renderThumbStyle({
            size: props.size,
            move: props.move,
            bar: bar.value
          }));
          const offsetRatio = computed$1(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e) => {
            var _a;
            e.stopPropagation();
            if (e.ctrlKey || [1, 2].includes(e.button))
              return;
            (_a = window.getSelection()) == null ? void 0 : _a.removeAllRanges();
            startDrag(e);
            const el = e.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e) => {
            e.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                  onMousedown: clickTrackHandler
                }, [
                  createElementVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(ns).e("thumb")),
                    style: normalizeStyle(unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 34), [
                  [vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$11, [["__file", "thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        minSize: {
          type: Number,
          required: true
        }
      });
      const _sfc_main$10 = /* @__PURE__ */ defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const moveX = ref(0);
          const moveY = ref(0);
          const sizeWidth = ref("");
          const sizeHeight = ref("");
          const ratioY = ref(1);
          const ratioX = ref(1);
          const handleScroll = (wrap) => {
            if (wrap) {
              const offsetHeight = wrap.offsetHeight - GAP;
              const offsetWidth = wrap.offsetWidth - GAP;
              moveY.value = wrap.scrollTop * 100 / offsetHeight * ratioY.value;
              moveX.value = wrap.scrollLeft * 100 / offsetWidth * ratioX.value;
            }
          };
          const update = () => {
            const wrap = scrollbar == null ? void 0 : scrollbar.wrapElement;
            if (!wrap)
              return;
            const offsetHeight = wrap.offsetHeight - GAP;
            const offsetWidth = wrap.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrap.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrap.scrollWidth;
            const height = Math.max(originalHeight, props.minSize);
            const width = Math.max(originalWidth, props.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          expose({
            handleScroll,
            update
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(Thumb, {
                move: moveX.value,
                ratio: ratioX.value,
                size: sizeWidth.value,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              createVNode(Thumb, {
                move: moveY.value,
                ratio: ratioY.value,
                size: sizeHeight.value,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$10, [["__file", "bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        },
        id: String,
        role: String,
        ariaLabel: String,
        ariaOrientation: {
          type: String,
          values: ["horizontal", "vertical"]
        }
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber)
      };
      const COMPONENT_NAME$6 = "ElScrollbar";
      const __default__$A = defineComponent({
        name: COMPONENT_NAME$6
      });
      const _sfc_main$$ = /* @__PURE__ */ defineComponent({
        ...__default__$A,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          const scrollbarRef = ref();
          const wrapRef = ref();
          const resizeRef = ref();
          const barRef = ref();
          const wrapStyle = computed$1(() => {
            const style = {};
            if (props.height)
              style.height = addUnit(props.height);
            if (props.maxHeight)
              style.maxHeight = addUnit(props.maxHeight);
            return [props.wrapStyle, style];
          });
          const wrapKls = computed$1(() => {
            return [
              props.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props.native }
            ];
          });
          const resizeKls = computed$1(() => {
            return [ns.e("view"), props.viewClass];
          });
          const handleScroll = () => {
            var _a;
            if (wrapRef.value) {
              (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);
              emit("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$1(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber(arg1) && isNumber(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            var _a;
            (_a = barRef.value) == null ? void 0 : _a.update();
          };
          watch(() => props.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
              stopResizeListener = useEventListener("resize", update);
            }
          }, { immediate: true });
          watch(() => [props.maxHeight, props.height], () => {
            if (!props.native)
              nextTick(() => {
                var _a;
                update();
                if (wrapRef.value) {
                  (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);
                }
              });
          });
          provide(scrollbarContextKey, reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          onMounted(() => {
            if (!props.native)
              nextTick(() => {
                update();
              });
          });
          onUpdated(() => update());
          expose({
            wrapRef,
            update,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createElementVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: normalizeClass(unref(wrapKls)),
                style: normalizeStyle(unref(wrapStyle)),
                onScroll: handleScroll
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                  id: _ctx.id,
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: normalizeClass(unref(resizeKls)),
                  style: normalizeStyle(_ctx.viewStyle),
                  role: _ctx.role,
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": _ctx.ariaOrientation
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
              ], 38),
              !_ctx.native ? (openBlock(), createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                always: _ctx.always,
                "min-size": _ctx.minSize
              }, null, 8, ["always", "min-size"])) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$$, [["__file", "scrollbar.vue"]]);
      const ElScrollbar = withInstall(Scrollbar);
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$z = defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$_ = /* @__PURE__ */ defineComponent({
        ...__default__$z,
        props: popperProps,
        setup(__props, { expose }) {
          const props = __props;
          const triggerRef = ref();
          const popperInstanceRef = ref();
          const contentRef = ref();
          const referenceRef = ref();
          const role = computed$1(() => props.role);
          const popperProvides = {
            triggerRef,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["__file", "popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$y = defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$Z = /* @__PURE__ */ defineComponent({
        ...__default__$y,
        props: popperArrowProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          watch(() => props.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: normalizeClass(unref(ns).e("arrow")),
              style: normalizeStyle(unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$Z, [["__file", "arrow.vue"]]);
      const NAME = "ElOnlyChild";
      const OnlyChild = defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a;
          const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a : NOOP);
          return () => {
            var _a2;
            const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$1(child)) {
            switch (child.type) {
              case Comment:
                continue;
              case Text$1:
              case "svg":
                return wrapTextContent(child);
              case Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s2) {
        const ns = useNamespace("only-child");
        return createVNode("span", {
          "class": ns.e("content")
        }, [s2]);
      }
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const __default__$x = defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$Y = /* @__PURE__ */ defineComponent({
        ...__default__$x,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const { role, triggerRef } = inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef);
          const ariaControls = computed$1(() => {
            return ariaHaspopup.value ? props.id : void 0;
          });
          const ariaDescribedby = computed$1(() => {
            if (role && role.value === "tooltip") {
              return props.open && props.id ? props.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = computed$1(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = computed$1(() => {
            return ariaHaspopup.value ? `${props.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          onMounted(() => {
            watch(() => props.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef.value = unrefElement(virtualEl);
              }
            }, {
              immediate: true
            });
            watch(triggerRef, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement(el)) {
                [
                  "onMouseenter",
                  "onMouseleave",
                  "onClick",
                  "onKeydown",
                  "onFocus",
                  "onBlur",
                  "onContextmenu"
                ].forEach((eventName) => {
                  var _a;
                  const handler = props[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                  [
                    "aria-controls",
                    "aria-describedby",
                    "aria-haspopup",
                    "aria-expanded"
                  ].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (isElement(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": unref(ariaControls),
              "aria-describedby": unref(ariaDescribedby),
              "aria-expanded": unref(ariaExpanded),
              "aria-haspopup": unref(ariaHaspopup)
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$Y, [["__file", "trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = ref();
      const lastUserFocusTimestamp = ref(0);
      const lastAutomatedFocusTimestamp = ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last = getVisibleElement(focusable.reverse(), container);
        return [first, last];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack = [];
        const push = (layer) => {
          const currentLayer = stack[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack = removeFromStack(stack, layer);
          stack.unshift(layer);
        };
        const remove = (layer) => {
          var _a, _b;
          stack = removeFromStack(stack, layer);
          (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);
        };
        return {
          push,
          remove
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const _sfc_main$X = defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props, { emit }) {
          const forwardRef = ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props.trapped && !focusLayer.paused) {
              emit("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e) => {
            if (!props.loop && !props.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
            const { loop } = props;
            const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last] = getEdges(container);
              const isTabbable = first && last;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(last, true);
                  }
                }
              }
            }
          };
          provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          watch(() => props.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e) => {
            emit(ON_TRAP_FOCUS_EVT, e);
          };
          const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
          const onFocusIn = (e) => {
            const trapContainer = unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e.target;
            const relatedTarget = e.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit("focusin", e);
            if (focusLayer.paused)
              return;
            if (props.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e) => {
            const trapContainer = unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props.trapped) {
              const relatedTarget = e.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit("focusout", e);
            }
          };
          async function startTrap() {
            await nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props.focusStartEl;
                    if (!isString(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          onMounted(() => {
            if (props.trapped) {
              startTrap();
            }
            watch(() => props.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          onBeforeUnmount(() => {
            if (props.trapped) {
              stopTrap();
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["render", _sfc_render$g], ["__file", "focus-trap.vue"]]);
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: String,
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        virtualTriggering: Boolean,
        zIndex: Number
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const buildPopperOptions = (props, modifiers = []) => {
        const { placement, strategy, popperOptions } = props;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient)
          return;
        return unrefElement($el);
      };
      function genModifiers(options) {
        const { offset, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props) => {
        const { popperInstanceRef, contentRef, triggerRef, role } = inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = ref();
        const arrowOffset = ref();
        const eventListenerModifier = computed$1(() => {
          return {
            name: "eventListeners",
            enabled: !!props.visible
          };
        });
        const arrowModifier = computed$1(() => {
          var _a;
          const arrowEl = unref(arrowRef);
          const offset = (_a = unref(arrowOffset)) != null ? _a : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options = computed$1(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props, [
              unref(arrowModifier),
              unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = computed$1(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        watch(instanceRef, (instance) => popperInstanceRef.value = instance);
        onMounted(() => {
          watch(() => {
            var _a;
            return (_a = unref(computedReference)) == null ? void 0 : _a.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = computed$1(() => unref(attributes).popper);
        const contentZIndex = ref(isNumber(props.zIndex) ? props.zIndex : nextZIndex());
        const contentClass = computed$1(() => [
          ns.b(),
          ns.is("pure", props.pure),
          ns.is(props.effect),
          props.popperClass
        ]);
        const contentStyle = computed$1(() => {
          return [
            { zIndex: unref(contentZIndex) },
            unref(styles).popper,
            props.popperStyle || {}
          ];
        });
        const ariaModal = computed$1(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = computed$1(() => unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = isNumber(props.zIndex) ? props.zIndex : nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const usePopperContentFocusTrap = (props, emit) => {
        const trapped = ref(false);
        const focusStartRef = ref();
        const onFocusAfterTrapped = () => {
          emit("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a;
          if (((_a = event.detail) == null ? void 0 : _a.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const __default__$w = defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$W = /* @__PURE__ */ defineComponent({
        ...__default__$w,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props, emit);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props, {
            styles,
            attributes,
            role
          });
          const formItemContext = inject(formItemContextKey, void 0);
          const arrowOffset = ref();
          provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
            provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props.visible && props.focusOnShow) {
              trapped.value = true;
            } else if (props.visible === false) {
              trapped.value = false;
            }
          };
          onMounted(() => {
            watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = unref(triggerTargetEl || contentRef.value);
              const prevEl = unref(prevTriggerTargetEl || contentRef.value);
              if (isElement(el)) {
                triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            watch(() => props.visible, togglePopperAlive, { immediate: true });
          });
          onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, unref(contentAttrs), {
              style: unref(contentStyle),
              class: unref(contentClass),
              tabindex: "-1",
              onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
              onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
            }), [
              createVNode(unref(ElFocusTrap), {
                trapped: unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": unref(contentRef),
                "focus-start-el": unref(focusStartRef),
                onFocusAfterTrapped: unref(onFocusAfterTrapped),
                onFocusAfterReleased: unref(onFocusAfterReleased),
                onFocusin: unref(onFocusInTrap),
                onFocusoutPrevented: unref(onFocusoutPrevented),
                onReleaseRequested: unref(onReleaseRequested)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$W, [["__file", "content.vue"]]);
      const ElPopper = withInstall(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      const useTooltipContentProps = buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: definePropType([String, Object])
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: {
          type: Boolean,
          default: false
        },
        persistent: Boolean,
        ariaLabel: String,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean
      });
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.space]
        }
      });
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger, type4) => {
        if (isArray$1(trigger)) {
          return trigger.includes(type4);
        }
        return trigger === type4;
      };
      const whenTrigger = (trigger, type4, handler) => {
        return (e) => {
          isTriggerType(unref(trigger), type4) && handler(e);
        };
      };
      const __default__$v = defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$V = /* @__PURE__ */ defineComponent({
        ...__default__$v,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef = ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (unref(controlled) || props.disabled) {
              return true;
            }
          };
          const trigger = toRef(props, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "click", (e) => {
            if (e.button === 0) {
              onToggle(e);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "contextmenu", (e) => {
            e.preventDefault();
            onToggle(e);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
            const { code } = e;
            if (props.triggerKeys.includes(code)) {
              e.preventDefault();
              onToggle(e);
            }
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopperTrigger), {
              id: unref(id),
              "virtual-ref": _ctx.virtualRef,
              open: unref(open),
              "virtual-triggering": _ctx.virtualTriggering,
              class: normalizeClass(unref(ns).e("trigger")),
              onBlur: unref(onBlur),
              onClick: unref(onClick),
              onContextmenu: unref(onContextMenu),
              onFocus: unref(onFocus),
              onMouseenter: unref(onMouseenter),
              onMouseleave: unref(onMouseleave),
              onKeydown: unref(onKeydown)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["__file", "trigger.vue"]]);
      const __default__$u = defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$U = /* @__PURE__ */ defineComponent({
        ...__default__$u,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = ref(null);
          const destroyed = ref(false);
          const {
            controlled,
            id,
            open,
            trigger,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = computed$1(() => {
            return props.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = computed$1(() => {
            return props.persistent;
          });
          onBeforeUnmount(() => {
            destroyed.value = true;
          });
          const shouldRender = computed$1(() => {
            return unref(persistentRef) ? true : unref(open);
          });
          const shouldShow = computed$1(() => {
            return props.disabled ? false : unref(open);
          });
          const appendTo = computed$1(() => {
            return props.appendTo || selector.value;
          });
          const contentStyle = computed$1(() => {
            var _a;
            return (_a = props.style) != null ? _a : {};
          });
          const ariaHidden = computed$1(() => !unref(open));
          const onTransitionLeave = () => {
            onHide();
          };
          const stopWhenControlled = () => {
            if (unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props.enterable && unref(trigger) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (unref(trigger) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a, _b;
            (_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(computed$1(() => {
              var _a;
              return (_a = contentRef.value) == null ? void 0 : _a.popperContentRef;
            }), () => {
              if (unref(controlled))
                return;
              const $trigger = unref(trigger);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props.virtualTriggering) {
              onClose();
            }
          };
          let stopHandle;
          watch(() => unref(open), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            }
          }, {
            flush: "post"
          });
          watch(() => props.content, () => {
            var _a, _b;
            (_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
          });
          expose({
            contentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              disabled: !_ctx.teleported,
              to: unref(appendTo)
            }, [
              createVNode(Transition, {
                name: unref(transitionClass),
                onAfterLeave: onTransitionLeave,
                onBeforeEnter,
                onAfterEnter: onAfterShow,
                onBeforeLeave
              }, {
                default: withCtx(() => [
                  unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                    key: 0,
                    id: unref(id),
                    ref_key: "contentRef",
                    ref: contentRef
                  }, _ctx.$attrs, {
                    "aria-label": _ctx.ariaLabel,
                    "aria-hidden": unref(ariaHidden),
                    "boundaries-padding": _ctx.boundariesPadding,
                    "fallback-placements": _ctx.fallbackPlacements,
                    "gpu-acceleration": _ctx.gpuAcceleration,
                    offset: _ctx.offset,
                    placement: _ctx.placement,
                    "popper-options": _ctx.popperOptions,
                    strategy: _ctx.strategy,
                    effect: _ctx.effect,
                    enterable: _ctx.enterable,
                    pure: _ctx.pure,
                    "popper-class": _ctx.popperClass,
                    "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                    "reference-el": _ctx.referenceEl,
                    "trigger-target-el": _ctx.triggerTargetEl,
                    visible: unref(shouldShow),
                    "z-index": _ctx.zIndex,
                    onMouseenter: unref(onContentEnter),
                    onMouseleave: unref(onContentLeave),
                    onBlur,
                    onClose: unref(onClose)
                  }), {
                    default: withCtx(() => [
                      !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                    [vShow, unref(shouldShow)]
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["__file", "content.vue"]]);
      const _hoisted_1$D = ["innerHTML"];
      const _hoisted_2$t = { key: 1 };
      const __default__$t = defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$T = /* @__PURE__ */ defineComponent({
        ...__default__$t,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          usePopperContainer();
          const id = useId();
          const popperRef = ref();
          const contentRef = ref();
          const updatePopper = () => {
            var _a;
            const popperComponent = unref(popperRef);
            if (popperComponent) {
              (_a = popperComponent.popperInstanceRef) == null ? void 0 : _a.update();
            }
          };
          const open = ref(false);
          const toggleReason = ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef(props, "showAfter"),
            hideAfter: toRef(props, "hideAfter"),
            autoClose: toRef(props, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = computed$1(() => isBoolean(props.visible) && !hasUpdateHandler.value);
          provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id,
            open: readonly(open),
            trigger: toRef(props, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (unref(open)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit("show", toggleReason.value);
            },
            onHide: () => {
              emit("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit("before-hide", toggleReason.value);
            },
            updatePopper
          });
          watch(() => props.disabled, (disabled) => {
            if (disabled && open.value) {
              open.value = false;
            }
          });
          const isFocusInsideContent = (event) => {
            var _a, _b;
            const popperContent = (_b = (_a = contentRef.value) == null ? void 0 : _a.contentRef) == null ? void 0 : _b.popperContentRef;
            const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
            return popperContent && popperContent.contains(activeElement);
          };
          onDeactivated(() => open.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: withCtx(() => [
                createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": _ctx.popperClass,
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, _hoisted_1$D)) : (openBlock(), createElementBlock("span", _hoisted_2$t, toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["__file", "tooltip.vue"]]);
      const ElTooltip = withInstall(Tooltip);
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs(x2) {
        return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
      }
      var dayjs_min = { exports: {} };
      (function(module2, exports2) {
        !function(t, e) {
          module2.exports = e();
        }(commonjsGlobal, function() {
          var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
            var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
            return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
          } }, m2 = function(t2, e2, n2) {
            var r2 = String(t2);
            return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
          }, v2 = { s: m2, z: function(t2) {
            var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
            return (e2 <= 0 ? "+" : "-") + m2(r2, 2, "0") + ":" + m2(i2, 2, "0");
          }, m: function t2(e2, n2) {
            if (e2.date() < n2.date())
              return -t2(n2, e2);
            var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c2), s3 = n2 - i2 < 0, u3 = e2.clone().add(r2 + (s3 ? -1 : 1), c2);
            return +(-(r2 + (n2 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
          }, a: function(t2) {
            return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
          }, p: function(t2) {
            return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i, ms: r, Q: f2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
          }, u: function(t2) {
            return void 0 === t2;
          } }, g = "en", D2 = {};
          D2[g] = M2;
          var p2 = "$isDayjsObject", S2 = function(t2) {
            return t2 instanceof _2 || !(!t2 || !t2[p2]);
          }, w2 = function t2(e2, n2, r2) {
            var i2;
            if (!e2)
              return g;
            if ("string" == typeof e2) {
              var s3 = e2.toLowerCase();
              D2[s3] && (i2 = s3), n2 && (D2[s3] = n2, i2 = s3);
              var u3 = e2.split("-");
              if (!i2 && u3.length > 1)
                return t2(u3[0]);
            } else {
              var a3 = e2.name;
              D2[a3] = e2, i2 = a3;
            }
            return !r2 && i2 && (g = i2), i2 || !r2 && g;
          }, O2 = function(t2, e2) {
            if (S2(t2))
              return t2.clone();
            var n2 = "object" == typeof e2 ? e2 : {};
            return n2.date = t2, n2.args = arguments, new _2(n2);
          }, b2 = v2;
          b2.l = w2, b2.i = S2, b2.w = function(t2, e2) {
            return O2(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
          };
          var _2 = function() {
            function M3(t2) {
              this.$L = w2(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p2] = true;
            }
            var m3 = M3.prototype;
            return m3.parse = function(t2) {
              this.$d = function(t3) {
                var e2 = t3.date, n2 = t3.utc;
                if (null === e2)
                  return /* @__PURE__ */ new Date(NaN);
                if (b2.u(e2))
                  return /* @__PURE__ */ new Date();
                if (e2 instanceof Date)
                  return new Date(e2);
                if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                  var r2 = e2.match($);
                  if (r2) {
                    var i2 = r2[2] - 1 || 0, s3 = (r2[7] || "0").substring(0, 3);
                    return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3);
                  }
                }
                return new Date(e2);
              }(t2), this.init();
            }, m3.init = function() {
              var t2 = this.$d;
              this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
            }, m3.$utils = function() {
              return b2;
            }, m3.isValid = function() {
              return !(this.$d.toString() === l2);
            }, m3.isSame = function(t2, e2) {
              var n2 = O2(t2);
              return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
            }, m3.isAfter = function(t2, e2) {
              return O2(t2) < this.startOf(e2);
            }, m3.isBefore = function(t2, e2) {
              return this.endOf(e2) < O2(t2);
            }, m3.$g = function(t2, e2, n2) {
              return b2.u(t2) ? this[e2] : this.set(n2, t2);
            }, m3.unix = function() {
              return Math.floor(this.valueOf() / 1e3);
            }, m3.valueOf = function() {
              return this.$d.getTime();
            }, m3.startOf = function(t2, e2) {
              var n2 = this, r2 = !!b2.u(e2) || e2, f3 = b2.p(t2), l3 = function(t3, e3) {
                var i2 = b2.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
                return r2 ? i2 : i2.endOf(a2);
              }, $2 = function(t3, e3) {
                return b2.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
              }, y2 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
              switch (f3) {
                case h2:
                  return r2 ? l3(1, 0) : l3(31, 11);
                case c2:
                  return r2 ? l3(1, M4) : l3(0, M4 + 1);
                case o2:
                  var g2 = this.$locale().weekStart || 0, D3 = (y2 < g2 ? y2 + 7 : y2) - g2;
                  return l3(r2 ? m4 - D3 : m4 + (6 - D3), M4);
                case a2:
                case d2:
                  return $2(v3 + "Hours", 0);
                case u2:
                  return $2(v3 + "Minutes", 1);
                case s2:
                  return $2(v3 + "Seconds", 2);
                case i:
                  return $2(v3 + "Milliseconds", 3);
                default:
                  return this.clone();
              }
            }, m3.endOf = function(t2) {
              return this.startOf(t2, false);
            }, m3.$set = function(t2, e2) {
              var n2, o3 = b2.p(t2), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n2 = {}, n2[a2] = f3 + "Date", n2[d2] = f3 + "Date", n2[c2] = f3 + "Month", n2[h2] = f3 + "FullYear", n2[u2] = f3 + "Hours", n2[s2] = f3 + "Minutes", n2[i] = f3 + "Seconds", n2[r] = f3 + "Milliseconds", n2)[o3], $2 = o3 === a2 ? this.$D + (e2 - this.$W) : e2;
              if (o3 === c2 || o3 === h2) {
                var y2 = this.clone().set(d2, 1);
                y2.$d[l3]($2), y2.init(), this.$d = y2.set(d2, Math.min(this.$D, y2.daysInMonth())).$d;
              } else
                l3 && this.$d[l3]($2);
              return this.init(), this;
            }, m3.set = function(t2, e2) {
              return this.clone().$set(t2, e2);
            }, m3.get = function(t2) {
              return this[b2.p(t2)]();
            }, m3.add = function(r2, f3) {
              var d3, l3 = this;
              r2 = Number(r2);
              var $2 = b2.p(f3), y2 = function(t2) {
                var e2 = O2(l3);
                return b2.w(e2.date(e2.date() + Math.round(t2 * r2)), l3);
              };
              if ($2 === c2)
                return this.set(c2, this.$M + r2);
              if ($2 === h2)
                return this.set(h2, this.$y + r2);
              if ($2 === a2)
                return y2(1);
              if ($2 === o2)
                return y2(7);
              var M4 = (d3 = {}, d3[s2] = e, d3[u2] = n, d3[i] = t, d3)[$2] || 1, m4 = this.$d.getTime() + r2 * M4;
              return b2.w(m4, this);
            }, m3.subtract = function(t2, e2) {
              return this.add(-1 * t2, e2);
            }, m3.format = function(t2) {
              var e2 = this, n2 = this.$locale();
              if (!this.isValid())
                return n2.invalidDate || l2;
              var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n2.weekdays, c3 = n2.months, f3 = n2.meridiem, h3 = function(t3, n3, i3, s4) {
                return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s4);
              }, d3 = function(t3) {
                return b2.s(s3 % 12 || 12, t3, "0");
              }, $2 = f3 || function(t3, e3, n3) {
                var r3 = t3 < 12 ? "AM" : "PM";
                return n3 ? r3.toLowerCase() : r3;
              };
              return r2.replace(y, function(t3, r3) {
                return r3 || function(t4) {
                  switch (t4) {
                    case "YY":
                      return String(e2.$y).slice(-2);
                    case "YYYY":
                      return b2.s(e2.$y, 4, "0");
                    case "M":
                      return a3 + 1;
                    case "MM":
                      return b2.s(a3 + 1, 2, "0");
                    case "MMM":
                      return h3(n2.monthsShort, a3, c3, 3);
                    case "MMMM":
                      return h3(c3, a3);
                    case "D":
                      return e2.$D;
                    case "DD":
                      return b2.s(e2.$D, 2, "0");
                    case "d":
                      return String(e2.$W);
                    case "dd":
                      return h3(n2.weekdaysMin, e2.$W, o3, 2);
                    case "ddd":
                      return h3(n2.weekdaysShort, e2.$W, o3, 3);
                    case "dddd":
                      return o3[e2.$W];
                    case "H":
                      return String(s3);
                    case "HH":
                      return b2.s(s3, 2, "0");
                    case "h":
                      return d3(1);
                    case "hh":
                      return d3(2);
                    case "a":
                      return $2(s3, u3, true);
                    case "A":
                      return $2(s3, u3, false);
                    case "m":
                      return String(u3);
                    case "mm":
                      return b2.s(u3, 2, "0");
                    case "s":
                      return String(e2.$s);
                    case "ss":
                      return b2.s(e2.$s, 2, "0");
                    case "SSS":
                      return b2.s(e2.$ms, 3, "0");
                    case "Z":
                      return i2;
                  }
                  return null;
                }(t3) || i2.replace(":", "");
              });
            }, m3.utcOffset = function() {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }, m3.diff = function(r2, d3, l3) {
              var $2, y2 = this, M4 = b2.p(d3), m4 = O2(r2), v3 = (m4.utcOffset() - this.utcOffset()) * e, g2 = this - m4, D3 = function() {
                return b2.m(y2, m4);
              };
              switch (M4) {
                case h2:
                  $2 = D3() / 12;
                  break;
                case c2:
                  $2 = D3();
                  break;
                case f2:
                  $2 = D3() / 3;
                  break;
                case o2:
                  $2 = (g2 - v3) / 6048e5;
                  break;
                case a2:
                  $2 = (g2 - v3) / 864e5;
                  break;
                case u2:
                  $2 = g2 / n;
                  break;
                case s2:
                  $2 = g2 / e;
                  break;
                case i:
                  $2 = g2 / t;
                  break;
                default:
                  $2 = g2;
              }
              return l3 ? $2 : b2.a($2);
            }, m3.daysInMonth = function() {
              return this.endOf(c2).$D;
            }, m3.$locale = function() {
              return D2[this.$L];
            }, m3.locale = function(t2, e2) {
              if (!t2)
                return this.$L;
              var n2 = this.clone(), r2 = w2(t2, e2, true);
              return r2 && (n2.$L = r2), n2;
            }, m3.clone = function() {
              return b2.w(this.$d, this);
            }, m3.toDate = function() {
              return new Date(this.valueOf());
            }, m3.toJSON = function() {
              return this.isValid() ? this.toISOString() : null;
            }, m3.toISOString = function() {
              return this.$d.toISOString();
            }, m3.toString = function() {
              return this.$d.toUTCString();
            }, M3;
          }(), k = _2.prototype;
          return O2.prototype = k, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t2) {
            k[t2[1]] = function(e2) {
              return this.$g(e2, t2[0], t2[1]);
            };
          }), O2.extend = function(t2, e2) {
            return t2.$i || (t2(e2, _2, O2), t2.$i = true), O2;
          }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t2) {
            return O2(1e3 * t2);
          }, O2.en = D2[g], O2.Ls = D2, O2.p = {}, O2;
        });
      })(dayjs_min);
      var dayjs_minExports = dayjs_min.exports;
      const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
      var customParseFormat$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e, t) {
          module2.exports = t();
        }(commonjsGlobal, function() {
          var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o2 = {}, s2 = function(e2) {
            return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
          };
          var a2 = function(e2) {
            return function(t2) {
              this[e2] = +t2;
            };
          }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
            (this.zone || (this.zone = {})).offset = function(e3) {
              if (!e3)
                return 0;
              if ("Z" === e3)
                return 0;
              var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
              return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
            }(e2);
          }], h2 = function(e2) {
            var t2 = o2[e2];
            return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
          }, u2 = function(e2, t2) {
            var n2, r2 = o2.meridiem;
            if (r2) {
              for (var i2 = 1; i2 <= 24; i2 += 1)
                if (e2.indexOf(r2(i2, 0, t2)) > -1) {
                  n2 = i2 > 12;
                  break;
                }
            } else
              n2 = e2 === (t2 ? "pm" : "PM");
            return n2;
          }, d2 = { A: [i, function(e2) {
            this.afternoon = u2(e2, false);
          }], a: [i, function(e2) {
            this.afternoon = u2(e2, true);
          }], S: [/\d/, function(e2) {
            this.milliseconds = 100 * +e2;
          }], SS: [n, function(e2) {
            this.milliseconds = 10 * +e2;
          }], SSS: [/\d{3}/, function(e2) {
            this.milliseconds = +e2;
          }], s: [r, a2("seconds")], ss: [r, a2("seconds")], m: [r, a2("minutes")], mm: [r, a2("minutes")], H: [r, a2("hours")], h: [r, a2("hours")], HH: [r, a2("hours")], hh: [r, a2("hours")], D: [r, a2("day")], DD: [n, a2("day")], Do: [i, function(e2) {
            var t2 = o2.ordinal, n2 = e2.match(/\d+/);
            if (this.day = n2[0], t2)
              for (var r2 = 1; r2 <= 31; r2 += 1)
                t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
          }], M: [r, a2("month")], MM: [n, a2("month")], MMM: [i, function(e2) {
            var t2 = h2("months"), n2 = (h2("monthsShort") || t2.map(function(e3) {
              return e3.slice(0, 3);
            })).indexOf(e2) + 1;
            if (n2 < 1)
              throw new Error();
            this.month = n2 % 12 || n2;
          }], MMMM: [i, function(e2) {
            var t2 = h2("months").indexOf(e2) + 1;
            if (t2 < 1)
              throw new Error();
            this.month = t2 % 12 || t2;
          }], Y: [/[+-]?\d+/, a2("year")], YY: [n, function(e2) {
            this.year = s2(e2);
          }], YYYY: [/\d{4}/, a2("year")], Z: f2, ZZ: f2 };
          function c2(n2) {
            var r2, i2;
            r2 = n2, i2 = o2 && o2.formats;
            for (var s3 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
              var o3 = r3 && r3.toUpperCase();
              return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
                return t3 || n4.slice(1);
              });
            })).match(t), a3 = s3.length, f3 = 0; f3 < a3; f3 += 1) {
              var h3 = s3[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
              s3[f3] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
            }
            return function(e2) {
              for (var t2 = {}, n3 = 0, r3 = 0; n3 < a3; n3 += 1) {
                var i3 = s3[n3];
                if ("string" == typeof i3)
                  r3 += i3.length;
                else {
                  var o3 = i3.regex, f4 = i3.parser, h4 = e2.slice(r3), u4 = o3.exec(h4)[0];
                  f4.call(t2, u4), e2 = e2.replace(u4, "");
                }
              }
              return function(e3) {
                var t3 = e3.afternoon;
                if (void 0 !== t3) {
                  var n4 = e3.hours;
                  t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
                }
              }(t2), t2;
            };
          }
          return function(e2, t2, n2) {
            n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s2 = e2.parseTwoDigitYear);
            var r2 = t2.prototype, i2 = r2.parse;
            r2.parse = function(e3) {
              var t3 = e3.date, r3 = e3.utc, s3 = e3.args;
              this.$u = r3;
              var a3 = s3[1];
              if ("string" == typeof a3) {
                var f3 = true === s3[2], h3 = true === s3[3], u3 = f3 || h3, d3 = s3[2];
                h3 && (d3 = s3[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n2.Ls[d3]), this.$d = function(e4, t4, n3) {
                  try {
                    if (["x", "X"].indexOf(t4) > -1)
                      return new Date(("X" === t4 ? 1e3 : 1) * e4);
                    var r4 = c2(t4)(e4), i3 = r4.year, o3 = r4.month, s4 = r4.day, a4 = r4.hours, f4 = r4.minutes, h4 = r4.seconds, u4 = r4.milliseconds, d4 = r4.zone, l3 = /* @__PURE__ */ new Date(), m3 = s4 || (i3 || o3 ? 1 : l3.getDate()), M3 = i3 || l3.getFullYear(), Y2 = 0;
                    i3 && !o3 || (Y2 = o3 > 0 ? o3 - 1 : l3.getMonth());
                    var p2 = a4 || 0, v2 = f4 || 0, D2 = h4 || 0, g = u4 || 0;
                    return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g + 60 * d4.offset * 1e3)) : n3 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g)) : new Date(M3, Y2, m3, p2, v2, D2, g);
                  } catch (e5) {
                    return /* @__PURE__ */ new Date("");
                  }
                }(t3, a3, r3), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t3 != this.format(a3) && (this.$d = /* @__PURE__ */ new Date("")), o2 = {};
              } else if (a3 instanceof Array)
                for (var l2 = a3.length, m2 = 1; m2 <= l2; m2 += 1) {
                  s3[1] = a3[m2 - 1];
                  var M2 = n2.apply(this, s3);
                  if (M2.isValid()) {
                    this.$d = M2.$d, this.$L = M2.$L, this.init();
                    break;
                  }
                  m2 === l2 && (this.$d = /* @__PURE__ */ new Date(""));
                }
              else
                i2.call(this, e3);
            };
          };
        });
      })(customParseFormat$1);
      var customParseFormatExports = customParseFormat$1.exports;
      const customParseFormat = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
      const timeUnits = ["hours", "minutes", "seconds"];
      const DEFAULT_FORMATS_TIME = "HH:mm:ss";
      const buildTimeList = (value, bound) => {
        return [
          value > 0 ? value - 1 : void 0,
          value,
          value < bound ? value + 1 : void 0
        ];
      };
      const dateEquals = function(a2, b2) {
        const aIsDate = isDate(a2);
        const bIsDate = isDate(b2);
        if (aIsDate && bIsDate) {
          return a2.getTime() === b2.getTime();
        }
        if (!aIsDate && !bIsDate) {
          return a2 === b2;
        }
        return false;
      };
      const valueEquals = function(a2, b2) {
        const aIsArray = isArray$1(a2);
        const bIsArray = isArray$1(b2);
        if (aIsArray && bIsArray) {
          if (a2.length !== b2.length) {
            return false;
          }
          return a2.every((item, index) => dateEquals(item, b2[index]));
        }
        if (!aIsArray && !bIsArray) {
          return dateEquals(a2, b2);
        }
        return false;
      };
      const parseDate = function(date4, format2, lang) {
        const day = isEmpty(format2) || format2 === "x" ? dayjs(date4).locale(lang) : dayjs(date4, format2).locale(lang);
        return day.isValid() ? day : void 0;
      };
      const formatter = function(date4, format2, lang) {
        if (isEmpty(format2))
          return date4;
        if (format2 === "x")
          return +date4;
        return dayjs(date4).locale(lang).format(format2);
      };
      const makeList = (total, method4) => {
        var _a;
        const arr = [];
        const disabledArr = method4 == null ? void 0 : method4();
        for (let i = 0; i < total; i++) {
          arr.push((_a = disabledArr == null ? void 0 : disabledArr.includes(i)) != null ? _a : false);
        }
        return arr;
      };
      const disabledTimeListsProps = buildProps({
        disabledHours: {
          type: definePropType(Function)
        },
        disabledMinutes: {
          type: definePropType(Function)
        },
        disabledSeconds: {
          type: definePropType(Function)
        }
      });
      const timePanelSharedProps = buildProps({
        visible: Boolean,
        actualVisible: {
          type: Boolean,
          default: void 0
        },
        format: {
          type: String,
          default: ""
        }
      });
      const timePickerDefaultProps = buildProps({
        id: {
          type: definePropType([Array, String])
        },
        name: {
          type: definePropType([Array, String]),
          default: ""
        },
        popperClass: {
          type: String,
          default: ""
        },
        format: String,
        valueFormat: String,
        dateFormat: String,
        timeFormat: String,
        type: {
          type: String,
          default: ""
        },
        clearable: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: definePropType([String, Object]),
          default: circle_close_default
        },
        editable: {
          type: Boolean,
          default: true
        },
        prefixIcon: {
          type: definePropType([String, Object]),
          default: ""
        },
        size: useSizeProp,
        readonly: Boolean,
        disabled: Boolean,
        placeholder: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        modelValue: {
          type: definePropType([Date, Array, String, Number]),
          default: ""
        },
        rangeSeparator: {
          type: String,
          default: "-"
        },
        startPlaceholder: String,
        endPlaceholder: String,
        defaultValue: {
          type: definePropType([Date, Array])
        },
        defaultTime: {
          type: definePropType([Date, Array])
        },
        isRange: Boolean,
        ...disabledTimeListsProps,
        disabledDate: {
          type: Function
        },
        cellClassName: {
          type: Function
        },
        shortcuts: {
          type: Array,
          default: () => []
        },
        arrowControl: Boolean,
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: definePropType([String, Number]),
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        unlinkPanels: Boolean,
        ...useEmptyValuesProps
      });
      const _hoisted_1$C = ["id", "name", "placeholder", "value", "disabled", "readonly"];
      const _hoisted_2$s = ["id", "name", "placeholder", "value", "disabled", "readonly"];
      const __default__$s = defineComponent({
        name: "Picker"
      });
      const _sfc_main$S = /* @__PURE__ */ defineComponent({
        ...__default__$s,
        props: timePickerDefaultProps,
        emits: [
          "update:modelValue",
          "change",
          "focus",
          "blur",
          "calendar-change",
          "panel-change",
          "visible-change",
          "keydown"
        ],
        setup(__props, { expose, emit }) {
          const props = __props;
          const attrs = useAttrs$1();
          const { lang } = useLocale();
          const nsDate = useNamespace("date");
          const nsInput = useNamespace("input");
          const nsRange = useNamespace("range");
          const { form, formItem } = useFormItem();
          const elPopperOptions = inject("ElPopperOptions", {});
          const { valueOnClear } = useEmptyValues(props, null);
          const refPopper = ref();
          const inputRef = ref();
          const pickerVisible = ref(false);
          const pickerActualVisible = ref(false);
          const valueOnOpen = ref(null);
          let hasJustTabExitedInput = false;
          let ignoreFocusEvent = false;
          const rangeInputKls = computed$1(() => [
            nsDate.b("editor"),
            nsDate.bm("editor", props.type),
            nsInput.e("wrapper"),
            nsDate.is("disabled", pickerDisabled.value),
            nsDate.is("active", pickerVisible.value),
            nsRange.b("editor"),
            pickerSize ? nsRange.bm("editor", pickerSize.value) : "",
            attrs.class
          ]);
          const clearIconKls = computed$1(() => [
            nsInput.e("icon"),
            nsRange.e("close-icon"),
            !showClose.value ? nsRange.e("close-icon--hidden") : ""
          ]);
          watch(pickerVisible, (val) => {
            if (!val) {
              userInput.value = null;
              nextTick(() => {
                emitChange(props.modelValue);
              });
            } else {
              nextTick(() => {
                if (val) {
                  valueOnOpen.value = props.modelValue;
                }
              });
            }
          });
          const emitChange = (val, isClear) => {
            if (isClear || !valueEquals(val, valueOnOpen.value)) {
              emit("change", val);
              props.validateEvent && (formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn()));
            }
          };
          const emitInput = (input) => {
            if (!valueEquals(props.modelValue, input)) {
              let formatted;
              if (isArray$1(input)) {
                formatted = input.map((item) => formatter(item, props.valueFormat, lang.value));
              } else if (input) {
                formatted = formatter(input, props.valueFormat, lang.value);
              }
              emit("update:modelValue", input ? formatted : input, lang.value);
            }
          };
          const emitKeydown = (e) => {
            emit("keydown", e);
          };
          const refInput = computed$1(() => {
            if (inputRef.value) {
              const _r = isRangeInput.value ? inputRef.value : inputRef.value.$el;
              return Array.from(_r.querySelectorAll("input"));
            }
            return [];
          });
          const setSelectionRange = (start, end, pos) => {
            const _inputs = refInput.value;
            if (!_inputs.length)
              return;
            if (!pos || pos === "min") {
              _inputs[0].setSelectionRange(start, end);
              _inputs[0].focus();
            } else if (pos === "max") {
              _inputs[1].setSelectionRange(start, end);
              _inputs[1].focus();
            }
          };
          const focusOnInputBox = () => {
            focus(true, true);
            nextTick(() => {
              ignoreFocusEvent = false;
            });
          };
          const onPick = (date4 = "", visible = false) => {
            if (!visible) {
              ignoreFocusEvent = true;
            }
            pickerVisible.value = visible;
            let result;
            if (isArray$1(date4)) {
              result = date4.map((_2) => _2.toDate());
            } else {
              result = date4 ? date4.toDate() : date4;
            }
            userInput.value = null;
            emitInput(result);
          };
          const onBeforeShow = () => {
            pickerActualVisible.value = true;
          };
          const onShow = () => {
            emit("visible-change", true);
          };
          const onKeydownPopperContent = (event) => {
            if ((event == null ? void 0 : event.key) === EVENT_CODE.esc) {
              focus(true, true);
            }
          };
          const onHide = () => {
            pickerActualVisible.value = false;
            pickerVisible.value = false;
            ignoreFocusEvent = false;
            emit("visible-change", false);
          };
          const handleOpen = () => {
            pickerVisible.value = true;
          };
          const handleClose = () => {
            pickerVisible.value = false;
          };
          const focus = (focusStartInput = true, isIgnoreFocusEvent = false) => {
            ignoreFocusEvent = isIgnoreFocusEvent;
            const [leftInput, rightInput] = unref(refInput);
            let input = leftInput;
            if (!focusStartInput && isRangeInput.value) {
              input = rightInput;
            }
            if (input) {
              input.focus();
            }
          };
          const handleFocusInput = (e) => {
            if (props.readonly || pickerDisabled.value || pickerVisible.value || ignoreFocusEvent) {
              return;
            }
            pickerVisible.value = true;
            emit("focus", e);
          };
          let currentHandleBlurDeferCallback = void 0;
          const handleBlurInput = (e) => {
            const handleBlurDefer = async () => {
              setTimeout(() => {
                var _a;
                if (currentHandleBlurDeferCallback === handleBlurDefer) {
                  if (!(((_a = refPopper.value) == null ? void 0 : _a.isFocusInsideContent()) && !hasJustTabExitedInput) && refInput.value.filter((input) => {
                    return input.contains(document.activeElement);
                  }).length === 0) {
                    handleChange();
                    pickerVisible.value = false;
                    emit("blur", e);
                    props.validateEvent && (formItem == null ? void 0 : formItem.validate("blur").catch((err) => debugWarn()));
                  }
                  hasJustTabExitedInput = false;
                }
              }, 0);
            };
            currentHandleBlurDeferCallback = handleBlurDefer;
            handleBlurDefer();
          };
          const pickerDisabled = computed$1(() => {
            return props.disabled || (form == null ? void 0 : form.disabled);
          });
          const parsedValue = computed$1(() => {
            let dayOrDays;
            if (valueIsEmpty.value) {
              if (pickerOptions.value.getDefaultValue) {
                dayOrDays = pickerOptions.value.getDefaultValue();
              }
            } else {
              if (isArray$1(props.modelValue)) {
                dayOrDays = props.modelValue.map((d2) => parseDate(d2, props.valueFormat, lang.value));
              } else {
                dayOrDays = parseDate(props.modelValue, props.valueFormat, lang.value);
              }
            }
            if (pickerOptions.value.getRangeAvailableTime) {
              const availableResult = pickerOptions.value.getRangeAvailableTime(dayOrDays);
              if (!isEqual(availableResult, dayOrDays)) {
                dayOrDays = availableResult;
                emitInput(isArray$1(dayOrDays) ? dayOrDays.map((_2) => _2.toDate()) : dayOrDays.toDate());
              }
            }
            if (isArray$1(dayOrDays) && dayOrDays.some((day) => !day)) {
              dayOrDays = [];
            }
            return dayOrDays;
          });
          const displayValue = computed$1(() => {
            if (!pickerOptions.value.panelReady)
              return "";
            const formattedValue = formatDayjsToString(parsedValue.value);
            if (isArray$1(userInput.value)) {
              return [
                userInput.value[0] || formattedValue && formattedValue[0] || "",
                userInput.value[1] || formattedValue && formattedValue[1] || ""
              ];
            } else if (userInput.value !== null) {
              return userInput.value;
            }
            if (!isTimePicker.value && valueIsEmpty.value)
              return "";
            if (!pickerVisible.value && valueIsEmpty.value)
              return "";
            if (formattedValue) {
              return isDatesPicker.value || isYearsPicker.value ? formattedValue.join(", ") : formattedValue;
            }
            return "";
          });
          const isTimeLikePicker = computed$1(() => props.type.includes("time"));
          const isTimePicker = computed$1(() => props.type.startsWith("time"));
          const isDatesPicker = computed$1(() => props.type === "dates");
          const isYearsPicker = computed$1(() => props.type === "years");
          const triggerIcon = computed$1(() => props.prefixIcon || (isTimeLikePicker.value ? clock_default : calendar_default));
          const showClose = ref(false);
          const onClearIconClick = (event) => {
            if (props.readonly || pickerDisabled.value)
              return;
            if (showClose.value) {
              event.stopPropagation();
              focusOnInputBox();
              emitInput(valueOnClear.value);
              emitChange(valueOnClear.value, true);
              showClose.value = false;
              pickerVisible.value = false;
              pickerOptions.value.handleClear && pickerOptions.value.handleClear();
            }
          };
          const valueIsEmpty = computed$1(() => {
            const { modelValue } = props;
            return !modelValue || isArray$1(modelValue) && !modelValue.filter(Boolean).length;
          });
          const onMouseDownInput = async (event) => {
            var _a;
            if (props.readonly || pickerDisabled.value)
              return;
            if (((_a = event.target) == null ? void 0 : _a.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
              pickerVisible.value = true;
            }
          };
          const onMouseEnter = () => {
            if (props.readonly || pickerDisabled.value)
              return;
            if (!valueIsEmpty.value && props.clearable) {
              showClose.value = true;
            }
          };
          const onMouseLeave = () => {
            showClose.value = false;
          };
          const onTouchStartInput = (event) => {
            var _a;
            if (props.readonly || pickerDisabled.value)
              return;
            if (((_a = event.touches[0].target) == null ? void 0 : _a.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
              pickerVisible.value = true;
            }
          };
          const isRangeInput = computed$1(() => {
            return props.type.includes("range");
          });
          const pickerSize = useFormSize();
          const popperEl = computed$1(() => {
            var _a, _b;
            return (_b = (_a = unref(refPopper)) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
          });
          const actualInputRef = computed$1(() => {
            var _a;
            if (unref(isRangeInput)) {
              return unref(inputRef);
            }
            return (_a = unref(inputRef)) == null ? void 0 : _a.$el;
          });
          onClickOutside(actualInputRef, (e) => {
            const unrefedPopperEl = unref(popperEl);
            const inputEl = unref(actualInputRef);
            if (unrefedPopperEl && (e.target === unrefedPopperEl || e.composedPath().includes(unrefedPopperEl)) || e.target === inputEl || e.composedPath().includes(inputEl))
              return;
            pickerVisible.value = false;
          });
          const userInput = ref(null);
          const handleChange = () => {
            if (userInput.value) {
              const value = parseUserInputToDayjs(displayValue.value);
              if (value) {
                if (isValidValue(value)) {
                  emitInput(isArray$1(value) ? value.map((_2) => _2.toDate()) : value.toDate());
                  userInput.value = null;
                }
              }
            }
            if (userInput.value === "") {
              emitInput(valueOnClear.value);
              emitChange(valueOnClear.value);
              userInput.value = null;
            }
          };
          const parseUserInputToDayjs = (value) => {
            if (!value)
              return null;
            return pickerOptions.value.parseUserInput(value);
          };
          const formatDayjsToString = (value) => {
            if (!value)
              return null;
            return pickerOptions.value.formatToString(value);
          };
          const isValidValue = (value) => {
            return pickerOptions.value.isValidValue(value);
          };
          const handleKeydownInput = async (event) => {
            if (props.readonly || pickerDisabled.value)
              return;
            const { code } = event;
            emitKeydown(event);
            if (code === EVENT_CODE.esc) {
              if (pickerVisible.value === true) {
                pickerVisible.value = false;
                event.preventDefault();
                event.stopPropagation();
              }
              return;
            }
            if (code === EVENT_CODE.down) {
              if (pickerOptions.value.handleFocusPicker) {
                event.preventDefault();
                event.stopPropagation();
              }
              if (pickerVisible.value === false) {
                pickerVisible.value = true;
                await nextTick();
              }
              if (pickerOptions.value.handleFocusPicker) {
                pickerOptions.value.handleFocusPicker();
                return;
              }
            }
            if (code === EVENT_CODE.tab) {
              hasJustTabExitedInput = true;
              return;
            }
            if (code === EVENT_CODE.enter || code === EVENT_CODE.numpadEnter) {
              if (userInput.value === null || userInput.value === "" || isValidValue(parseUserInputToDayjs(displayValue.value))) {
                handleChange();
                pickerVisible.value = false;
              }
              event.stopPropagation();
              return;
            }
            if (userInput.value) {
              event.stopPropagation();
              return;
            }
            if (pickerOptions.value.handleKeydownInput) {
              pickerOptions.value.handleKeydownInput(event);
            }
          };
          const onUserInput = (e) => {
            userInput.value = e;
            if (!pickerVisible.value) {
              pickerVisible.value = true;
            }
          };
          const handleStartInput = (event) => {
            const target = event.target;
            if (userInput.value) {
              userInput.value = [target.value, userInput.value[1]];
            } else {
              userInput.value = [target.value, null];
            }
          };
          const handleEndInput = (event) => {
            const target = event.target;
            if (userInput.value) {
              userInput.value = [userInput.value[0], target.value];
            } else {
              userInput.value = [null, target.value];
            }
          };
          const handleStartChange = () => {
            var _a;
            const values = userInput.value;
            const value = parseUserInputToDayjs(values && values[0]);
            const parsedVal = unref(parsedValue);
            if (value && value.isValid()) {
              userInput.value = [
                formatDayjsToString(value),
                ((_a = displayValue.value) == null ? void 0 : _a[1]) || null
              ];
              const newValue = [value, parsedVal && (parsedVal[1] || null)];
              if (isValidValue(newValue)) {
                emitInput(newValue);
                userInput.value = null;
              }
            }
          };
          const handleEndChange = () => {
            var _a;
            const values = unref(userInput);
            const value = parseUserInputToDayjs(values && values[1]);
            const parsedVal = unref(parsedValue);
            if (value && value.isValid()) {
              userInput.value = [
                ((_a = unref(displayValue)) == null ? void 0 : _a[0]) || null,
                formatDayjsToString(value)
              ];
              const newValue = [parsedVal && parsedVal[0], value];
              if (isValidValue(newValue)) {
                emitInput(newValue);
                userInput.value = null;
              }
            }
          };
          const pickerOptions = ref({});
          const onSetPickerOption = (e) => {
            pickerOptions.value[e[0]] = e[1];
            pickerOptions.value.panelReady = true;
          };
          const onCalendarChange = (e) => {
            emit("calendar-change", e);
          };
          const onPanelChange = (value, mode, view) => {
            emit("panel-change", value, mode, view);
          };
          provide("EP_PICKER_BASE", {
            props
          });
          expose({
            focus,
            handleFocusInput,
            handleBlurInput,
            handleOpen,
            handleClose,
            onPick
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), mergeProps({
              ref_key: "refPopper",
              ref: refPopper,
              visible: pickerVisible.value,
              effect: "light",
              pure: "",
              trigger: "click"
            }, _ctx.$attrs, {
              role: "dialog",
              teleported: "",
              transition: `${unref(nsDate).namespace.value}-zoom-in-top`,
              "popper-class": [`${unref(nsDate).namespace.value}-picker__popper`, _ctx.popperClass],
              "popper-options": unref(elPopperOptions),
              "fallback-placements": ["bottom", "top", "right", "left"],
              "gpu-acceleration": false,
              "stop-popper-mouse-event": false,
              "hide-after": 0,
              persistent: "",
              onBeforeShow,
              onShow,
              onHide
            }), {
              default: withCtx(() => [
                !unref(isRangeInput) ? (openBlock(), createBlock(unref(ElInput), {
                  key: 0,
                  id: _ctx.id,
                  ref_key: "inputRef",
                  ref: inputRef,
                  "container-role": "combobox",
                  "model-value": unref(displayValue),
                  name: _ctx.name,
                  size: unref(pickerSize),
                  disabled: unref(pickerDisabled),
                  placeholder: _ctx.placeholder,
                  class: normalizeClass([unref(nsDate).b("editor"), unref(nsDate).bm("editor", _ctx.type), _ctx.$attrs.class]),
                  style: normalizeStyle(_ctx.$attrs.style),
                  readonly: !_ctx.editable || _ctx.readonly || unref(isDatesPicker) || unref(isYearsPicker) || _ctx.type === "week",
                  label: _ctx.label,
                  tabindex: _ctx.tabindex,
                  "validate-event": false,
                  onInput: onUserInput,
                  onFocus: handleFocusInput,
                  onBlur: handleBlurInput,
                  onKeydown: handleKeydownInput,
                  onChange: handleChange,
                  onMousedown: onMouseDownInput,
                  onMouseenter: onMouseEnter,
                  onMouseleave: onMouseLeave,
                  onTouchstart: onTouchStartInput,
                  onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["stop"]))
                }, {
                  prefix: withCtx(() => [
                    unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(nsInput).e("icon")),
                      onMousedown: withModifiers(onMouseDownInput, ["prevent"]),
                      onTouchstart: onTouchStartInput
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true)
                  ]),
                  suffix: withCtx(() => [
                    showClose.value && _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(`${unref(nsInput).e("icon")} clear-icon`),
                      onClick: withModifiers(onClearIconClick, ["stop"])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 1
                }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onKeydown"])) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  ref_key: "inputRef",
                  ref: inputRef,
                  class: normalizeClass(unref(rangeInputKls)),
                  style: normalizeStyle(_ctx.$attrs.style),
                  onClick: handleFocusInput,
                  onMouseenter: onMouseEnter,
                  onMouseleave: onMouseLeave,
                  onTouchstart: onTouchStartInput,
                  onKeydown: handleKeydownInput
                }, [
                  unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(nsInput).e("icon"), unref(nsRange).e("icon")]),
                    onMousedown: withModifiers(onMouseDownInput, ["prevent"]),
                    onTouchstart: onTouchStartInput
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                    ]),
                    _: 1
                  }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                  createElementVNode("input", {
                    id: _ctx.id && _ctx.id[0],
                    autocomplete: "off",
                    name: _ctx.name && _ctx.name[0],
                    placeholder: _ctx.startPlaceholder,
                    value: unref(displayValue) && unref(displayValue)[0],
                    disabled: unref(pickerDisabled),
                    readonly: !_ctx.editable || _ctx.readonly,
                    class: normalizeClass(unref(nsRange).b("input")),
                    onMousedown: onMouseDownInput,
                    onInput: handleStartInput,
                    onChange: handleStartChange,
                    onFocus: handleFocusInput,
                    onBlur: handleBlurInput
                  }, null, 42, _hoisted_1$C),
                  renderSlot(_ctx.$slots, "range-separator", {}, () => [
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsRange).b("separator"))
                    }, toDisplayString(_ctx.rangeSeparator), 3)
                  ]),
                  createElementVNode("input", {
                    id: _ctx.id && _ctx.id[1],
                    autocomplete: "off",
                    name: _ctx.name && _ctx.name[1],
                    placeholder: _ctx.endPlaceholder,
                    value: unref(displayValue) && unref(displayValue)[1],
                    disabled: unref(pickerDisabled),
                    readonly: !_ctx.editable || _ctx.readonly,
                    class: normalizeClass(unref(nsRange).b("input")),
                    onMousedown: onMouseDownInput,
                    onFocus: handleFocusInput,
                    onBlur: handleBlurInput,
                    onInput: handleEndInput,
                    onChange: handleEndChange
                  }, null, 42, _hoisted_2$s),
                  _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(clearIconKls)),
                    onClick: onClearIconClick
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 38))
              ]),
              content: withCtx(() => [
                renderSlot(_ctx.$slots, "default", {
                  visible: pickerVisible.value,
                  actualVisible: pickerActualVisible.value,
                  parsedValue: unref(parsedValue),
                  format: _ctx.format,
                  dateFormat: _ctx.dateFormat,
                  timeFormat: _ctx.timeFormat,
                  unlinkPanels: _ctx.unlinkPanels,
                  type: _ctx.type,
                  defaultValue: _ctx.defaultValue,
                  onPick,
                  onSelectRange: setSelectionRange,
                  onSetPickerOption,
                  onCalendarChange,
                  onPanelChange,
                  onKeydown: onKeydownPopperContent,
                  onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["stop"]))
                })
              ]),
              _: 3
            }, 16, ["visible", "transition", "popper-class", "popper-options"]);
          };
        }
      });
      var CommonPicker = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["__file", "picker.vue"]]);
      const panelTimePickerProps = buildProps({
        ...timePanelSharedProps,
        datetimeRole: String,
        parsedValue: {
          type: definePropType(Object)
        }
      });
      const useTimePanel = ({
        getAvailableHours,
        getAvailableMinutes,
        getAvailableSeconds
      }) => {
        const getAvailableTime = (date4, role, first, compareDate) => {
          const availableTimeGetters = {
            hour: getAvailableHours,
            minute: getAvailableMinutes,
            second: getAvailableSeconds
          };
          let result = date4;
          ["hour", "minute", "second"].forEach((type4) => {
            if (availableTimeGetters[type4]) {
              let availableTimeSlots;
              const method4 = availableTimeGetters[type4];
              switch (type4) {
                case "minute": {
                  availableTimeSlots = method4(result.hour(), role, compareDate);
                  break;
                }
                case "second": {
                  availableTimeSlots = method4(result.hour(), result.minute(), role, compareDate);
                  break;
                }
                default: {
                  availableTimeSlots = method4(role, compareDate);
                  break;
                }
              }
              if ((availableTimeSlots == null ? void 0 : availableTimeSlots.length) && !availableTimeSlots.includes(result[type4]())) {
                const pos = first ? 0 : availableTimeSlots.length - 1;
                result = result[type4](availableTimeSlots[pos]);
              }
            }
          });
          return result;
        };
        const timePickerOptions = {};
        const onSetOption = ([key, val]) => {
          timePickerOptions[key] = val;
        };
        return {
          timePickerOptions,
          getAvailableTime,
          onSetOption
        };
      };
      const makeAvailableArr = (disabledList) => {
        const trueOrNumber = (isDisabled, index) => isDisabled || index;
        const getNumber = (predicate) => predicate !== true;
        return disabledList.map(trueOrNumber).filter(getNumber);
      };
      const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
        const getHoursList = (role, compare) => {
          return makeList(24, disabledHours && (() => disabledHours == null ? void 0 : disabledHours(role, compare)));
        };
        const getMinutesList = (hour, role, compare) => {
          return makeList(60, disabledMinutes && (() => disabledMinutes == null ? void 0 : disabledMinutes(hour, role, compare)));
        };
        const getSecondsList = (hour, minute, role, compare) => {
          return makeList(60, disabledSeconds && (() => disabledSeconds == null ? void 0 : disabledSeconds(hour, minute, role, compare)));
        };
        return {
          getHoursList,
          getMinutesList,
          getSecondsList
        };
      };
      const buildAvailableTimeSlotGetter = (disabledHours, disabledMinutes, disabledSeconds) => {
        const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
        const getAvailableHours = (role, compare) => {
          return makeAvailableArr(getHoursList(role, compare));
        };
        const getAvailableMinutes = (hour, role, compare) => {
          return makeAvailableArr(getMinutesList(hour, role, compare));
        };
        const getAvailableSeconds = (hour, minute, role, compare) => {
          return makeAvailableArr(getSecondsList(hour, minute, role, compare));
        };
        return {
          getAvailableHours,
          getAvailableMinutes,
          getAvailableSeconds
        };
      };
      const useOldValue = (props) => {
        const oldValue = ref(props.parsedValue);
        watch(() => props.visible, (val) => {
          if (!val) {
            oldValue.value = props.parsedValue;
          }
        });
        return oldValue;
      };
      const nodeList = /* @__PURE__ */ new Map();
      let startClick;
      if (isClient) {
        document.addEventListener("mousedown", (e) => startClick = e);
        document.addEventListener("mouseup", (e) => {
          for (const handlers of nodeList.values()) {
            for (const { documentHandler } of handlers) {
              documentHandler(e, startClick);
            }
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (Array.isArray(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      };
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction$1(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$1(value) ? value() : value.handler();
          const clear = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear();
            handler();
            document.addEventListener("mouseup", () => clear(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay);
          });
        }
      };
      var v = false, o, f, s, u, d, N, l, p, m, w, D, x, E, M, F;
      function a() {
        if (!v) {
          v = true;
          var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
          if (x = /\b(iPhone|iP[ao]d)/.exec(e), E = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), M = /FBAN\/\w+;/i.exec(e), F = /Mobile/i.exec(e), D = !!/Win64/.exec(e), n) {
            o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
            var r = /(?:Trident\/(\d+.\d+))/.exec(e);
            N = r ? parseFloat(r[1]) + 4 : o, f = n[2] ? parseFloat(n[2]) : NaN, s = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
          } else
            o = f = s = d = u = NaN;
          if (i) {
            if (i[1]) {
              var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
              l = t ? parseFloat(t[1].replace("_", ".")) : true;
            } else
              l = false;
            p = !!i[2], m = !!i[3];
          } else
            l = p = m = false;
        }
      }
      var _ = { ie: function() {
        return a() || o;
      }, ieCompatibilityMode: function() {
        return a() || N > o;
      }, ie64: function() {
        return _.ie() && D;
      }, firefox: function() {
        return a() || f;
      }, opera: function() {
        return a() || s;
      }, webkit: function() {
        return a() || u;
      }, safari: function() {
        return _.webkit();
      }, chrome: function() {
        return a() || d;
      }, windows: function() {
        return a() || p;
      }, osx: function() {
        return a() || l;
      }, linux: function() {
        return a() || m;
      }, iphone: function() {
        return a() || x;
      }, mobile: function() {
        return a() || x || E || w || F;
      }, nativeApp: function() {
        return a() || M;
      }, android: function() {
        return a() || w;
      }, ipad: function() {
        return a() || E;
      } }, A = _;
      var c = !!(typeof window < "u" && window.document && window.document.createElement), U = { canUseDOM: c, canUseWorkers: typeof Worker < "u", canUseEventListeners: c && !!(window.addEventListener || window.attachEvent), canUseViewport: c && !!window.screen, isInWorker: !c }, h = U;
      var X;
      h.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
      function S(e, n) {
        if (!h.canUseDOM || n && !("addEventListener" in document))
          return false;
        var i = "on" + e, r = i in document;
        if (!r) {
          var t = document.createElement("div");
          t.setAttribute(i, "return;"), r = typeof t[i] == "function";
        }
        return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
      }
      var b = S;
      var O = 10, I = 40, P = 800;
      function T(e) {
        var n = 0, i = 0, r = 0, t = 0;
        return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= I, t *= I) : (r *= P, t *= P)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
      }
      T.getEventType = function() {
        return A.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
      };
      var Y = T;
      /**
      * Checks if an event is supported in the current execution environment.
      *
      * NOTE: This will not work correctly for non-generic events such as `change`,
      * `reset`, `load`, `error`, and `select`.
      *
      * Borrows from Modernizr.
      *
      * @param {string} eventNameSuffix Event name, e.g. "click".
      * @param {?boolean} capture Check if the capture phase is supported.
      * @return {boolean} True if the event is supported.
      * @internal
      * @license Modernizr 3.0.0pre (Custom Build) | MIT
      */
      const mousewheel = function(element, callback) {
        if (element && element.addEventListener) {
          const fn2 = function(event) {
            const normalized = Y(event);
            callback && Reflect.apply(callback, this, [event, normalized]);
          };
          element.addEventListener("wheel", fn2, { passive: true });
        }
      };
      const Mousewheel = {
        beforeMount(el, binding) {
          mousewheel(el, binding.value);
        }
      };
      const basicTimeSpinnerProps = buildProps({
        role: {
          type: String,
          required: true
        },
        spinnerDate: {
          type: definePropType(Object),
          required: true
        },
        showSeconds: {
          type: Boolean,
          default: true
        },
        arrowControl: Boolean,
        amPmMode: {
          type: definePropType(String),
          default: ""
        },
        ...disabledTimeListsProps
      });
      const _hoisted_1$B = ["onClick"];
      const _hoisted_2$r = ["onMouseenter"];
      const _sfc_main$R = /* @__PURE__ */ defineComponent({
        __name: "basic-time-spinner",
        props: basicTimeSpinnerProps,
        emits: ["change", "select-range", "set-option"],
        setup(__props, { emit }) {
          const props = __props;
          const ns = useNamespace("time");
          const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(props.disabledHours, props.disabledMinutes, props.disabledSeconds);
          let isScrolling = false;
          const currentScrollbar = ref();
          const listHoursRef = ref();
          const listMinutesRef = ref();
          const listSecondsRef = ref();
          const listRefsMap = {
            hours: listHoursRef,
            minutes: listMinutesRef,
            seconds: listSecondsRef
          };
          const spinnerItems = computed$1(() => {
            return props.showSeconds ? timeUnits : timeUnits.slice(0, 2);
          });
          const timePartials = computed$1(() => {
            const { spinnerDate } = props;
            const hours = spinnerDate.hour();
            const minutes = spinnerDate.minute();
            const seconds = spinnerDate.second();
            return { hours, minutes, seconds };
          });
          const timeList = computed$1(() => {
            const { hours, minutes } = unref(timePartials);
            return {
              hours: getHoursList(props.role),
              minutes: getMinutesList(hours, props.role),
              seconds: getSecondsList(hours, minutes, props.role)
            };
          });
          const arrowControlTimeList = computed$1(() => {
            const { hours, minutes, seconds } = unref(timePartials);
            return {
              hours: buildTimeList(hours, 23),
              minutes: buildTimeList(minutes, 59),
              seconds: buildTimeList(seconds, 59)
            };
          });
          const debouncedResetScroll = debounce((type4) => {
            isScrolling = false;
            adjustCurrentSpinner(type4);
          }, 200);
          const getAmPmFlag = (hour) => {
            const shouldShowAmPm = !!props.amPmMode;
            if (!shouldShowAmPm)
              return "";
            const isCapital = props.amPmMode === "A";
            let content = hour < 12 ? " am" : " pm";
            if (isCapital)
              content = content.toUpperCase();
            return content;
          };
          const emitSelectRange = (type4) => {
            let range3;
            switch (type4) {
              case "hours":
                range3 = [0, 2];
                break;
              case "minutes":
                range3 = [3, 5];
                break;
              case "seconds":
                range3 = [6, 8];
                break;
            }
            const [left, right] = range3;
            emit("select-range", left, right);
            currentScrollbar.value = type4;
          };
          const adjustCurrentSpinner = (type4) => {
            adjustSpinner(type4, unref(timePartials)[type4]);
          };
          const adjustSpinners = () => {
            adjustCurrentSpinner("hours");
            adjustCurrentSpinner("minutes");
            adjustCurrentSpinner("seconds");
          };
          const getScrollbarElement = (el) => el.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);
          const adjustSpinner = (type4, value) => {
            if (props.arrowControl)
              return;
            const scrollbar = unref(listRefsMap[type4]);
            if (scrollbar && scrollbar.$el) {
              getScrollbarElement(scrollbar.$el).scrollTop = Math.max(0, value * typeItemHeight(type4));
            }
          };
          const typeItemHeight = (type4) => {
            const scrollbar = unref(listRefsMap[type4]);
            const listItem = scrollbar == null ? void 0 : scrollbar.$el.querySelector("li");
            if (listItem) {
              return Number.parseFloat(getStyle(listItem, "height")) || 0;
            }
            return 0;
          };
          const onIncrement = () => {
            scrollDown(1);
          };
          const onDecrement = () => {
            scrollDown(-1);
          };
          const scrollDown = (step) => {
            if (!currentScrollbar.value) {
              emitSelectRange("hours");
            }
            const label = currentScrollbar.value;
            const now2 = unref(timePartials)[label];
            const total = currentScrollbar.value === "hours" ? 24 : 60;
            const next = findNextUnDisabled(label, now2, step, total);
            modifyDateField(label, next);
            adjustSpinner(label, next);
            nextTick(() => emitSelectRange(label));
          };
          const findNextUnDisabled = (type4, now2, step, total) => {
            let next = (now2 + step + total) % total;
            const list = unref(timeList)[type4];
            while (list[next] && next !== now2) {
              next = (next + step + total) % total;
            }
            return next;
          };
          const modifyDateField = (type4, value) => {
            const list = unref(timeList)[type4];
            const isDisabled = list[value];
            if (isDisabled)
              return;
            const { hours, minutes, seconds } = unref(timePartials);
            let changeTo;
            switch (type4) {
              case "hours":
                changeTo = props.spinnerDate.hour(value).minute(minutes).second(seconds);
                break;
              case "minutes":
                changeTo = props.spinnerDate.hour(hours).minute(value).second(seconds);
                break;
              case "seconds":
                changeTo = props.spinnerDate.hour(hours).minute(minutes).second(value);
                break;
            }
            emit("change", changeTo);
          };
          const handleClick = (type4, { value, disabled }) => {
            if (!disabled) {
              modifyDateField(type4, value);
              emitSelectRange(type4);
              adjustSpinner(type4, value);
            }
          };
          const handleScroll = (type4) => {
            isScrolling = true;
            debouncedResetScroll(type4);
            const value = Math.min(Math.round((getScrollbarElement(unref(listRefsMap[type4]).$el).scrollTop - (scrollBarHeight(type4) * 0.5 - 10) / typeItemHeight(type4) + 3) / typeItemHeight(type4)), type4 === "hours" ? 23 : 59);
            modifyDateField(type4, value);
          };
          const scrollBarHeight = (type4) => {
            return unref(listRefsMap[type4]).$el.offsetHeight;
          };
          const bindScrollEvent = () => {
            const bindFunction = (type4) => {
              const scrollbar = unref(listRefsMap[type4]);
              if (scrollbar && scrollbar.$el) {
                getScrollbarElement(scrollbar.$el).onscroll = () => {
                  handleScroll(type4);
                };
              }
            };
            bindFunction("hours");
            bindFunction("minutes");
            bindFunction("seconds");
          };
          onMounted(() => {
            nextTick(() => {
              !props.arrowControl && bindScrollEvent();
              adjustSpinners();
              if (props.role === "start")
                emitSelectRange("hours");
            });
          });
          const setRef = (scrollbar, type4) => {
            listRefsMap[type4].value = scrollbar;
          };
          emit("set-option", [`${props.role}_scrollDown`, scrollDown]);
          emit("set-option", [`${props.role}_emitSelectRange`, emitSelectRange]);
          watch(() => props.spinnerDate, () => {
            if (isScrolling)
              return;
            adjustSpinners();
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b("spinner"), { "has-seconds": _ctx.showSeconds }])
            }, [
              !_ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(spinnerItems), (item) => {
                return openBlock(), createBlock(unref(ElScrollbar), {
                  key: item,
                  ref_for: true,
                  ref: (scrollbar) => setRef(scrollbar, item),
                  class: normalizeClass(unref(ns).be("spinner", "wrapper")),
                  "wrap-style": "max-height: inherit;",
                  "view-class": unref(ns).be("spinner", "list"),
                  noresize: "",
                  tag: "ul",
                  onMouseenter: ($event) => emitSelectRange(item),
                  onMousemove: ($event) => adjustCurrentSpinner(item)
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(timeList)[item], (disabled, key) => {
                      return openBlock(), createElementBlock("li", {
                        key,
                        class: normalizeClass([
                          unref(ns).be("spinner", "item"),
                          unref(ns).is("active", key === unref(timePartials)[item]),
                          unref(ns).is("disabled", disabled)
                        ]),
                        onClick: ($event) => handleClick(item, { value: key, disabled })
                      }, [
                        item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? key % 12 || 12 : key)).slice(-2)) + toDisplayString(getAmPmFlag(key)), 1)
                        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createTextVNode(toDisplayString(("0" + key).slice(-2)), 1)
                        ], 64))
                      ], 10, _hoisted_1$B);
                    }), 128))
                  ]),
                  _: 2
                }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]);
              }), 128)) : createCommentVNode("v-if", true),
              _ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(spinnerItems), (item) => {
                return openBlock(), createElementBlock("div", {
                  key: item,
                  class: normalizeClass([unref(ns).be("spinner", "wrapper"), unref(ns).is("arrow")]),
                  onMouseenter: ($event) => emitSelectRange(item)
                }, [
                  withDirectives((openBlock(), createBlock(unref(ElIcon), {
                    class: normalizeClass(["arrow-up", unref(ns).be("spinner", "arrow")])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_up_default))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [unref(vRepeatClick), onDecrement]
                  ]),
                  withDirectives((openBlock(), createBlock(unref(ElIcon), {
                    class: normalizeClass(["arrow-down", unref(ns).be("spinner", "arrow")])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_down_default))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [unref(vRepeatClick), onIncrement]
                  ]),
                  createElementVNode("ul", {
                    class: normalizeClass(unref(ns).be("spinner", "list"))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(arrowControlTimeList)[item], (time, key) => {
                      return openBlock(), createElementBlock("li", {
                        key,
                        class: normalizeClass([
                          unref(ns).be("spinner", "item"),
                          unref(ns).is("active", time === unref(timePartials)[item]),
                          unref(ns).is("disabled", unref(timeList)[item][time])
                        ])
                      }, [
                        typeof time === "number" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2)) + toDisplayString(getAmPmFlag(time)), 1)
                          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            createTextVNode(toDisplayString(("0" + time).slice(-2)), 1)
                          ], 64))
                        ], 64)) : createCommentVNode("v-if", true)
                      ], 2);
                    }), 128))
                  ], 2)
                ], 42, _hoisted_2$r);
              }), 128)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var TimeSpinner = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["__file", "basic-time-spinner.vue"]]);
      const _sfc_main$Q = /* @__PURE__ */ defineComponent({
        __name: "panel-time-pick",
        props: panelTimePickerProps,
        emits: ["pick", "select-range", "set-picker-option"],
        setup(__props, { emit }) {
          const props = __props;
          const pickerBase = inject("EP_PICKER_BASE");
          const {
            arrowControl,
            disabledHours,
            disabledMinutes,
            disabledSeconds,
            defaultValue
          } = pickerBase.props;
          const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours, disabledMinutes, disabledSeconds);
          const ns = useNamespace("time");
          const { t, lang } = useLocale();
          const selectionRange = ref([0, 2]);
          const oldValue = useOldValue(props);
          const transitionName = computed$1(() => {
            return isUndefined$1(props.actualVisible) ? `${ns.namespace.value}-zoom-in-top` : "";
          });
          const showSeconds = computed$1(() => {
            return props.format.includes("ss");
          });
          const amPmMode = computed$1(() => {
            if (props.format.includes("A"))
              return "A";
            if (props.format.includes("a"))
              return "a";
            return "";
          });
          const isValidValue = (_date) => {
            const parsedDate = dayjs(_date).locale(lang.value);
            const result = getRangeAvailableTime(parsedDate);
            return parsedDate.isSame(result);
          };
          const handleCancel = () => {
            emit("pick", oldValue.value, false);
          };
          const handleConfirm = (visible = false, first = false) => {
            if (first)
              return;
            emit("pick", props.parsedValue, visible);
          };
          const handleChange = (_date) => {
            if (!props.visible) {
              return;
            }
            const result = getRangeAvailableTime(_date).millisecond(0);
            emit("pick", result, true);
          };
          const setSelectionRange = (start, end) => {
            emit("select-range", start, end);
            selectionRange.value = [start, end];
          };
          const changeSelectionRange = (step) => {
            const list = [0, 3].concat(showSeconds.value ? [6] : []);
            const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
            const index = list.indexOf(selectionRange.value[0]);
            const next = (index + step + list.length) % list.length;
            timePickerOptions["start_emitSelectRange"](mapping[next]);
          };
          const handleKeydown = (event) => {
            const code = event.code;
            const { left, right, up, down } = EVENT_CODE;
            if ([left, right].includes(code)) {
              const step = code === left ? -1 : 1;
              changeSelectionRange(step);
              event.preventDefault();
              return;
            }
            if ([up, down].includes(code)) {
              const step = code === up ? -1 : 1;
              timePickerOptions["start_scrollDown"](step);
              event.preventDefault();
              return;
            }
          };
          const { timePickerOptions, onSetOption, getAvailableTime } = useTimePanel({
            getAvailableHours,
            getAvailableMinutes,
            getAvailableSeconds
          });
          const getRangeAvailableTime = (date4) => {
            return getAvailableTime(date4, props.datetimeRole || "", true);
          };
          const parseUserInput = (value) => {
            if (!value)
              return null;
            return dayjs(value, props.format).locale(lang.value);
          };
          const formatToString = (value) => {
            if (!value)
              return null;
            return value.format(props.format);
          };
          const getDefaultValue = () => {
            return dayjs(defaultValue).locale(lang.value);
          };
          emit("set-picker-option", ["isValidValue", isValidValue]);
          emit("set-picker-option", ["formatToString", formatToString]);
          emit("set-picker-option", ["parseUserInput", parseUserInput]);
          emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
          emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
          emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, { name: unref(transitionName) }, {
              default: withCtx(() => [
                _ctx.actualVisible || _ctx.visible ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).b("panel"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass([unref(ns).be("panel", "content"), { "has-seconds": unref(showSeconds) }])
                  }, [
                    createVNode(TimeSpinner, {
                      ref: "spinner",
                      role: _ctx.datetimeRole || "start",
                      "arrow-control": unref(arrowControl),
                      "show-seconds": unref(showSeconds),
                      "am-pm-mode": unref(amPmMode),
                      "spinner-date": _ctx.parsedValue,
                      "disabled-hours": unref(disabledHours),
                      "disabled-minutes": unref(disabledMinutes),
                      "disabled-seconds": unref(disabledSeconds),
                      onChange: handleChange,
                      onSetOption: unref(onSetOption),
                      onSelectRange: setSelectionRange
                    }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
                  ], 2),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).be("panel", "footer"))
                  }, [
                    createElementVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ns).be("panel", "btn"), "cancel"]),
                      onClick: handleCancel
                    }, toDisplayString(unref(t)("el.datepicker.cancel")), 3),
                    createElementVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ns).be("panel", "btn"), "confirm"]),
                      onClick: _cache[0] || (_cache[0] = ($event) => handleConfirm())
                    }, toDisplayString(unref(t)("el.datepicker.confirm")), 3)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var TimePickPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["__file", "panel-time-pick.vue"]]);
      const panelTimeRangeProps = buildProps({
        ...timePanelSharedProps,
        parsedValue: {
          type: definePropType(Array)
        }
      });
      const _hoisted_1$A = ["disabled"];
      const _sfc_main$P = /* @__PURE__ */ defineComponent({
        __name: "panel-time-range",
        props: panelTimeRangeProps,
        emits: ["pick", "select-range", "set-picker-option"],
        setup(__props, { emit }) {
          const props = __props;
          const makeSelectRange = (start, end) => {
            const result = [];
            for (let i = start; i <= end; i++) {
              result.push(i);
            }
            return result;
          };
          const { t, lang } = useLocale();
          const nsTime = useNamespace("time");
          const nsPicker = useNamespace("picker");
          const pickerBase = inject("EP_PICKER_BASE");
          const {
            arrowControl,
            disabledHours,
            disabledMinutes,
            disabledSeconds,
            defaultValue
          } = pickerBase.props;
          const startContainerKls = computed$1(() => [
            nsTime.be("range-picker", "body"),
            nsTime.be("panel", "content"),
            nsTime.is("arrow", arrowControl),
            showSeconds.value ? "has-seconds" : ""
          ]);
          const endContainerKls = computed$1(() => [
            nsTime.be("range-picker", "body"),
            nsTime.be("panel", "content"),
            nsTime.is("arrow", arrowControl),
            showSeconds.value ? "has-seconds" : ""
          ]);
          const startTime = computed$1(() => props.parsedValue[0]);
          const endTime = computed$1(() => props.parsedValue[1]);
          const oldValue = useOldValue(props);
          const handleCancel = () => {
            emit("pick", oldValue.value, false);
          };
          const showSeconds = computed$1(() => {
            return props.format.includes("ss");
          });
          const amPmMode = computed$1(() => {
            if (props.format.includes("A"))
              return "A";
            if (props.format.includes("a"))
              return "a";
            return "";
          });
          const handleConfirm = (visible = false) => {
            emit("pick", [startTime.value, endTime.value], visible);
          };
          const handleMinChange = (date4) => {
            handleChange(date4.millisecond(0), endTime.value);
          };
          const handleMaxChange = (date4) => {
            handleChange(startTime.value, date4.millisecond(0));
          };
          const isValidValue = (_date) => {
            const parsedDate = _date.map((_2) => dayjs(_2).locale(lang.value));
            const result = getRangeAvailableTime(parsedDate);
            return parsedDate[0].isSame(result[0]) && parsedDate[1].isSame(result[1]);
          };
          const handleChange = (start, end) => {
            emit("pick", [start, end], true);
          };
          const btnConfirmDisabled = computed$1(() => {
            return startTime.value > endTime.value;
          });
          const selectionRange = ref([0, 2]);
          const setMinSelectionRange = (start, end) => {
            emit("select-range", start, end, "min");
            selectionRange.value = [start, end];
          };
          const offset = computed$1(() => showSeconds.value ? 11 : 8);
          const setMaxSelectionRange = (start, end) => {
            emit("select-range", start, end, "max");
            const _offset = unref(offset);
            selectionRange.value = [start + _offset, end + _offset];
          };
          const changeSelectionRange = (step) => {
            const list = showSeconds.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
            const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
            const index = list.indexOf(selectionRange.value[0]);
            const next = (index + step + list.length) % list.length;
            const half = list.length / 2;
            if (next < half) {
              timePickerOptions["start_emitSelectRange"](mapping[next]);
            } else {
              timePickerOptions["end_emitSelectRange"](mapping[next - half]);
            }
          };
          const handleKeydown = (event) => {
            const code = event.code;
            const { left, right, up, down } = EVENT_CODE;
            if ([left, right].includes(code)) {
              const step = code === left ? -1 : 1;
              changeSelectionRange(step);
              event.preventDefault();
              return;
            }
            if ([up, down].includes(code)) {
              const step = code === up ? -1 : 1;
              const role = selectionRange.value[0] < offset.value ? "start" : "end";
              timePickerOptions[`${role}_scrollDown`](step);
              event.preventDefault();
              return;
            }
          };
          const disabledHours_ = (role, compare) => {
            const defaultDisable = disabledHours ? disabledHours(role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? endTime.value : startTime.value);
            const compareHour = compareDate.hour();
            const nextDisable = isStart ? makeSelectRange(compareHour + 1, 23) : makeSelectRange(0, compareHour - 1);
            return union(defaultDisable, nextDisable);
          };
          const disabledMinutes_ = (hour, role, compare) => {
            const defaultDisable = disabledMinutes ? disabledMinutes(hour, role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? endTime.value : startTime.value);
            const compareHour = compareDate.hour();
            if (hour !== compareHour) {
              return defaultDisable;
            }
            const compareMinute = compareDate.minute();
            const nextDisable = isStart ? makeSelectRange(compareMinute + 1, 59) : makeSelectRange(0, compareMinute - 1);
            return union(defaultDisable, nextDisable);
          };
          const disabledSeconds_ = (hour, minute, role, compare) => {
            const defaultDisable = disabledSeconds ? disabledSeconds(hour, minute, role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? endTime.value : startTime.value);
            const compareHour = compareDate.hour();
            const compareMinute = compareDate.minute();
            if (hour !== compareHour || minute !== compareMinute) {
              return defaultDisable;
            }
            const compareSecond = compareDate.second();
            const nextDisable = isStart ? makeSelectRange(compareSecond + 1, 59) : makeSelectRange(0, compareSecond - 1);
            return union(defaultDisable, nextDisable);
          };
          const getRangeAvailableTime = ([start, end]) => {
            return [
              getAvailableTime(start, "start", true, end),
              getAvailableTime(end, "end", false, start)
            ];
          };
          const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours_, disabledMinutes_, disabledSeconds_);
          const {
            timePickerOptions,
            getAvailableTime,
            onSetOption
          } = useTimePanel({
            getAvailableHours,
            getAvailableMinutes,
            getAvailableSeconds
          });
          const parseUserInput = (days) => {
            if (!days)
              return null;
            if (isArray$1(days)) {
              return days.map((d2) => dayjs(d2, props.format).locale(lang.value));
            }
            return dayjs(days, props.format).locale(lang.value);
          };
          const formatToString = (days) => {
            if (!days)
              return null;
            if (isArray$1(days)) {
              return days.map((d2) => d2.format(props.format));
            }
            return days.format(props.format);
          };
          const getDefaultValue = () => {
            if (isArray$1(defaultValue)) {
              return defaultValue.map((d2) => dayjs(d2).locale(lang.value));
            }
            const defaultDay = dayjs(defaultValue).locale(lang.value);
            return [defaultDay, defaultDay.add(60, "m")];
          };
          emit("set-picker-option", ["formatToString", formatToString]);
          emit("set-picker-option", ["parseUserInput", parseUserInput]);
          emit("set-picker-option", ["isValidValue", isValidValue]);
          emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
          emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
          emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
          return (_ctx, _cache) => {
            return _ctx.actualVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass([unref(nsTime).b("range-picker"), unref(nsPicker).b("panel")])
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(nsTime).be("range-picker", "content"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(nsTime).be("range-picker", "cell"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(nsTime).be("range-picker", "header"))
                  }, toDisplayString(unref(t)("el.datepicker.startTime")), 3),
                  createElementVNode("div", {
                    class: normalizeClass(unref(startContainerKls))
                  }, [
                    createVNode(TimeSpinner, {
                      ref: "minSpinner",
                      role: "start",
                      "show-seconds": unref(showSeconds),
                      "am-pm-mode": unref(amPmMode),
                      "arrow-control": unref(arrowControl),
                      "spinner-date": unref(startTime),
                      "disabled-hours": disabledHours_,
                      "disabled-minutes": disabledMinutes_,
                      "disabled-seconds": disabledSeconds_,
                      onChange: handleMinChange,
                      onSetOption: unref(onSetOption),
                      onSelectRange: setMinSelectionRange
                    }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
                  ], 2)
                ], 2),
                createElementVNode("div", {
                  class: normalizeClass(unref(nsTime).be("range-picker", "cell"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(nsTime).be("range-picker", "header"))
                  }, toDisplayString(unref(t)("el.datepicker.endTime")), 3),
                  createElementVNode("div", {
                    class: normalizeClass(unref(endContainerKls))
                  }, [
                    createVNode(TimeSpinner, {
                      ref: "maxSpinner",
                      role: "end",
                      "show-seconds": unref(showSeconds),
                      "am-pm-mode": unref(amPmMode),
                      "arrow-control": unref(arrowControl),
                      "spinner-date": unref(endTime),
                      "disabled-hours": disabledHours_,
                      "disabled-minutes": disabledMinutes_,
                      "disabled-seconds": disabledSeconds_,
                      onChange: handleMaxChange,
                      onSetOption: unref(onSetOption),
                      onSelectRange: setMaxSelectionRange
                    }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
                  ], 2)
                ], 2)
              ], 2),
              createElementVNode("div", {
                class: normalizeClass(unref(nsTime).be("panel", "footer"))
              }, [
                createElementVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(nsTime).be("panel", "btn"), "cancel"]),
                  onClick: _cache[0] || (_cache[0] = ($event) => handleCancel())
                }, toDisplayString(unref(t)("el.datepicker.cancel")), 3),
                createElementVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(nsTime).be("panel", "btn"), "confirm"]),
                  disabled: unref(btnConfirmDisabled),
                  onClick: _cache[1] || (_cache[1] = ($event) => handleConfirm())
                }, toDisplayString(unref(t)("el.datepicker.confirm")), 11, _hoisted_1$A)
              ], 2)
            ], 2)) : createCommentVNode("v-if", true);
          };
        }
      });
      var TimeRangePanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["__file", "panel-time-range.vue"]]);
      dayjs.extend(customParseFormat);
      var TimePicker = defineComponent({
        name: "ElTimePicker",
        install: null,
        props: {
          ...timePickerDefaultProps,
          isRange: {
            type: Boolean,
            default: false
          }
        },
        emits: ["update:modelValue"],
        setup(props, ctx) {
          const commonPicker = ref();
          const [type4, Panel2] = props.isRange ? ["timerange", TimeRangePanel] : ["time", TimePickPanel];
          const modelUpdater = (value) => ctx.emit("update:modelValue", value);
          provide("ElPopperOptions", props.popperOptions);
          ctx.expose({
            focus: (e) => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleFocusInput(e);
            },
            blur: (e) => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleBlurInput(e);
            },
            handleOpen: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleOpen();
            },
            handleClose: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleClose();
            }
          });
          return () => {
            var _a;
            const format2 = (_a = props.format) != null ? _a : DEFAULT_FORMATS_TIME;
            return createVNode(CommonPicker, mergeProps(props, {
              "ref": commonPicker,
              "type": type4,
              "format": format2,
              "onUpdate:modelValue": modelUpdater
            }), {
              default: (props2) => createVNode(Panel2, props2, null)
            });
          };
        }
      });
      const _TimePicker = TimePicker;
      _TimePicker.install = (app) => {
        app.component(_TimePicker.name, _TimePicker);
      };
      const ElTimePicker = _TimePicker;
      const checkboxProps = {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        value: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueValue: {
          type: [String, Number],
          default: void 0
        },
        falseValue: {
          type: [String, Number],
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        controls: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        }
      };
      const checkboxEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString(val) || isNumber(val) || isBoolean(val),
        change: (val) => isString(val) || isNumber(val) || isBoolean(val)
      };
      const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = computed$1(() => {
          var _a, _b;
          const max = (_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value;
          const min = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined$1(max) && model.value.length >= max && !isChecked.value || !isUndefined$1(min) && model.value.length <= min && isChecked.value;
        });
        const isDisabled = useFormDisabled(computed$1(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit } = getCurrentInstance();
        function getLabeledValue(value) {
          var _a, _b, _c, _d;
          return [true, props.trueValue, props.trueLabel].includes(value) ? (_b = (_a = props.trueValue) != null ? _a : props.trueLabel) != null ? _b : true : (_d = (_c = props.falseValue) != null ? _c : props.falseLabel) != null ? _d : false;
        }
        function emitChangeEvent(checked, e) {
          emit("change", getLabeledValue(checked), e);
        }
        function handleChange(e) {
          if (isLimitExceeded.value)
            return;
          const target = e.target;
          emit("change", getLabeledValue(target.checked), e);
        }
        async function onClickRoot(e) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props.falseValue, props.falseLabel].includes(model.value));
              await nextTick();
              emitChangeEvent(model.value, e);
            }
          }
        }
        const validateEvent = computed$1(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
        watch(() => props.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props) => {
        const selfModel = ref(false);
        const { emit } = getCurrentInstance();
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isGroup = computed$1(() => isUndefined$1(checkboxGroup) === false);
        const isLimitExceeded = ref(false);
        const model = computed$1({
          get() {
            var _a, _b;
            return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a.value : (_b = props.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a, _b;
            if (isGroup.value && isArray$1(val)) {
              isLimitExceeded.value = ((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value) && val.length > model.value.length;
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props, slots, { model }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isFocused = ref(false);
        const actualValue = computed$1(() => {
          if (!isPropAbsent(props.value)) {
            return props.value;
          }
          return props.label;
        });
        const isChecked = computed$1(() => {
          const value = model.value;
          if (isBoolean(value)) {
            return value;
          } else if (isArray$1(value)) {
            if (isObject$1(actualValue.value)) {
              return value.map(toRaw$1).some((o2) => isEqual(o2, actualValue.value));
            } else {
              return value.map(toRaw$1).includes(actualValue.value);
            }
          } else if (value !== null && value !== void 0) {
            return value === props.trueValue || value === props.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(computed$1(() => {
          var _a;
          return (_a = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(computed$1(() => {
          var _a;
          return (_a = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a.value;
        }));
        const hasOwnLabel = computed$1(() => {
          return !!slots.default || !isPropAbsent(actualValue.value);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel,
          actualValue
        };
      };
      const useCheckbox = (props, slots) => {
        const { formItem: elFormItem } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          actualValue
        } = useCheckboxStatus(props, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: elFormItem,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        const setStoreValue = () => {
          function addToStore() {
            var _a, _b;
            if (isArray$1(model.value) && !model.value.includes(actualValue.value)) {
              model.value.push(actualValue.value);
            } else {
              model.value = (_b = (_a = props.trueValue) != null ? _a : props.trueLabel) != null ? _b : true;
            }
          }
          props.checked && addToStore();
        };
        setStoreValue();
        useDeprecated({
          from: "label act as value",
          replacement: "value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed$1(() => isGroup.value && isPropAbsent(props.value)));
        useDeprecated({
          from: "true-label",
          replacement: "true-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed$1(() => !!props.trueLabel));
        useDeprecated({
          from: "false-label",
          replacement: "false-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed$1(() => !!props.falseLabel));
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          actualValue,
          handleChange,
          onClickRoot
        };
      };
      const _hoisted_1$z = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$q = ["id", "indeterminate", "disabled", "value", "name", "tabindex"];
      const __default__$r = defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$O = /* @__PURE__ */ defineComponent({
        ...__default__$r,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            actualValue,
            handleChange,
            onClickRoot
          } = useCheckbox(props, slots);
          const ns = useNamespace("checkbox");
          const compKls = computed$1(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = computed$1(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
              class: normalizeClass(unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
              onClick: unref(onClickRoot)
            }, {
              default: withCtx(() => {
                var _a, _b;
                return [
                  createElementVNode("span", {
                    class: normalizeClass(unref(spanKls))
                  }, [
                    _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                      key: 0,
                      id: unref(inputId),
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      disabled: unref(isDisabled),
                      "true-value": (_a = _ctx.trueValue) != null ? _a : _ctx.trueLabel,
                      "false-value": (_b = _ctx.falseValue) != null ? _b : _ctx.falseLabel,
                      onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                      onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                      onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
                      onClick: _cache[4] || (_cache[4] = withModifiers(() => {
                      }, ["stop"]))
                    }, null, 42, _hoisted_1$z)), [
                      [vModelCheckbox, unref(model)]
                    ]) : withDirectives((openBlock(), createElementBlock("input", {
                      key: 1,
                      id: unref(inputId),
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(model) ? model.value = $event : null),
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      disabled: unref(isDisabled),
                      value: unref(actualValue),
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      onChange: _cache[6] || (_cache[6] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                      onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
                      onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
                      onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                      }, ["stop"]))
                    }, null, 42, _hoisted_2$q)), [
                      [vModelCheckbox, unref(model)]
                    ]),
                    createElementVNode("span", {
                      class: normalizeClass(unref(ns).e("inner"))
                    }, null, 2)
                  ], 2),
                  unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(ns).e("label"))
                  }, [
                    renderSlot(_ctx.$slots, "default"),
                    !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createTextVNode(toDisplayString(_ctx.label), 1)
                    ], 64)) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true)
                ];
              }),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["__file", "checkbox.vue"]]);
      const _hoisted_1$y = ["name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$p = ["name", "tabindex", "disabled", "value"];
      const __default__$q = defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$N = /* @__PURE__ */ defineComponent({
        ...__default__$q,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            actualValue,
            handleChange
          } = useCheckbox(props, slots);
          const checkboxGroup = inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = computed$1(() => {
            var _a, _b, _c, _d;
            const fillValue = (_b = (_a = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = computed$1(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            var _a, _b;
            return openBlock(), createElementBlock("label", {
              class: normalizeClass(unref(labelKls))
            }, [
              _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                "true-value": (_a = _ctx.trueValue) != null ? _a : _ctx.trueLabel,
                "false-value": (_b = _ctx.falseValue) != null ? _b : _ctx.falseLabel,
                onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
                onClick: _cache[4] || (_cache[4] = withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_1$y)), [
                [vModelCheckbox, unref(model)]
              ]) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                value: unref(actualValue),
                onChange: _cache[6] || (_cache[6] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
                onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
                onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_2$p)), [
                [vModelCheckbox, unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["__file", "checkbox-button.vue"]]);
      const checkboxGroupProps = buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        label: String,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const checkboxGroupEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isArray$1(val),
        change: (val) => isArray$1(val)
      };
      const __default__$p = defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$M = /* @__PURE__ */ defineComponent({
        ...__default__$p,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit }) {
          const props = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit(UPDATE_MODEL_EVENT, value);
            await nextTick();
            emit("change", value);
          };
          const modelValue = computed$1({
            get() {
              return props.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          provide(checkboxGroupContextKey, {
            ...pick(toRefs(props), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          watch(() => props.modelValue, () => {
            if (props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              id: unref(groupId),
              class: normalizeClass(unref(ns).b("group")),
              role: "group",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? (_a = unref(formItem)) == null ? void 0 : _a.labelId : void 0
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["__file", "checkbox-group.vue"]]);
      const ElCheckbox = withInstall(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      });
      withNoopInstall(CheckboxButton);
      withNoopInstall(CheckboxGroup);
      const tagProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger"],
          default: "primary"
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: String,
        size: {
          type: String,
          values: componentSizes
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      });
      const tagEmits = {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$o = defineComponent({
        name: "ElTag"
      });
      const _sfc_main$L = /* @__PURE__ */ defineComponent({
        ...__default__$o,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit }) {
          const props = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = computed$1(() => {
            const { type: type4, hit, effect, closable, round } = props;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type4 || "primary"),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round)
            ];
          });
          const handleClose = (event) => {
            emit("close", event);
          };
          const handleClick = (event) => {
            emit("click", event);
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(containerKls)),
              style: normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              createElementVNode("span", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns).e("close")),
                onClick: withModifiers(handleClose, ["stop"])
              }, {
                default: withCtx(() => [
                  createVNode(unref(close_default))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ], 6)) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              appear: ""
            }, {
              default: withCtx(() => [
                createElementVNode("span", {
                  class: normalizeClass(unref(containerKls)),
                  style: normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  createElementVNode("span", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).e("close")),
                    onClick: withModifiers(handleClose, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(close_default))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__file", "tag.vue"]]);
      const ElTag = withInstall(Tag);
      const rowContextKey = Symbol("rowContextKey");
      const RowJustify = [
        "start",
        "center",
        "end",
        "space-around",
        "space-between",
        "space-evenly"
      ];
      const RowAlign = ["top", "middle", "bottom"];
      const rowProps = buildProps({
        tag: {
          type: String,
          default: "div"
        },
        gutter: {
          type: Number,
          default: 0
        },
        justify: {
          type: String,
          values: RowJustify,
          default: "start"
        },
        align: {
          type: String,
          values: RowAlign
        }
      });
      const __default__$n = defineComponent({
        name: "ElRow"
      });
      const _sfc_main$K = /* @__PURE__ */ defineComponent({
        ...__default__$n,
        props: rowProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("row");
          const gutter = computed$1(() => props.gutter);
          provide(rowContextKey, {
            gutter
          });
          const style = computed$1(() => {
            const styles = {};
            if (!props.gutter) {
              return styles;
            }
            styles.marginRight = styles.marginLeft = `-${props.gutter / 2}px`;
            return styles;
          });
          const rowKls = computed$1(() => [
            ns.b(),
            ns.is(`justify-${props.justify}`, props.justify !== "start"),
            ns.is(`align-${props.align}`, !!props.align)
          ]);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              class: normalizeClass(unref(rowKls)),
              style: normalizeStyle(unref(style))
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Row = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["__file", "row.vue"]]);
      const ElRow = withInstall(Row);
      const colProps = buildProps({
        tag: {
          type: String,
          default: "div"
        },
        span: {
          type: Number,
          default: 24
        },
        offset: {
          type: Number,
          default: 0
        },
        pull: {
          type: Number,
          default: 0
        },
        push: {
          type: Number,
          default: 0
        },
        xs: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        sm: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        md: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        lg: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        xl: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        }
      });
      const __default__$m = defineComponent({
        name: "ElCol"
      });
      const _sfc_main$J = /* @__PURE__ */ defineComponent({
        ...__default__$m,
        props: colProps,
        setup(__props) {
          const props = __props;
          const { gutter } = inject(rowContextKey, { gutter: computed$1(() => 0) });
          const ns = useNamespace("col");
          const style = computed$1(() => {
            const styles = {};
            if (gutter.value) {
              styles.paddingLeft = styles.paddingRight = `${gutter.value / 2}px`;
            }
            return styles;
          });
          const colKls = computed$1(() => {
            const classes = [];
            const pos = ["span", "offset", "pull", "push"];
            pos.forEach((prop) => {
              const size = props[prop];
              if (isNumber(size)) {
                if (prop === "span")
                  classes.push(ns.b(`${props[prop]}`));
                else if (size > 0)
                  classes.push(ns.b(`${prop}-${props[prop]}`));
              }
            });
            const sizes = ["xs", "sm", "md", "lg", "xl"];
            sizes.forEach((size) => {
              if (isNumber(props[size])) {
                classes.push(ns.b(`${size}-${props[size]}`));
              } else if (isObject$1(props[size])) {
                Object.entries(props[size]).forEach(([prop, sizeProp]) => {
                  classes.push(prop !== "span" ? ns.b(`${size}-${prop}-${sizeProp}`) : ns.b(`${size}-${sizeProp}`));
                });
              }
            });
            if (gutter.value) {
              classes.push(ns.is("guttered"));
            }
            return [ns.b(), classes];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              class: normalizeClass(unref(colKls)),
              style: normalizeStyle(unref(style))
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Col = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__file", "col.vue"]]);
      const ElCol = withInstall(Col);
      const __default__$l = defineComponent({
        name: "ElCollapseTransition"
      });
      const _sfc_main$I = /* @__PURE__ */ defineComponent({
        ...__default__$l,
        setup(__props) {
          const ns = useNamespace("collapse-transition");
          const reset = (el) => {
            el.style.maxHeight = "";
            el.style.overflow = el.dataset.oldOverflow;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          };
          const on2 = {
            beforeEnter(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              if (el.style.height)
                el.dataset.elExistsHeight = el.style.height;
              el.style.maxHeight = 0;
              el.style.paddingTop = 0;
              el.style.paddingBottom = 0;
            },
            enter(el) {
              requestAnimationFrame(() => {
                el.dataset.oldOverflow = el.style.overflow;
                if (el.dataset.elExistsHeight) {
                  el.style.maxHeight = el.dataset.elExistsHeight;
                } else if (el.scrollHeight !== 0) {
                  el.style.maxHeight = `${el.scrollHeight}px`;
                } else {
                  el.style.maxHeight = 0;
                }
                el.style.paddingTop = el.dataset.oldPaddingTop;
                el.style.paddingBottom = el.dataset.oldPaddingBottom;
                el.style.overflow = "hidden";
              });
            },
            afterEnter(el) {
              el.style.maxHeight = "";
              el.style.overflow = el.dataset.oldOverflow;
            },
            enterCancelled(el) {
              reset(el);
            },
            beforeLeave(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              el.dataset.oldOverflow = el.style.overflow;
              el.style.maxHeight = `${el.scrollHeight}px`;
              el.style.overflow = "hidden";
            },
            leave(el) {
              if (el.scrollHeight !== 0) {
                el.style.maxHeight = 0;
                el.style.paddingTop = 0;
                el.style.paddingBottom = 0;
              }
            },
            afterLeave(el) {
              reset(el);
            },
            leaveCancelled(el) {
              reset(el);
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, mergeProps({
              name: unref(ns).b()
            }, toHandlers(on2)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["name"]);
          };
        }
      });
      var CollapseTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__file", "collapse-transition.vue"]]);
      CollapseTransition.install = (app) => {
        app.component(CollapseTransition.name, CollapseTransition);
      };
      const _CollapseTransition = CollapseTransition;
      const overlayProps = buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: {
          type: Boolean,
          default: false
        },
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      });
      const overlayEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const BLOCK = "overlay";
      var Overlay = defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props, { slots, emit }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e) => {
            emit("click", e);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props.mask ? createVNode("div", {
              class: [ns.b(), props.overlayClass],
              style: {
                zIndex: props.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
              class: props.overlayClass,
              style: {
                zIndex: props.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = Overlay;
      const dialogInjectionKey = Symbol("dialogInjectionKey");
      const dialogContentProps = buildProps({
        center: Boolean,
        alignCenter: Boolean,
        closeIcon: {
          type: iconPropType
        },
        draggable: Boolean,
        overflow: Boolean,
        fullscreen: Boolean,
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        ariaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const _hoisted_1$x = ["aria-level"];
      const _hoisted_2$o = ["aria-label"];
      const _hoisted_3$f = ["id"];
      const __default__$k = defineComponent({ name: "ElDialogContent" });
      const _sfc_main$H = /* @__PURE__ */ defineComponent({
        ...__default__$k,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props) {
          const props = __props;
          const { t } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style } = inject(dialogInjectionKey);
          const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
          const dialogKls = computed$1(() => [
            ns.b(),
            ns.is("fullscreen", props.fullscreen),
            ns.is("draggable", props.draggable),
            ns.is("align-center", props.alignCenter),
            { [ns.m("center")]: props.center }
          ]);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable = computed$1(() => props.draggable);
          const overflow = computed$1(() => props.overflow);
          useDraggable(dialogRef, headerRef, draggable, overflow);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref: unref(composedDialogRef),
              class: normalizeClass(unref(dialogKls)),
              style: normalizeStyle(unref(style)),
              tabindex: "-1"
            }, [
              createElementVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: normalizeClass([unref(ns).e("header"), { "show-close": _ctx.showClose }])
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createElementVNode("span", {
                    role: "heading",
                    "aria-level": _ctx.ariaLevel,
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString(_ctx.title), 11, _hoisted_1$x)
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": unref(t)("el.dialog.close"),
                  class: normalizeClass(unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass(unref(ns).e("close"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, _hoisted_2$o)) : createCommentVNode("v-if", true)
              ], 2),
              createElementVNode("div", {
                id: unref(bodyId),
                class: normalizeClass(unref(ns).e("body"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 10, _hoisted_3$f),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
                key: 0,
                class: normalizeClass(unref(ns).e("footer"))
              }, [
                renderSlot(_ctx.$slots, "footer")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["__file", "dialog-content.vue"]]);
      const dialogProps = buildProps({
        ...dialogContentProps,
        appendToBody: Boolean,
        appendTo: {
          type: definePropType(String),
          default: "body"
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: Boolean,
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: Boolean,
        modalClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: {
          type: Boolean,
          default: false
        },
        headerAriaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogEmits = {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      };
      const useDialog = (props, targetRef) => {
        var _a;
        const instance = getCurrentInstance();
        const emit = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = ref(false);
        const closed = ref(false);
        const rendered = ref(false);
        const zIndex2 = ref((_a = props.zIndex) != null ? _a : nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const namespace = useGlobalConfig("namespace", defaultNamespace);
        const style = computed$1(() => {
          const style2 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props.fullscreen) {
            if (props.top) {
              style2[`${varPrefix}-margin-top`] = props.top;
            }
            if (props.width) {
              style2[`${varPrefix}-width`] = addUnit(props.width);
            }
          }
          return style2;
        });
        const overlayDialogStyle = computed$1(() => {
          if (props.alignCenter) {
            return { display: "flex" };
          }
          return {};
        });
        function afterEnter() {
          emit("opened");
        }
        function afterLeave() {
          emit("closed");
          emit(UPDATE_MODEL_EVENT, false);
          if (props.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit("close");
        }
        function open() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props.openDelay && props.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
          } else {
            doOpen();
          }
        }
        function close() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props.closeDelay && props.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props.beforeClose) {
            props.beforeClose(hide);
          } else {
            close();
          }
        }
        function onModalClick() {
          if (props.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props.closeOnPressEscape) {
            handleClose();
          }
        }
        watch(() => props.modelValue, (val) => {
          if (val) {
            closed.value = false;
            open();
            rendered.value = true;
            zIndex2.value = isUndefined(props.zIndex) ? nextZIndex() : zIndex2.value++;
            nextTick(() => {
              emit("open");
              if (targetRef.value) {
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close();
            }
          }
        });
        watch(() => props.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        onMounted(() => {
          if (props.modelValue) {
            visible.value = true;
            rendered.value = true;
            open();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2
        };
      };
      const _hoisted_1$w = ["aria-label", "aria-labelledby", "aria-describedby"];
      const __default__$j = defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$G = /* @__PURE__ */ defineComponent({
        ...__default__$j,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose }) {
          const props = __props;
          const slots = useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, computed$1(() => !!slots.title));
          const ns = useNamespace("dialog");
          const dialogRef = ref();
          const headerRef = ref();
          const dialogContentRef = ref();
          const {
            visible,
            titleId,
            bodyId,
            style,
            overlayDialogStyle,
            rendered,
            zIndex: zIndex2,
            afterEnter,
            afterLeave,
            beforeLeave,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props, dialogRef);
          provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style
          });
          const overlayEvent = useSameTarget(onModalClick);
          const draggable = computed$1(() => props.draggable && !props.fullscreen);
          expose({
            visible,
            dialogContentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: _ctx.appendTo,
              disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
            }, [
              createVNode(Transition, {
                name: "dialog-fade",
                onAfterEnter: unref(afterEnter),
                onAfterLeave: unref(afterLeave),
                onBeforeLeave: unref(beforeLeave),
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createVNode(unref(ElOverlay), {
                    "custom-mask-event": "",
                    mask: _ctx.modal,
                    "overlay-class": _ctx.modalClass,
                    "z-index": unref(zIndex2)
                  }, {
                    default: withCtx(() => [
                      createElementVNode("div", {
                        role: "dialog",
                        "aria-modal": "true",
                        "aria-label": _ctx.title || void 0,
                        "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                        "aria-describedby": unref(bodyId),
                        class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                        style: normalizeStyle(unref(overlayDialogStyle)),
                        onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                        onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                        onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                      }, [
                        createVNode(unref(ElFocusTrap), {
                          loop: "",
                          trapped: unref(visible),
                          "focus-start-el": "container",
                          onFocusAfterTrapped: unref(onOpenAutoFocus),
                          onFocusAfterReleased: unref(onCloseAutoFocus),
                          onFocusoutPrevented: unref(onFocusoutPrevented),
                          onReleaseRequested: unref(onCloseRequested)
                        }, {
                          default: withCtx(() => [
                            unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                              key: 0,
                              ref_key: "dialogContentRef",
                              ref: dialogContentRef
                            }, _ctx.$attrs, {
                              center: _ctx.center,
                              "align-center": _ctx.alignCenter,
                              "close-icon": _ctx.closeIcon,
                              draggable: unref(draggable),
                              overflow: _ctx.overflow,
                              fullscreen: _ctx.fullscreen,
                              "show-close": _ctx.showClose,
                              title: _ctx.title,
                              "aria-level": _ctx.headerAriaLevel,
                              onClose: unref(handleClose)
                            }), createSlots({
                              header: withCtx(() => [
                                !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                  key: 0,
                                  close: unref(handleClose),
                                  titleId: unref(titleId),
                                  titleClass: unref(ns).e("title")
                                }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                              ]),
                              default: withCtx(() => [
                                renderSlot(_ctx.$slots, "default")
                              ]),
                              _: 2
                            }, [
                              _ctx.$slots.footer ? {
                                name: "footer",
                                fn: withCtx(() => [
                                  renderSlot(_ctx.$slots, "footer")
                                ])
                              } : void 0
                            ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : createCommentVNode("v-if", true)
                          ]),
                          _: 3
                        }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                      ], 46, _hoisted_1$w)
                    ]),
                    _: 3
                  }, 8, ["mask", "overlay-class", "z-index"]), [
                    [vShow, unref(visible)]
                  ])
                ]),
                _: 3
              }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
            ], 8, ["to", "disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__file", "dialog.vue"]]);
      const ElDialog = withInstall(Dialog);
      const _hoisted_1$v = {
        viewBox: "0 0 79 86",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink"
      };
      const _hoisted_2$n = ["id"];
      const _hoisted_3$e = ["stop-color"];
      const _hoisted_4$8 = ["stop-color"];
      const _hoisted_5$7 = ["id"];
      const _hoisted_6$4 = ["stop-color"];
      const _hoisted_7$2 = ["stop-color"];
      const _hoisted_8$1 = ["id"];
      const _hoisted_9$1 = {
        id: "Illustrations",
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      };
      const _hoisted_10$1 = {
        id: "B-type",
        transform: "translate(-1268.000000, -535.000000)"
      };
      const _hoisted_11$1 = {
        id: "Group-2",
        transform: "translate(1268.000000, 535.000000)"
      };
      const _hoisted_12$1 = ["fill"];
      const _hoisted_13$1 = ["fill"];
      const _hoisted_14$1 = {
        id: "Group-Copy",
        transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
      };
      const _hoisted_15$1 = ["fill"];
      const _hoisted_16$1 = ["fill"];
      const _hoisted_17$1 = ["fill"];
      const _hoisted_18$1 = ["fill"];
      const _hoisted_19$1 = ["fill"];
      const _hoisted_20$1 = {
        id: "Rectangle-Copy-17",
        transform: "translate(53.000000, 45.000000)"
      };
      const _hoisted_21$1 = ["fill", "xlink:href"];
      const _hoisted_22$1 = ["fill", "mask"];
      const _hoisted_23$1 = ["fill"];
      const __default__$i = defineComponent({
        name: "ImgEmpty"
      });
      const _sfc_main$F = /* @__PURE__ */ defineComponent({
        ...__default__$i,
        setup(__props) {
          const ns = useNamespace("empty");
          const id = useId();
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("svg", _hoisted_1$v, [
              createElementVNode("defs", null, [
                createElementVNode("linearGradient", {
                  id: `linearGradient-1-${unref(id)}`,
                  x1: "38.8503086%",
                  y1: "0%",
                  x2: "61.1496914%",
                  y2: "100%"
                }, [
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-1")})`,
                    offset: "0%"
                  }, null, 8, _hoisted_3$e),
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-4")})`,
                    offset: "100%"
                  }, null, 8, _hoisted_4$8)
                ], 8, _hoisted_2$n),
                createElementVNode("linearGradient", {
                  id: `linearGradient-2-${unref(id)}`,
                  x1: "0%",
                  y1: "9.5%",
                  x2: "100%",
                  y2: "90.5%"
                }, [
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-1")})`,
                    offset: "0%"
                  }, null, 8, _hoisted_6$4),
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-6")})`,
                    offset: "100%"
                  }, null, 8, _hoisted_7$2)
                ], 8, _hoisted_5$7),
                createElementVNode("rect", {
                  id: `path-3-${unref(id)}`,
                  x: "0",
                  y: "0",
                  width: "17",
                  height: "36"
                }, null, 8, _hoisted_8$1)
              ]),
              createElementVNode("g", _hoisted_9$1, [
                createElementVNode("g", _hoisted_10$1, [
                  createElementVNode("g", _hoisted_11$1, [
                    createElementVNode("path", {
                      id: "Oval-Copy-2",
                      d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
                      fill: `var(${unref(ns).cssVarBlockName("fill-color-3")})`
                    }, null, 8, _hoisted_12$1),
                    createElementVNode("polygon", {
                      id: "Rectangle-Copy-14",
                      fill: `var(${unref(ns).cssVarBlockName("fill-color-7")})`,
                      transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
                      points: "13 58 53 58 42 45 2 45"
                    }, null, 8, _hoisted_13$1),
                    createElementVNode("g", _hoisted_14$1, [
                      createElementVNode("polygon", {
                        id: "Rectangle-Copy-10",
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-7")})`,
                        transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                        points: "2.84078316e-14 3 18 3 23 7 5 7"
                      }, null, 8, _hoisted_15$1),
                      createElementVNode("polygon", {
                        id: "Rectangle-Copy-11",
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-5")})`,
                        points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
                      }, null, 8, _hoisted_16$1),
                      createElementVNode("rect", {
                        id: "Rectangle-Copy-12",
                        fill: `url(#linearGradient-1-${unref(id)})`,
                        transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                        x: "38",
                        y: "7",
                        width: "17",
                        height: "36"
                      }, null, 8, _hoisted_17$1),
                      createElementVNode("polygon", {
                        id: "Rectangle-Copy-13",
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-2")})`,
                        transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                        points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
                      }, null, 8, _hoisted_18$1)
                    ]),
                    createElementVNode("rect", {
                      id: "Rectangle-Copy-15",
                      fill: `url(#linearGradient-2-${unref(id)})`,
                      x: "13",
                      y: "45",
                      width: "40",
                      height: "36"
                    }, null, 8, _hoisted_19$1),
                    createElementVNode("g", _hoisted_20$1, [
                      createElementVNode("use", {
                        id: "Mask",
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-8")})`,
                        transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                        "xlink:href": `#path-3-${unref(id)}`
                      }, null, 8, _hoisted_21$1),
                      createElementVNode("polygon", {
                        id: "Rectangle-Copy",
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-9")})`,
                        mask: `url(#mask-4-${unref(id)})`,
                        transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                        points: "7 0 24 0 20 18 7 16.5"
                      }, null, 8, _hoisted_22$1)
                    ]),
                    createElementVNode("polygon", {
                      id: "Rectangle-Copy-18",
                      fill: `var(${unref(ns).cssVarBlockName("fill-color-2")})`,
                      transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
                      points: "62 45 79 45 70 58 53 58"
                    }, null, 8, _hoisted_23$1)
                  ])
                ])
              ])
            ]);
          };
        }
      });
      var ImgEmpty = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__file", "img-empty.vue"]]);
      const emptyProps = buildProps({
        image: {
          type: String,
          default: ""
        },
        imageSize: Number,
        description: {
          type: String,
          default: ""
        }
      });
      const _hoisted_1$u = ["src"];
      const _hoisted_2$m = { key: 1 };
      const __default__$h = defineComponent({
        name: "ElEmpty"
      });
      const _sfc_main$E = /* @__PURE__ */ defineComponent({
        ...__default__$h,
        props: emptyProps,
        setup(__props) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("empty");
          const emptyDescription = computed$1(() => props.description || t("el.table.emptyText"));
          const imageStyle = computed$1(() => ({
            width: addUnit(props.imageSize)
          }));
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("image")),
                style: normalizeStyle(unref(imageStyle))
              }, [
                _ctx.image ? (openBlock(), createElementBlock("img", {
                  key: 0,
                  src: _ctx.image,
                  ondragstart: "return false"
                }, null, 8, _hoisted_1$u)) : renderSlot(_ctx.$slots, "image", { key: 1 }, () => [
                  createVNode(ImgEmpty)
                ])
              ], 6),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("description"))
              }, [
                _ctx.$slots.description ? renderSlot(_ctx.$slots, "description", { key: 0 }) : (openBlock(), createElementBlock("p", _hoisted_2$m, toDisplayString(unref(emptyDescription)), 1))
              ], 2),
              _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("bottom"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Empty = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["__file", "empty.vue"]]);
      const ElEmpty = withInstall(Empty);
      const imageViewerProps = buildProps({
        urlList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        hideOnClickModal: Boolean,
        teleported: Boolean,
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        },
        minScale: {
          type: Number,
          default: 0.2
        },
        maxScale: {
          type: Number,
          default: 7
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const imageViewerEmits = {
        close: () => true,
        switch: (index) => isNumber(index),
        rotate: (deg) => isNumber(deg)
      };
      const _hoisted_1$t = ["src", "crossorigin"];
      const __default__$g = defineComponent({
        name: "ElImageViewer"
      });
      const _sfc_main$D = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        props: imageViewerProps,
        emits: imageViewerEmits,
        setup(__props, { expose, emit }) {
          var _a;
          const props = __props;
          const modes = {
            CONTAIN: {
              name: "contain",
              icon: markRaw(full_screen_default)
            },
            ORIGINAL: {
              name: "original",
              icon: markRaw(scale_to_original_default)
            }
          };
          const { t } = useLocale();
          const ns = useNamespace("image-viewer");
          const { nextZIndex } = useZIndex();
          const wrapper = ref();
          const imgRefs = ref([]);
          const scopeEventListener = effectScope();
          const loading = ref(true);
          const activeIndex = ref(props.initialIndex);
          const mode = shallowRef(modes.CONTAIN);
          const transform = ref({
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: false
          });
          const zIndex2 = ref((_a = props.zIndex) != null ? _a : nextZIndex());
          const isSingle = computed$1(() => {
            const { urlList } = props;
            return urlList.length <= 1;
          });
          const isFirst = computed$1(() => {
            return activeIndex.value === 0;
          });
          const isLast = computed$1(() => {
            return activeIndex.value === props.urlList.length - 1;
          });
          const currentImg = computed$1(() => {
            return props.urlList[activeIndex.value];
          });
          const arrowPrevKls = computed$1(() => [
            ns.e("btn"),
            ns.e("prev"),
            ns.is("disabled", !props.infinite && isFirst.value)
          ]);
          const arrowNextKls = computed$1(() => [
            ns.e("btn"),
            ns.e("next"),
            ns.is("disabled", !props.infinite && isLast.value)
          ]);
          const imgStyle = computed$1(() => {
            const { scale, deg, offsetX, offsetY, enableTransition } = transform.value;
            let translateX = offsetX / scale;
            let translateY = offsetY / scale;
            switch (deg % 360) {
              case 90:
              case -270:
                [translateX, translateY] = [translateY, -translateX];
                break;
              case 180:
              case -180:
                [translateX, translateY] = [-translateX, -translateY];
                break;
              case 270:
              case -90:
                [translateX, translateY] = [-translateY, translateX];
                break;
            }
            const style = {
              transform: `scale(${scale}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
              transition: enableTransition ? "transform .3s" : ""
            };
            if (mode.value.name === modes.CONTAIN.name) {
              style.maxWidth = style.maxHeight = "100%";
            }
            return style;
          });
          function hide() {
            unregisterEventListener();
            emit("close");
          }
          function registerEventListener() {
            const keydownHandler = throttle((e) => {
              switch (e.code) {
                case EVENT_CODE.esc:
                  props.closeOnPressEscape && hide();
                  break;
                case EVENT_CODE.space:
                  toggleMode();
                  break;
                case EVENT_CODE.left:
                  prev();
                  break;
                case EVENT_CODE.up:
                  handleActions("zoomIn");
                  break;
                case EVENT_CODE.right:
                  next();
                  break;
                case EVENT_CODE.down:
                  handleActions("zoomOut");
                  break;
              }
            });
            const mousewheelHandler = throttle((e) => {
              const delta = e.deltaY || e.deltaX;
              handleActions(delta < 0 ? "zoomIn" : "zoomOut", {
                zoomRate: props.zoomRate,
                enableTransition: false
              });
            });
            scopeEventListener.run(() => {
              useEventListener(document, "keydown", keydownHandler);
              useEventListener(document, "wheel", mousewheelHandler);
            });
          }
          function unregisterEventListener() {
            scopeEventListener.stop();
          }
          function handleImgLoad() {
            loading.value = false;
          }
          function handleImgError(e) {
            loading.value = false;
            e.target.alt = t("el.image.error");
          }
          function handleMouseDown(e) {
            if (loading.value || e.button !== 0 || !wrapper.value)
              return;
            transform.value.enableTransition = false;
            const { offsetX, offsetY } = transform.value;
            const startX = e.pageX;
            const startY = e.pageY;
            const dragHandler = throttle((ev) => {
              transform.value = {
                ...transform.value,
                offsetX: offsetX + ev.pageX - startX,
                offsetY: offsetY + ev.pageY - startY
              };
            });
            const removeMousemove = useEventListener(document, "mousemove", dragHandler);
            useEventListener(document, "mouseup", () => {
              removeMousemove();
            });
            e.preventDefault();
          }
          function reset() {
            transform.value = {
              scale: 1,
              deg: 0,
              offsetX: 0,
              offsetY: 0,
              enableTransition: false
            };
          }
          function toggleMode() {
            if (loading.value)
              return;
            const modeNames = keysOf(modes);
            const modeValues = Object.values(modes);
            const currentMode = mode.value.name;
            const index = modeValues.findIndex((i) => i.name === currentMode);
            const nextIndex = (index + 1) % modeNames.length;
            mode.value = modes[modeNames[nextIndex]];
            reset();
          }
          function setActiveItem(index) {
            const len = props.urlList.length;
            activeIndex.value = (index + len) % len;
          }
          function prev() {
            if (isFirst.value && !props.infinite)
              return;
            setActiveItem(activeIndex.value - 1);
          }
          function next() {
            if (isLast.value && !props.infinite)
              return;
            setActiveItem(activeIndex.value + 1);
          }
          function handleActions(action, options = {}) {
            if (loading.value)
              return;
            const { minScale, maxScale } = props;
            const { zoomRate, rotateDeg, enableTransition } = {
              zoomRate: props.zoomRate,
              rotateDeg: 90,
              enableTransition: true,
              ...options
            };
            switch (action) {
              case "zoomOut":
                if (transform.value.scale > minScale) {
                  transform.value.scale = Number.parseFloat((transform.value.scale / zoomRate).toFixed(3));
                }
                break;
              case "zoomIn":
                if (transform.value.scale < maxScale) {
                  transform.value.scale = Number.parseFloat((transform.value.scale * zoomRate).toFixed(3));
                }
                break;
              case "clockwise":
                transform.value.deg += rotateDeg;
                emit("rotate", transform.value.deg);
                break;
              case "anticlockwise":
                transform.value.deg -= rotateDeg;
                emit("rotate", transform.value.deg);
                break;
            }
            transform.value.enableTransition = enableTransition;
          }
          watch(currentImg, () => {
            nextTick(() => {
              const $img = imgRefs.value[0];
              if (!($img == null ? void 0 : $img.complete)) {
                loading.value = true;
              }
            });
          });
          watch(activeIndex, (val) => {
            reset();
            emit("switch", val);
          });
          onMounted(() => {
            var _a2, _b;
            registerEventListener();
            (_b = (_a2 = wrapper.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          });
          expose({
            setActiveItem
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: "body",
              disabled: !_ctx.teleported
            }, [
              createVNode(Transition, {
                name: "viewer-fade",
                appear: ""
              }, {
                default: withCtx(() => [
                  createElementVNode("div", {
                    ref_key: "wrapper",
                    ref: wrapper,
                    tabindex: -1,
                    class: normalizeClass(unref(ns).e("wrapper")),
                    style: normalizeStyle({ zIndex: zIndex2.value })
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("mask")),
                      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.hideOnClickModal && hide(), ["self"]))
                    }, null, 2),
                    createCommentVNode(" CLOSE "),
                    createElementVNode("span", {
                      class: normalizeClass([unref(ns).e("btn"), unref(ns).e("close")]),
                      onClick: hide
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(close_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    createCommentVNode(" ARROW "),
                    !unref(isSingle) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createElementVNode("span", {
                        class: normalizeClass(unref(arrowPrevKls)),
                        onClick: prev
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 2),
                      createElementVNode("span", {
                        class: normalizeClass(unref(arrowNextKls)),
                        onClick: next
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 2)
                    ], 64)) : createCommentVNode("v-if", true),
                    createCommentVNode(" ACTIONS "),
                    createElementVNode("div", {
                      class: normalizeClass([unref(ns).e("btn"), unref(ns).e("actions")])
                    }, [
                      createElementVNode("div", {
                        class: normalizeClass(unref(ns).e("actions__inner"))
                      }, [
                        createVNode(unref(ElIcon), {
                          onClick: _cache[1] || (_cache[1] = ($event) => handleActions("zoomOut"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_out_default))
                          ]),
                          _: 1
                        }),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[2] || (_cache[2] = ($event) => handleActions("zoomIn"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_in_default))
                          ]),
                          _: 1
                        }),
                        createElementVNode("i", {
                          class: normalizeClass(unref(ns).e("actions__divider"))
                        }, null, 2),
                        createVNode(unref(ElIcon), { onClick: toggleMode }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(unref(mode).icon)))
                          ]),
                          _: 1
                        }),
                        createElementVNode("i", {
                          class: normalizeClass(unref(ns).e("actions__divider"))
                        }, null, 2),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[3] || (_cache[3] = ($event) => handleActions("anticlockwise"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(refresh_left_default))
                          ]),
                          _: 1
                        }),
                        createVNode(unref(ElIcon), {
                          onClick: _cache[4] || (_cache[4] = ($event) => handleActions("clockwise"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(refresh_right_default))
                          ]),
                          _: 1
                        })
                      ], 2)
                    ], 2),
                    createCommentVNode(" CANVAS "),
                    createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("canvas"))
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.urlList, (url2, i) => {
                        return withDirectives((openBlock(), createElementBlock("img", {
                          ref_for: true,
                          ref: (el) => imgRefs.value[i] = el,
                          key: url2,
                          src: url2,
                          style: normalizeStyle(unref(imgStyle)),
                          class: normalizeClass(unref(ns).e("img")),
                          crossorigin: _ctx.crossorigin,
                          onLoad: handleImgLoad,
                          onError: handleImgError,
                          onMousedown: handleMouseDown
                        }, null, 46, _hoisted_1$t)), [
                          [vShow, i === activeIndex.value]
                        ]);
                      }), 128))
                    ], 2),
                    renderSlot(_ctx.$slots, "default")
                  ], 6)
                ]),
                _: 3
              })
            ], 8, ["disabled"]);
          };
        }
      });
      var ImageViewer = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["__file", "image-viewer.vue"]]);
      const ElImageViewer = withInstall(ImageViewer);
      const imageProps = buildProps({
        hideOnClickModal: Boolean,
        src: {
          type: String,
          default: ""
        },
        fit: {
          type: String,
          values: ["", "contain", "cover", "fill", "none", "scale-down"],
          default: ""
        },
        loading: {
          type: String,
          values: ["eager", "lazy"]
        },
        lazy: Boolean,
        scrollContainer: {
          type: definePropType([String, Object])
        },
        previewSrcList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        previewTeleported: Boolean,
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        },
        minScale: {
          type: Number,
          default: 0.2
        },
        maxScale: {
          type: Number,
          default: 7
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const imageEmits = {
        load: (evt) => evt instanceof Event,
        error: (evt) => evt instanceof Event,
        switch: (val) => isNumber(val),
        close: () => true,
        show: () => true
      };
      const _hoisted_1$s = ["src", "loading", "crossorigin"];
      const _hoisted_2$l = { key: 0 };
      const __default__$f = defineComponent({
        name: "ElImage",
        inheritAttrs: false
      });
      const _sfc_main$C = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        props: imageProps,
        emits: imageEmits,
        setup(__props, { emit }) {
          const props = __props;
          let prevOverflow = "";
          const { t } = useLocale();
          const ns = useNamespace("image");
          const rawAttrs = useAttrs$1();
          const attrs = useAttrs();
          const imageSrc = ref();
          const hasLoadError = ref(false);
          const isLoading = ref(true);
          const showViewer = ref(false);
          const container = ref();
          const _scrollContainer = ref();
          const supportLoading = isClient && "loading" in HTMLImageElement.prototype;
          let stopScrollListener;
          let stopWheelListener;
          const imageKls = computed$1(() => [
            ns.e("inner"),
            preview.value && ns.e("preview"),
            isLoading.value && ns.is("loading")
          ]);
          const containerStyle = computed$1(() => rawAttrs.style);
          const imageStyle = computed$1(() => {
            const { fit } = props;
            if (isClient && fit) {
              return { objectFit: fit };
            }
            return {};
          });
          const preview = computed$1(() => {
            const { previewSrcList } = props;
            return Array.isArray(previewSrcList) && previewSrcList.length > 0;
          });
          const imageIndex = computed$1(() => {
            const { previewSrcList, initialIndex } = props;
            let previewIndex = initialIndex;
            if (initialIndex > previewSrcList.length - 1) {
              previewIndex = 0;
            }
            return previewIndex;
          });
          const isManual = computed$1(() => {
            if (props.loading === "eager")
              return false;
            return !supportLoading && props.loading === "lazy" || props.lazy;
          });
          const loadImage = () => {
            if (!isClient)
              return;
            isLoading.value = true;
            hasLoadError.value = false;
            imageSrc.value = props.src;
          };
          function handleLoad(event) {
            isLoading.value = false;
            hasLoadError.value = false;
            emit("load", event);
          }
          function handleError(event) {
            isLoading.value = false;
            hasLoadError.value = true;
            emit("error", event);
          }
          function handleLazyLoad() {
            if (isInContainer(container.value, _scrollContainer.value)) {
              loadImage();
              removeLazyLoadListener();
            }
          }
          const lazyLoadHandler = useThrottleFn(handleLazyLoad, 200, true);
          async function addLazyLoadListener() {
            var _a;
            if (!isClient)
              return;
            await nextTick();
            const { scrollContainer } = props;
            if (isElement(scrollContainer)) {
              _scrollContainer.value = scrollContainer;
            } else if (isString(scrollContainer) && scrollContainer !== "") {
              _scrollContainer.value = (_a = document.querySelector(scrollContainer)) != null ? _a : void 0;
            } else if (container.value) {
              _scrollContainer.value = getScrollContainer(container.value);
            }
            if (_scrollContainer.value) {
              stopScrollListener = useEventListener(_scrollContainer, "scroll", lazyLoadHandler);
              setTimeout(() => handleLazyLoad(), 100);
            }
          }
          function removeLazyLoadListener() {
            if (!isClient || !_scrollContainer.value || !lazyLoadHandler)
              return;
            stopScrollListener == null ? void 0 : stopScrollListener();
            _scrollContainer.value = void 0;
          }
          function wheelHandler(e) {
            if (!e.ctrlKey)
              return;
            if (e.deltaY < 0) {
              e.preventDefault();
              return false;
            } else if (e.deltaY > 0) {
              e.preventDefault();
              return false;
            }
          }
          function clickHandler() {
            if (!preview.value)
              return;
            stopWheelListener = useEventListener("wheel", wheelHandler, {
              passive: false
            });
            prevOverflow = document.body.style.overflow;
            document.body.style.overflow = "hidden";
            showViewer.value = true;
            emit("show");
          }
          function closeViewer() {
            stopWheelListener == null ? void 0 : stopWheelListener();
            document.body.style.overflow = prevOverflow;
            showViewer.value = false;
            emit("close");
          }
          function switchViewer(val) {
            emit("switch", val);
          }
          watch(() => props.src, () => {
            if (isManual.value) {
              isLoading.value = true;
              hasLoadError.value = false;
              removeLazyLoadListener();
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          onMounted(() => {
            if (isManual.value) {
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "container",
              ref: container,
              class: normalizeClass([unref(ns).b(), _ctx.$attrs.class]),
              style: normalizeStyle(unref(containerStyle))
            }, [
              hasLoadError.value ? renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("error"))
                }, toDisplayString(unref(t)("el.image.error")), 3)
              ]) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                imageSrc.value !== void 0 ? (openBlock(), createElementBlock("img", mergeProps({ key: 0 }, unref(attrs), {
                  src: imageSrc.value,
                  loading: _ctx.loading,
                  style: unref(imageStyle),
                  class: unref(imageKls),
                  crossorigin: _ctx.crossorigin,
                  onClick: clickHandler,
                  onLoad: handleLoad,
                  onError: handleError
                }), null, 16, _hoisted_1$s)) : createCommentVNode("v-if", true),
                isLoading.value ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(ns).e("wrapper"))
                }, [
                  renderSlot(_ctx.$slots, "placeholder", {}, () => [
                    createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("placeholder"))
                    }, null, 2)
                  ])
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)),
              unref(preview) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                showViewer.value ? (openBlock(), createBlock(unref(ElImageViewer), {
                  key: 0,
                  "z-index": _ctx.zIndex,
                  "initial-index": unref(imageIndex),
                  infinite: _ctx.infinite,
                  "zoom-rate": _ctx.zoomRate,
                  "min-scale": _ctx.minScale,
                  "max-scale": _ctx.maxScale,
                  "url-list": _ctx.previewSrcList,
                  "hide-on-click-modal": _ctx.hideOnClickModal,
                  teleported: _ctx.previewTeleported,
                  "close-on-press-escape": _ctx.closeOnPressEscape,
                  onClose: closeViewer,
                  onSwitch: switchViewer
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.viewer ? (openBlock(), createElementBlock("div", _hoisted_2$l, [
                      renderSlot(_ctx.$slots, "viewer")
                    ])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : createCommentVNode("v-if", true)
              ], 64)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var Image = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["__file", "image.vue"]]);
      const ElImage = withInstall(Image);
      const inputNumberProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        step: {
          type: Number,
          default: 1
        },
        stepStrictly: Boolean,
        max: {
          type: Number,
          default: Number.POSITIVE_INFINITY
        },
        min: {
          type: Number,
          default: Number.NEGATIVE_INFINITY
        },
        modelValue: Number,
        readonly: Boolean,
        disabled: Boolean,
        size: useSizeProp,
        controls: {
          type: Boolean,
          default: true
        },
        controlsPosition: {
          type: String,
          default: "",
          values: ["", "right"]
        },
        valueOnClear: {
          type: [String, Number, null],
          validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
          default: null
        },
        name: String,
        label: String,
        placeholder: String,
        precision: {
          type: Number,
          validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const inputNumberEmits = {
        [CHANGE_EVENT]: (cur, prev) => prev !== cur,
        blur: (e) => e instanceof FocusEvent,
        focus: (e) => e instanceof FocusEvent,
        [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
        [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
      };
      const _hoisted_1$r = ["aria-label", "onKeydown"];
      const _hoisted_2$k = ["aria-label", "onKeydown"];
      const __default__$e = defineComponent({
        name: "ElInputNumber"
      });
      const _sfc_main$B = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        props: inputNumberProps,
        emits: inputNumberEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("input-number");
          const input = ref();
          const data = reactive({
            currentValue: props.modelValue,
            userInput: null
          });
          const { formItem } = useFormItem();
          const minDisabled = computed$1(() => isNumber(props.modelValue) && props.modelValue <= props.min);
          const maxDisabled = computed$1(() => isNumber(props.modelValue) && props.modelValue >= props.max);
          const numPrecision = computed$1(() => {
            const stepPrecision = getPrecision(props.step);
            if (!isUndefined$1(props.precision)) {
              if (stepPrecision > props.precision)
                ;
              return props.precision;
            } else {
              return Math.max(getPrecision(props.modelValue), stepPrecision);
            }
          });
          const controlsAtRight = computed$1(() => {
            return props.controls && props.controlsPosition === "right";
          });
          const inputNumberSize = useFormSize();
          const inputNumberDisabled = useFormDisabled();
          const displayValue = computed$1(() => {
            if (data.userInput !== null) {
              return data.userInput;
            }
            let currentValue = data.currentValue;
            if (isNil(currentValue))
              return "";
            if (isNumber(currentValue)) {
              if (Number.isNaN(currentValue))
                return "";
              if (!isUndefined$1(props.precision)) {
                currentValue = currentValue.toFixed(props.precision);
              }
            }
            return currentValue;
          });
          const toPrecision = (num, pre) => {
            if (isUndefined$1(pre))
              pre = numPrecision.value;
            if (pre === 0)
              return Math.round(num);
            let snum = String(num);
            const pointPos = snum.indexOf(".");
            if (pointPos === -1)
              return num;
            const nums = snum.replace(".", "").split("");
            const datum = nums[pointPos + pre];
            if (!datum)
              return num;
            const length = snum.length;
            if (snum.charAt(length - 1) === "5") {
              snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
            }
            return Number.parseFloat(Number(snum).toFixed(pre));
          };
          const getPrecision = (value) => {
            if (isNil(value))
              return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) {
              precision = valueString.length - dotPosition - 1;
            }
            return precision;
          };
          const ensurePrecision = (val, coefficient = 1) => {
            if (!isNumber(val))
              return data.currentValue;
            return toPrecision(val + props.step * coefficient);
          };
          const increase = () => {
            if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value);
            setCurrentValue(newVal);
            emit(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const decrease = () => {
            if (props.readonly || inputNumberDisabled.value || minDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value, -1);
            setCurrentValue(newVal);
            emit(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const verifyValue = (value, update) => {
            const { max, min, step, precision, stepStrictly, valueOnClear } = props;
            if (max < min) {
              throwError("InputNumber", "min should not be greater than max.");
            }
            let newVal = Number(value);
            if (isNil(value) || Number.isNaN(newVal)) {
              return null;
            }
            if (value === "") {
              if (valueOnClear === null) {
                return null;
              }
              newVal = isString(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
            }
            if (stepStrictly) {
              newVal = toPrecision(Math.round(newVal / step) * step, precision);
            }
            if (!isUndefined$1(precision)) {
              newVal = toPrecision(newVal, precision);
            }
            if (newVal > max || newVal < min) {
              newVal = newVal > max ? max : min;
              update && emit(UPDATE_MODEL_EVENT, newVal);
            }
            return newVal;
          };
          const setCurrentValue = (value, emitChange = true) => {
            var _a;
            const oldVal = data.currentValue;
            const newVal = verifyValue(value);
            if (!emitChange) {
              emit(UPDATE_MODEL_EVENT, newVal);
              return;
            }
            if (oldVal === newVal && value)
              return;
            data.userInput = null;
            emit(UPDATE_MODEL_EVENT, newVal);
            if (oldVal !== newVal) {
              emit(CHANGE_EVENT, newVal, oldVal);
            }
            if (props.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch((err) => debugWarn());
            }
            data.currentValue = newVal;
          };
          const handleInput = (value) => {
            data.userInput = value;
            const newVal = value === "" ? null : Number(value);
            emit(INPUT_EVENT, newVal);
            setCurrentValue(newVal, false);
          };
          const handleInputChange = (value) => {
            const newVal = value !== "" ? Number(value) : "";
            if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
              setCurrentValue(newVal);
            }
            setCurrentValueToModelValue();
            data.userInput = null;
          };
          const focus = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
          };
          const blur = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
          };
          const handleFocus = (event) => {
            emit("focus", event);
          };
          const handleBlur = (event) => {
            var _a;
            data.userInput = null;
            emit("blur", event);
            if (props.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "blur").catch((err) => debugWarn());
            }
          };
          const setCurrentValueToModelValue = () => {
            if (data.currentValue !== props.modelValue) {
              data.currentValue = props.modelValue;
            }
          };
          const handleWheel = (e) => {
            if (document.activeElement === e.target)
              e.preventDefault();
          };
          watch(() => props.modelValue, (value, oldValue) => {
            const newValue = verifyValue(value, true);
            if (data.userInput === null && newValue !== oldValue) {
              data.currentValue = newValue;
            }
          }, { immediate: true });
          onMounted(() => {
            var _a;
            const { min, max, modelValue } = props;
            const innerInput = (_a = input.value) == null ? void 0 : _a.input;
            innerInput.setAttribute("role", "spinbutton");
            if (Number.isFinite(max)) {
              innerInput.setAttribute("aria-valuemax", String(max));
            } else {
              innerInput.removeAttribute("aria-valuemax");
            }
            if (Number.isFinite(min)) {
              innerInput.setAttribute("aria-valuemin", String(min));
            } else {
              innerInput.removeAttribute("aria-valuemin");
            }
            innerInput.setAttribute("aria-valuenow", data.currentValue || data.currentValue === 0 ? String(data.currentValue) : "");
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!isNumber(modelValue) && modelValue != null) {
              let val = Number(modelValue);
              if (Number.isNaN(val)) {
                val = null;
              }
              emit(UPDATE_MODEL_EVENT, val);
            }
          });
          onUpdated(() => {
            var _a, _b;
            const innerInput = (_a = input.value) == null ? void 0 : _a.input;
            innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${(_b = data.currentValue) != null ? _b : ""}`);
          });
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(unref(inputNumberSize)),
                unref(ns).is("disabled", unref(inputNumberDisabled)),
                unref(ns).is("without-controls", !_ctx.controls),
                unref(ns).is("controls-right", unref(controlsAtRight))
              ]),
              onDragstart: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["prevent"]))
            }, [
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 0,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.decrease"),
                class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
                onKeydown: withKeys(decrease, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "decrease-icon", {}, () => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, _hoisted_1$r)), [
                [unref(vRepeatClick), decrease]
              ]) : createCommentVNode("v-if", true),
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 1,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.increase"),
                class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
                onKeydown: withKeys(increase, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "increase-icon", {}, () => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, _hoisted_2$k)), [
                [unref(vRepeatClick), increase]
              ]) : createCommentVNode("v-if", true),
              createVNode(unref(ElInput), {
                id: _ctx.id,
                ref_key: "input",
                ref: input,
                type: "number",
                step: _ctx.step,
                "model-value": unref(displayValue),
                placeholder: _ctx.placeholder,
                readonly: _ctx.readonly,
                disabled: unref(inputNumberDisabled),
                size: unref(inputNumberSize),
                max: _ctx.max,
                min: _ctx.min,
                name: _ctx.name,
                label: _ctx.label,
                "validate-event": false,
                onWheel: handleWheel,
                onKeydown: [
                  withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                  withKeys(withModifiers(decrease, ["prevent"]), ["down"])
                ],
                onBlur: handleBlur,
                onFocus: handleFocus,
                onInput: handleInput,
                onChange: handleInputChange
              }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
            ], 34);
          };
        }
      });
      var InputNumber = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["__file", "input-number.vue"]]);
      const ElInputNumber = withInstall(InputNumber);
      const linkProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "warning", "info", "danger", "default"],
          default: "default"
        },
        underline: {
          type: Boolean,
          default: true
        },
        disabled: { type: Boolean, default: false },
        href: { type: String, default: "" },
        target: {
          type: String,
          default: "_self"
        },
        icon: {
          type: iconPropType
        }
      });
      const linkEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const _hoisted_1$q = ["href", "target"];
      const __default__$d = defineComponent({
        name: "ElLink"
      });
      const _sfc_main$A = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: linkProps,
        emits: linkEmits,
        setup(__props, { emit }) {
          const props = __props;
          const ns = useNamespace("link");
          const linkKls = computed$1(() => [
            ns.b(),
            ns.m(props.type),
            ns.is("disabled", props.disabled),
            ns.is("underline", props.underline && !props.disabled)
          ]);
          function handleClick(event) {
            if (!props.disabled)
              emit("click", event);
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("a", {
              class: normalizeClass(unref(linkKls)),
              href: _ctx.disabled || !_ctx.href ? void 0 : _ctx.href,
              target: _ctx.disabled || !_ctx.href ? void 0 : _ctx.target,
              onClick: handleClick
            }, [
              _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                key: 1,
                class: normalizeClass(unref(ns).e("inner"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true),
              _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 2 }) : createCommentVNode("v-if", true)
            ], 10, _hoisted_1$q);
          };
        }
      });
      var Link = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["__file", "link.vue"]]);
      const ElLink = withInstall(Link);
      let SubMenu$1 = class SubMenu {
        constructor(parent, domNode) {
          this.parent = parent;
          this.domNode = domNode;
          this.subIndex = 0;
          this.subIndex = 0;
          this.init();
        }
        init() {
          this.subMenuItems = this.domNode.querySelectorAll("li");
          this.addListeners();
        }
        gotoSubIndex(idx) {
          if (idx === this.subMenuItems.length) {
            idx = 0;
          } else if (idx < 0) {
            idx = this.subMenuItems.length - 1;
          }
          this.subMenuItems[idx].focus();
          this.subIndex = idx;
        }
        addListeners() {
          const parentNode = this.parent.domNode;
          Array.prototype.forEach.call(this.subMenuItems, (el) => {
            el.addEventListener("keydown", (event) => {
              let prevDef = false;
              switch (event.code) {
                case EVENT_CODE.down: {
                  this.gotoSubIndex(this.subIndex + 1);
                  prevDef = true;
                  break;
                }
                case EVENT_CODE.up: {
                  this.gotoSubIndex(this.subIndex - 1);
                  prevDef = true;
                  break;
                }
                case EVENT_CODE.tab: {
                  triggerEvent(parentNode, "mouseleave");
                  break;
                }
                case EVENT_CODE.enter:
                case EVENT_CODE.space: {
                  prevDef = true;
                  event.currentTarget.click();
                  break;
                }
              }
              if (prevDef) {
                event.preventDefault();
                event.stopPropagation();
              }
              return false;
            });
          });
        }
      };
      let MenuItem$1 = class MenuItem {
        constructor(domNode, namespace) {
          this.domNode = domNode;
          this.submenu = null;
          this.submenu = null;
          this.init(namespace);
        }
        init(namespace) {
          this.domNode.setAttribute("tabindex", "0");
          const menuChild = this.domNode.querySelector(`.${namespace}-menu`);
          if (menuChild) {
            this.submenu = new SubMenu$1(this, menuChild);
          }
          this.addListeners();
        }
        addListeners() {
          this.domNode.addEventListener("keydown", (event) => {
            let prevDef = false;
            switch (event.code) {
              case EVENT_CODE.down: {
                triggerEvent(event.currentTarget, "mouseenter");
                this.submenu && this.submenu.gotoSubIndex(0);
                prevDef = true;
                break;
              }
              case EVENT_CODE.up: {
                triggerEvent(event.currentTarget, "mouseenter");
                this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
                prevDef = true;
                break;
              }
              case EVENT_CODE.tab: {
                triggerEvent(event.currentTarget, "mouseleave");
                break;
              }
              case EVENT_CODE.enter:
              case EVENT_CODE.space: {
                prevDef = true;
                event.currentTarget.click();
                break;
              }
            }
            if (prevDef) {
              event.preventDefault();
            }
          });
        }
      };
      let Menu$1 = class Menu {
        constructor(domNode, namespace) {
          this.domNode = domNode;
          this.init(namespace);
        }
        init(namespace) {
          const menuChildren = this.domNode.childNodes;
          Array.from(menuChildren).forEach((child) => {
            if (child.nodeType === 1) {
              new MenuItem$1(child, namespace);
            }
          });
        }
      };
      const _sfc_main$z = defineComponent({
        name: "ElMenuCollapseTransition",
        setup() {
          const ns = useNamespace("menu");
          const listeners = {
            onBeforeEnter: (el) => el.style.opacity = "0.2",
            onEnter(el, done) {
              addClass(el, `${ns.namespace.value}-opacity-transition`);
              el.style.opacity = "1";
              done();
            },
            onAfterEnter(el) {
              removeClass(el, `${ns.namespace.value}-opacity-transition`);
              el.style.opacity = "";
            },
            onBeforeLeave(el) {
              if (!el.dataset) {
                el.dataset = {};
              }
              if (hasClass(el, ns.m("collapse"))) {
                removeClass(el, ns.m("collapse"));
                el.dataset.oldOverflow = el.style.overflow;
                el.dataset.scrollWidth = el.clientWidth.toString();
                addClass(el, ns.m("collapse"));
              } else {
                addClass(el, ns.m("collapse"));
                el.dataset.oldOverflow = el.style.overflow;
                el.dataset.scrollWidth = el.clientWidth.toString();
                removeClass(el, ns.m("collapse"));
              }
              el.style.width = `${el.scrollWidth}px`;
              el.style.overflow = "hidden";
            },
            onLeave(el) {
              addClass(el, "horizontal-collapse-transition");
              el.style.width = `${el.dataset.scrollWidth}px`;
            }
          };
          return {
            listeners
          };
        }
      });
      function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createBlock(Transition, mergeProps({ mode: "out-in" }, _ctx.listeners), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16);
      }
      var ElMenuCollapseTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["render", _sfc_render$f], ["__file", "menu-collapse-transition.vue"]]);
      function useMenu(instance, currentIndex) {
        const indexPath = computed$1(() => {
          let parent = instance.parent;
          const path = [currentIndex.value];
          while (parent.type.name !== "ElMenu") {
            if (parent.props.index) {
              path.unshift(parent.props.index);
            }
            parent = parent.parent;
          }
          return path;
        });
        const parentMenu = computed$1(() => {
          let parent = instance.parent;
          while (parent && !["ElMenu", "ElSubMenu"].includes(parent.type.name)) {
            parent = parent.parent;
          }
          return parent;
        });
        return {
          parentMenu,
          indexPath
        };
      }
      function useMenuColor(props) {
        const menuBarColor = computed$1(() => {
          const color = props.backgroundColor;
          if (!color) {
            return "";
          } else {
            return new TinyColor(color).shade(20).toString();
          }
        });
        return menuBarColor;
      }
      const useMenuCssVar = (props, level) => {
        const ns = useNamespace("menu");
        return computed$1(() => {
          return ns.cssVarBlock({
            "text-color": props.textColor || "",
            "hover-text-color": props.textColor || "",
            "bg-color": props.backgroundColor || "",
            "hover-bg-color": useMenuColor(props).value || "",
            "active-color": props.activeTextColor || "",
            level: `${level}`
          });
        });
      };
      const subMenuProps = buildProps({
        index: {
          type: String,
          required: true
        },
        showTimeout: Number,
        hideTimeout: Number,
        popperClass: String,
        disabled: Boolean,
        teleported: {
          type: Boolean,
          default: void 0
        },
        popperOffset: Number,
        expandCloseIcon: {
          type: iconPropType
        },
        expandOpenIcon: {
          type: iconPropType
        },
        collapseCloseIcon: {
          type: iconPropType
        },
        collapseOpenIcon: {
          type: iconPropType
        }
      });
      const COMPONENT_NAME$5 = "ElSubMenu";
      var SubMenu2 = defineComponent({
        name: COMPONENT_NAME$5,
        props: subMenuProps,
        setup(props, { slots, expose }) {
          const instance = getCurrentInstance();
          const { indexPath, parentMenu } = useMenu(instance, computed$1(() => props.index));
          const nsMenu = useNamespace("menu");
          const nsSubMenu = useNamespace("sub-menu");
          const rootMenu = inject("rootMenu");
          if (!rootMenu)
            throwError(COMPONENT_NAME$5, "can not inject root menu");
          const subMenu = inject(`subMenu:${parentMenu.value.uid}`);
          if (!subMenu)
            throwError(COMPONENT_NAME$5, "can not inject sub menu");
          const items = ref({});
          const subMenus = ref({});
          let timeout;
          const mouseInChild = ref(false);
          const verticalTitleRef = ref();
          const vPopper = ref(null);
          const currentPlacement = computed$1(() => mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start");
          const subMenuTitleIcon = computed$1(() => {
            return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootMenu.props.collapse ? props.expandCloseIcon && props.expandOpenIcon ? opened.value ? props.expandOpenIcon : props.expandCloseIcon : arrow_down_default : props.collapseCloseIcon && props.collapseOpenIcon ? opened.value ? props.collapseOpenIcon : props.collapseCloseIcon : arrow_right_default;
          });
          const isFirstLevel = computed$1(() => {
            return subMenu.level === 0;
          });
          const appendToBody = computed$1(() => {
            const value = props.teleported;
            return value === void 0 ? isFirstLevel.value : value;
          });
          const menuTransitionName = computed$1(() => rootMenu.props.collapse ? `${nsMenu.namespace.value}-zoom-in-left` : `${nsMenu.namespace.value}-zoom-in-top`);
          const fallbackPlacements = computed$1(() => mode.value === "horizontal" && isFirstLevel.value ? [
            "bottom-start",
            "bottom-end",
            "top-start",
            "top-end",
            "right-start",
            "left-start"
          ] : [
            "right-start",
            "right",
            "right-end",
            "left-start",
            "bottom-start",
            "bottom-end",
            "top-start",
            "top-end"
          ]);
          const opened = computed$1(() => rootMenu.openedMenus.includes(props.index));
          const active = computed$1(() => {
            let isActive = false;
            Object.values(items.value).forEach((item2) => {
              if (item2.active) {
                isActive = true;
              }
            });
            Object.values(subMenus.value).forEach((subItem) => {
              if (subItem.active) {
                isActive = true;
              }
            });
            return isActive;
          });
          const mode = computed$1(() => rootMenu.props.mode);
          const item = reactive({
            index: props.index,
            indexPath,
            active
          });
          const ulStyle = useMenuCssVar(rootMenu.props, subMenu.level + 1);
          const subMenuPopperOffset = computed$1(() => {
            var _a;
            return (_a = props.popperOffset) != null ? _a : rootMenu.props.popperOffset;
          });
          const subMenuPopperClass = computed$1(() => {
            var _a;
            return (_a = props.popperClass) != null ? _a : rootMenu.props.popperClass;
          });
          const subMenuShowTimeout = computed$1(() => {
            var _a;
            return (_a = props.showTimeout) != null ? _a : rootMenu.props.showTimeout;
          });
          const subMenuHideTimeout = computed$1(() => {
            var _a;
            return (_a = props.hideTimeout) != null ? _a : rootMenu.props.hideTimeout;
          });
          const doDestroy = () => {
            var _a, _b, _c;
            return (_c = (_b = (_a = vPopper.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.popperInstanceRef) == null ? void 0 : _c.destroy();
          };
          const handleCollapseToggle = (value) => {
            if (!value) {
              doDestroy();
            }
          };
          const handleClick = () => {
            if (rootMenu.props.menuTrigger === "hover" && rootMenu.props.mode === "horizontal" || rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled)
              return;
            rootMenu.handleSubMenuClick({
              index: props.index,
              indexPath: indexPath.value,
              active: active.value
            });
          };
          const handleMouseenter = (event, showTimeout = subMenuShowTimeout.value) => {
            var _a;
            if (event.type === "focus") {
              return;
            }
            if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled) {
              subMenu.mouseInChild.value = true;
              return;
            }
            subMenu.mouseInChild.value = true;
            timeout == null ? void 0 : timeout();
            ({ stop: timeout } = useTimeoutFn(() => {
              rootMenu.openMenu(props.index, indexPath.value);
            }, showTimeout));
            if (appendToBody.value) {
              (_a = parentMenu.value.vnode.el) == null ? void 0 : _a.dispatchEvent(new MouseEvent("mouseenter"));
            }
          };
          const handleMouseleave = (deepDispatch = false) => {
            var _a;
            if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical") {
              subMenu.mouseInChild.value = false;
              return;
            }
            timeout == null ? void 0 : timeout();
            subMenu.mouseInChild.value = false;
            ({ stop: timeout } = useTimeoutFn(() => !mouseInChild.value && rootMenu.closeMenu(props.index, indexPath.value), subMenuHideTimeout.value));
            if (appendToBody.value && deepDispatch) {
              (_a = subMenu.handleMouseleave) == null ? void 0 : _a.call(subMenu, true);
            }
          };
          watch(() => rootMenu.props.collapse, (value) => handleCollapseToggle(Boolean(value)));
          {
            const addSubMenu = (item2) => {
              subMenus.value[item2.index] = item2;
            };
            const removeSubMenu = (item2) => {
              delete subMenus.value[item2.index];
            };
            provide(`subMenu:${instance.uid}`, {
              addSubMenu,
              removeSubMenu,
              handleMouseleave,
              mouseInChild,
              level: subMenu.level + 1
            });
          }
          expose({
            opened
          });
          onMounted(() => {
            rootMenu.addSubMenu(item);
            subMenu.addSubMenu(item);
          });
          onBeforeUnmount(() => {
            subMenu.removeSubMenu(item);
            rootMenu.removeSubMenu(item);
          });
          return () => {
            var _a;
            const titleTag = [
              (_a = slots.title) == null ? void 0 : _a.call(slots),
              h$1(ElIcon, {
                class: nsSubMenu.e("icon-arrow"),
                style: {
                  transform: opened.value ? props.expandCloseIcon && props.expandOpenIcon || props.collapseCloseIcon && props.collapseOpenIcon && rootMenu.props.collapse ? "none" : "rotateZ(180deg)" : "none"
                }
              }, {
                default: () => isString(subMenuTitleIcon.value) ? h$1(instance.appContext.components[subMenuTitleIcon.value]) : h$1(subMenuTitleIcon.value)
              })
            ];
            const child = rootMenu.isMenuPopup ? h$1(ElTooltip, {
              ref: vPopper,
              visible: opened.value,
              effect: "light",
              pure: true,
              offset: subMenuPopperOffset.value,
              showArrow: false,
              persistent: true,
              popperClass: subMenuPopperClass.value,
              placement: currentPlacement.value,
              teleported: appendToBody.value,
              fallbackPlacements: fallbackPlacements.value,
              transition: menuTransitionName.value,
              gpuAcceleration: false
            }, {
              content: () => {
                var _a2;
                return h$1("div", {
                  class: [
                    nsMenu.m(mode.value),
                    nsMenu.m("popup-container"),
                    subMenuPopperClass.value
                  ],
                  onMouseenter: (evt) => handleMouseenter(evt, 100),
                  onMouseleave: () => handleMouseleave(true),
                  onFocus: (evt) => handleMouseenter(evt, 100)
                }, [
                  h$1("ul", {
                    class: [
                      nsMenu.b(),
                      nsMenu.m("popup"),
                      nsMenu.m(`popup-${currentPlacement.value}`)
                    ],
                    style: ulStyle.value
                  }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])
                ]);
              },
              default: () => h$1("div", {
                class: nsSubMenu.e("title"),
                onClick: handleClick
              }, titleTag)
            }) : h$1(Fragment, {}, [
              h$1("div", {
                class: nsSubMenu.e("title"),
                ref: verticalTitleRef,
                onClick: handleClick
              }, titleTag),
              h$1(_CollapseTransition, {}, {
                default: () => {
                  var _a2;
                  return withDirectives(h$1("ul", {
                    role: "menu",
                    class: [nsMenu.b(), nsMenu.m("inline")],
                    style: ulStyle.value
                  }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), [[vShow, opened.value]]);
                }
              })
            ]);
            return h$1("li", {
              class: [
                nsSubMenu.b(),
                nsSubMenu.is("active", active.value),
                nsSubMenu.is("opened", opened.value),
                nsSubMenu.is("disabled", props.disabled)
              ],
              role: "menuitem",
              ariaHaspopup: true,
              ariaExpanded: opened.value,
              onMouseenter: handleMouseenter,
              onMouseleave: () => handleMouseleave(),
              onFocus: handleMouseenter
            }, [child]);
          };
        }
      });
      const menuProps = buildProps({
        mode: {
          type: String,
          values: ["horizontal", "vertical"],
          default: "vertical"
        },
        defaultActive: {
          type: String,
          default: ""
        },
        defaultOpeneds: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        uniqueOpened: Boolean,
        router: Boolean,
        menuTrigger: {
          type: String,
          values: ["hover", "click"],
          default: "hover"
        },
        collapse: Boolean,
        backgroundColor: String,
        textColor: String,
        activeTextColor: String,
        closeOnClickOutside: Boolean,
        collapseTransition: {
          type: Boolean,
          default: true
        },
        ellipsis: {
          type: Boolean,
          default: true
        },
        popperOffset: {
          type: Number,
          default: 6
        },
        ellipsisIcon: {
          type: iconPropType,
          default: () => more_default
        },
        popperEffect: {
          type: String,
          values: ["dark", "light"],
          default: "dark"
        },
        popperClass: String,
        showTimeout: {
          type: Number,
          default: 300
        },
        hideTimeout: {
          type: Number,
          default: 300
        }
      });
      const checkIndexPath = (indexPath) => Array.isArray(indexPath) && indexPath.every((path) => isString(path));
      const menuEmits = {
        close: (index, indexPath) => isString(index) && checkIndexPath(indexPath),
        open: (index, indexPath) => isString(index) && checkIndexPath(indexPath),
        select: (index, indexPath, item, routerResult) => isString(index) && checkIndexPath(indexPath) && isObject$1(item) && (routerResult === void 0 || routerResult instanceof Promise)
      };
      var Menu2 = defineComponent({
        name: "ElMenu",
        props: menuProps,
        emits: menuEmits,
        setup(props, { emit, slots, expose }) {
          const instance = getCurrentInstance();
          const router = instance.appContext.config.globalProperties.$router;
          const menu = ref();
          const nsMenu = useNamespace("menu");
          const nsSubMenu = useNamespace("sub-menu");
          const sliceIndex = ref(-1);
          const openedMenus = ref(props.defaultOpeneds && !props.collapse ? props.defaultOpeneds.slice(0) : []);
          const activeIndex = ref(props.defaultActive);
          const items = ref({});
          const subMenus = ref({});
          const isMenuPopup = computed$1(() => {
            return props.mode === "horizontal" || props.mode === "vertical" && props.collapse;
          });
          const initMenu = () => {
            const activeItem = activeIndex.value && items.value[activeIndex.value];
            if (!activeItem || props.mode === "horizontal" || props.collapse)
              return;
            const indexPath = activeItem.indexPath;
            indexPath.forEach((index) => {
              const subMenu = subMenus.value[index];
              subMenu && openMenu(index, subMenu.indexPath);
            });
          };
          const openMenu = (index, indexPath) => {
            if (openedMenus.value.includes(index))
              return;
            if (props.uniqueOpened) {
              openedMenus.value = openedMenus.value.filter((index2) => indexPath.includes(index2));
            }
            openedMenus.value.push(index);
            emit("open", index, indexPath);
          };
          const close = (index) => {
            const i = openedMenus.value.indexOf(index);
            if (i !== -1) {
              openedMenus.value.splice(i, 1);
            }
          };
          const closeMenu = (index, indexPath) => {
            close(index);
            emit("close", index, indexPath);
          };
          const handleSubMenuClick = ({
            index,
            indexPath
          }) => {
            const isOpened = openedMenus.value.includes(index);
            if (isOpened) {
              closeMenu(index, indexPath);
            } else {
              openMenu(index, indexPath);
            }
          };
          const handleMenuItemClick = (menuItem) => {
            if (props.mode === "horizontal" || props.collapse) {
              openedMenus.value = [];
            }
            const { index, indexPath } = menuItem;
            if (isNil(index) || isNil(indexPath))
              return;
            if (props.router && router) {
              const route = menuItem.route || index;
              const routerResult = router.push(route).then((res) => {
                if (!res)
                  activeIndex.value = index;
                return res;
              });
              emit("select", index, indexPath, { index, indexPath, route }, routerResult);
            } else {
              activeIndex.value = index;
              emit("select", index, indexPath, { index, indexPath });
            }
          };
          const updateActiveIndex = (val) => {
            const itemsInData = items.value;
            const item = itemsInData[val] || activeIndex.value && itemsInData[activeIndex.value] || itemsInData[props.defaultActive];
            if (item) {
              activeIndex.value = item.index;
            } else {
              activeIndex.value = val;
            }
          };
          const calcMenuItemWidth = (menuItem) => {
            const computedStyle = getComputedStyle(menuItem);
            const marginLeft = Number.parseInt(computedStyle.marginLeft, 10);
            const marginRight = Number.parseInt(computedStyle.marginRight, 10);
            return menuItem.offsetWidth + marginLeft + marginRight || 0;
          };
          const calcSliceIndex = () => {
            var _a, _b;
            if (!menu.value)
              return -1;
            const items2 = Array.from((_b = (_a = menu.value) == null ? void 0 : _a.childNodes) != null ? _b : []).filter((item) => item.nodeName !== "#comment" && (item.nodeName !== "#text" || item.nodeValue));
            const moreItemWidth = 64;
            const computedMenuStyle = getComputedStyle(menu.value);
            const paddingLeft = Number.parseInt(computedMenuStyle.paddingLeft, 10);
            const paddingRight = Number.parseInt(computedMenuStyle.paddingRight, 10);
            const menuWidth = menu.value.clientWidth - paddingLeft - paddingRight;
            let calcWidth = 0;
            let sliceIndex2 = 0;
            items2.forEach((item, index) => {
              calcWidth += calcMenuItemWidth(item);
              if (calcWidth <= menuWidth - moreItemWidth) {
                sliceIndex2 = index + 1;
              }
            });
            return sliceIndex2 === items2.length ? -1 : sliceIndex2;
          };
          const getIndexPath = (index) => subMenus.value[index].indexPath;
          const debounce2 = (fn2, wait = 33.34) => {
            let timmer;
            return () => {
              timmer && clearTimeout(timmer);
              timmer = setTimeout(() => {
                fn2();
              }, wait);
            };
          };
          let isFirstTimeRender = true;
          const handleResize = () => {
            if (sliceIndex.value === calcSliceIndex())
              return;
            const callback = () => {
              sliceIndex.value = -1;
              nextTick(() => {
                sliceIndex.value = calcSliceIndex();
              });
            };
            isFirstTimeRender ? callback() : debounce2(callback)();
            isFirstTimeRender = false;
          };
          watch(() => props.defaultActive, (currentActive) => {
            if (!items.value[currentActive]) {
              activeIndex.value = "";
            }
            updateActiveIndex(currentActive);
          });
          watch(() => props.collapse, (value) => {
            if (value)
              openedMenus.value = [];
          });
          watch(items.value, initMenu);
          let resizeStopper;
          watchEffect(() => {
            if (props.mode === "horizontal" && props.ellipsis)
              resizeStopper = useResizeObserver(menu, handleResize).stop;
            else
              resizeStopper == null ? void 0 : resizeStopper();
          });
          const mouseInChild = ref(false);
          {
            const addSubMenu = (item) => {
              subMenus.value[item.index] = item;
            };
            const removeSubMenu = (item) => {
              delete subMenus.value[item.index];
            };
            const addMenuItem = (item) => {
              items.value[item.index] = item;
            };
            const removeMenuItem = (item) => {
              delete items.value[item.index];
            };
            provide("rootMenu", reactive({
              props,
              openedMenus,
              items,
              subMenus,
              activeIndex,
              isMenuPopup,
              addMenuItem,
              removeMenuItem,
              addSubMenu,
              removeSubMenu,
              openMenu,
              closeMenu,
              handleMenuItemClick,
              handleSubMenuClick
            }));
            provide(`subMenu:${instance.uid}`, {
              addSubMenu,
              removeSubMenu,
              mouseInChild,
              level: 0
            });
          }
          onMounted(() => {
            if (props.mode === "horizontal") {
              new Menu$1(instance.vnode.el, nsMenu.namespace.value);
            }
          });
          {
            const open = (index) => {
              const { indexPath } = subMenus.value[index];
              indexPath.forEach((i) => openMenu(i, indexPath));
            };
            expose({
              open,
              close,
              handleResize
            });
          }
          return () => {
            var _a, _b;
            let slot = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
            const vShowMore = [];
            if (props.mode === "horizontal" && menu.value) {
              const originalSlot = flattedChildren(slot);
              const slotDefault = sliceIndex.value === -1 ? originalSlot : originalSlot.slice(0, sliceIndex.value);
              const slotMore = sliceIndex.value === -1 ? [] : originalSlot.slice(sliceIndex.value);
              if ((slotMore == null ? void 0 : slotMore.length) && props.ellipsis) {
                slot = slotDefault;
                vShowMore.push(h$1(SubMenu2, {
                  index: "sub-menu-more",
                  class: nsSubMenu.e("hide-arrow"),
                  popperOffset: props.popperOffset
                }, {
                  title: () => h$1(ElIcon, {
                    class: nsSubMenu.e("icon-more")
                  }, {
                    default: () => h$1(props.ellipsisIcon)
                  }),
                  default: () => slotMore
                }));
              }
            }
            const ulStyle = useMenuCssVar(props, 0);
            const directives = props.closeOnClickOutside ? [
              [
                ClickOutside,
                () => {
                  if (!openedMenus.value.length)
                    return;
                  if (!mouseInChild.value) {
                    openedMenus.value.forEach((openedMenu) => emit("close", openedMenu, getIndexPath(openedMenu)));
                    openedMenus.value = [];
                  }
                }
              ]
            ] : [];
            const vMenu = withDirectives(h$1("ul", {
              key: String(props.collapse),
              role: "menubar",
              ref: menu,
              style: ulStyle.value,
              class: {
                [nsMenu.b()]: true,
                [nsMenu.m(props.mode)]: true,
                [nsMenu.m("collapse")]: props.collapse
              }
            }, [...slot, ...vShowMore]), directives);
            if (props.collapseTransition && props.mode === "vertical") {
              return h$1(ElMenuCollapseTransition, () => vMenu);
            }
            return vMenu;
          };
        }
      });
      const menuItemProps = buildProps({
        index: {
          type: definePropType([String, null]),
          default: null
        },
        route: {
          type: definePropType([String, Object])
        },
        disabled: Boolean
      });
      const menuItemEmits = {
        click: (item) => isString(item.index) && Array.isArray(item.indexPath)
      };
      const COMPONENT_NAME$4 = "ElMenuItem";
      const _sfc_main$y = defineComponent({
        name: COMPONENT_NAME$4,
        components: {
          ElTooltip
        },
        props: menuItemProps,
        emits: menuItemEmits,
        setup(props, { emit }) {
          const instance = getCurrentInstance();
          const rootMenu = inject("rootMenu");
          const nsMenu = useNamespace("menu");
          const nsMenuItem = useNamespace("menu-item");
          if (!rootMenu)
            throwError(COMPONENT_NAME$4, "can not inject root menu");
          const { parentMenu, indexPath } = useMenu(instance, toRef(props, "index"));
          const subMenu = inject(`subMenu:${parentMenu.value.uid}`);
          if (!subMenu)
            throwError(COMPONENT_NAME$4, "can not inject sub menu");
          const active = computed$1(() => props.index === rootMenu.activeIndex);
          const item = reactive({
            index: props.index,
            indexPath,
            active
          });
          const handleClick = () => {
            if (!props.disabled) {
              rootMenu.handleMenuItemClick({
                index: props.index,
                indexPath: indexPath.value,
                route: props.route
              });
              emit("click", item);
            }
          };
          onMounted(() => {
            subMenu.addSubMenu(item);
            rootMenu.addMenuItem(item);
          });
          onBeforeUnmount(() => {
            subMenu.removeSubMenu(item);
            rootMenu.removeMenuItem(item);
          });
          return {
            parentMenu,
            rootMenu,
            active,
            nsMenu,
            nsMenuItem,
            handleClick
          };
        }
      });
      function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tooltip = resolveComponent("el-tooltip");
        return openBlock(), createElementBlock("li", {
          class: normalizeClass([
            _ctx.nsMenuItem.b(),
            _ctx.nsMenuItem.is("active", _ctx.active),
            _ctx.nsMenuItem.is("disabled", _ctx.disabled)
          ]),
          role: "menuitem",
          tabindex: "-1",
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
        }, [
          _ctx.parentMenu.type.name === "ElMenu" && _ctx.rootMenu.props.collapse && _ctx.$slots.title ? (openBlock(), createBlock(_component_el_tooltip, {
            key: 0,
            effect: _ctx.rootMenu.props.popperEffect,
            placement: "right",
            "fallback-placements": ["left"],
            persistent: ""
          }, {
            content: withCtx(() => [
              renderSlot(_ctx.$slots, "title")
            ]),
            default: withCtx(() => [
              createElementVNode("div", {
                class: normalizeClass(_ctx.nsMenu.be("tooltip", "trigger"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)
            ]),
            _: 3
          }, 8, ["effect"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            renderSlot(_ctx.$slots, "default"),
            renderSlot(_ctx.$slots, "title")
          ], 64))
        ], 2);
      }
      var MenuItem2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["render", _sfc_render$e], ["__file", "menu-item.vue"]]);
      const menuItemGroupProps = {
        title: String
      };
      const COMPONENT_NAME$3 = "ElMenuItemGroup";
      const _sfc_main$x = defineComponent({
        name: COMPONENT_NAME$3,
        props: menuItemGroupProps,
        setup() {
          const ns = useNamespace("menu-item-group");
          return {
            ns
          };
        }
      });
      function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("li", {
          class: normalizeClass(_ctx.ns.b())
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("title"))
          }, [
            !_ctx.$slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ], 64)) : renderSlot(_ctx.$slots, "title", { key: 1 })
          ], 2),
          createElementVNode("ul", null, [
            renderSlot(_ctx.$slots, "default")
          ])
        ], 2);
      }
      var MenuItemGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["render", _sfc_render$d], ["__file", "menu-item-group.vue"]]);
      const ElMenu = withInstall(Menu2, {
        MenuItem: MenuItem2,
        MenuItemGroup,
        SubMenu: SubMenu2
      });
      const ElMenuItem = withNoopInstall(MenuItem2);
      withNoopInstall(MenuItemGroup);
      withNoopInstall(SubMenu2);
      const elPaginationKey = Symbol("elPaginationKey");
      const paginationPrevProps = buildProps({
        disabled: Boolean,
        currentPage: {
          type: Number,
          default: 1
        },
        prevText: {
          type: String
        },
        prevIcon: {
          type: iconPropType
        }
      });
      const paginationPrevEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const _hoisted_1$p = ["disabled", "aria-label", "aria-disabled"];
      const _hoisted_2$j = { key: 0 };
      const __default__$c = defineComponent({
        name: "ElPaginationPrev"
      });
      const _sfc_main$w = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        props: paginationPrevProps,
        emits: paginationPrevEmits,
        setup(__props) {
          const props = __props;
          const { t } = useLocale();
          const internalDisabled = computed$1(() => props.disabled || props.currentPage <= 1);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("button", {
              type: "button",
              class: "btn-prev",
              disabled: unref(internalDisabled),
              "aria-label": _ctx.prevText || unref(t)("el.pagination.prev"),
              "aria-disabled": unref(internalDisabled),
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
            }, [
              _ctx.prevText ? (openBlock(), createElementBlock("span", _hoisted_2$j, toDisplayString(_ctx.prevText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.prevIcon)))
                ]),
                _: 1
              }))
            ], 8, _hoisted_1$p);
          };
        }
      });
      var Prev = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["__file", "prev.vue"]]);
      const paginationNextProps = buildProps({
        disabled: Boolean,
        currentPage: {
          type: Number,
          default: 1
        },
        pageCount: {
          type: Number,
          default: 50
        },
        nextText: {
          type: String
        },
        nextIcon: {
          type: iconPropType
        }
      });
      const _hoisted_1$o = ["disabled", "aria-label", "aria-disabled"];
      const _hoisted_2$i = { key: 0 };
      const __default__$b = defineComponent({
        name: "ElPaginationNext"
      });
      const _sfc_main$v = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: paginationNextProps,
        emits: ["click"],
        setup(__props) {
          const props = __props;
          const { t } = useLocale();
          const internalDisabled = computed$1(() => props.disabled || props.currentPage === props.pageCount || props.pageCount === 0);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("button", {
              type: "button",
              class: "btn-next",
              disabled: unref(internalDisabled),
              "aria-label": _ctx.nextText || unref(t)("el.pagination.next"),
              "aria-disabled": unref(internalDisabled),
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
            }, [
              _ctx.nextText ? (openBlock(), createElementBlock("span", _hoisted_2$i, toDisplayString(_ctx.nextText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.nextIcon)))
                ]),
                _: 1
              }))
            ], 8, _hoisted_1$o);
          };
        }
      });
      var Next = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["__file", "next.vue"]]);
      const selectGroupKey = Symbol("ElSelectGroup");
      const selectKey = Symbol("ElSelect");
      function useOption(props, states) {
        const select = inject(selectKey);
        const selectGroup = inject(selectGroupKey, { disabled: false });
        const itemSelected = computed$1(() => {
          if (select.props.multiple) {
            return contains(select.props.modelValue, props.value);
          } else {
            return contains([select.props.modelValue], props.value);
          }
        });
        const limitReached = computed$1(() => {
          if (select.props.multiple) {
            const modelValue = select.props.modelValue || [];
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
          } else {
            return false;
          }
        });
        const currentLabel = computed$1(() => {
          return props.label || (isObject$1(props.value) ? "" : props.value);
        });
        const currentValue = computed$1(() => {
          return props.value || props.label || "";
        });
        const isDisabled = computed$1(() => {
          return props.disabled || states.groupDisabled || limitReached.value;
        });
        const instance = getCurrentInstance();
        const contains = (arr = [], target) => {
          if (!isObject$1(props.value)) {
            return arr && arr.includes(target);
          } else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item) => {
              return toRaw$1(get(item, valueKey)) === get(target, valueKey);
            });
          }
        };
        const hoverItem = () => {
          if (!props.disabled && !selectGroup.disabled) {
            select.states.hoveringIndex = select.optionsArray.indexOf(instance.proxy);
          }
        };
        const updateOption = (query) => {
          const regexp4 = new RegExp(escapeStringRegexp(query), "i");
          states.visible = regexp4.test(currentLabel.value) || props.created;
        };
        watch(() => currentLabel.value, () => {
          if (!props.created && !select.props.remote)
            select.setSelected();
        });
        watch(() => props.value, (val, oldVal) => {
          const { remote, valueKey } = select.props;
          if (!isEqual(val, oldVal)) {
            select.onOptionDestroy(oldVal, instance.proxy);
            select.onOptionCreate(instance.proxy);
          }
          if (!props.created && !remote) {
            if (valueKey && isObject$1(val) && isObject$1(oldVal) && val[valueKey] === oldVal[valueKey]) {
              return;
            }
            select.setSelected();
          }
        });
        watch(() => selectGroup.disabled, () => {
          states.groupDisabled = selectGroup.disabled;
        }, { immediate: true });
        return {
          select,
          currentLabel,
          currentValue,
          itemSelected,
          isDisabled,
          hoverItem,
          updateOption
        };
      }
      const _sfc_main$u = defineComponent({
        name: "ElOption",
        componentName: "ElOption",
        props: {
          value: {
            required: true,
            type: [String, Number, Boolean, Object]
          },
          label: [String, Number],
          created: Boolean,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const id = useId();
          const containerKls = computed$1(() => [
            ns.be("dropdown", "item"),
            ns.is("disabled", unref(isDisabled)),
            ns.is("selected", unref(itemSelected)),
            ns.is("hovering", unref(hover))
          ]);
          const states = reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hover: false
          });
          const {
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption
          } = useOption(props, states);
          const { visible, hover } = toRefs(states);
          const vm = getCurrentInstance().proxy;
          select.onOptionCreate(vm);
          onBeforeUnmount(() => {
            const key = vm.value;
            const { selected } = select.states;
            const selectedOptions = select.props.multiple ? selected : [selected];
            const doesSelected = selectedOptions.some((item) => {
              return item.value === vm.value;
            });
            nextTick(() => {
              if (select.states.cachedOptions.get(key) === vm && !doesSelected) {
                select.states.cachedOptions.delete(key);
              }
            });
            select.onOptionDestroy(key, vm);
          });
          function selectOptionClick() {
            if (props.disabled !== true && states.groupDisabled !== true) {
              select.handleOptionSelect(vm);
            }
          }
          return {
            ns,
            id,
            containerKls,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption,
            visible,
            hover,
            selectOptionClick,
            states
          };
        }
      });
      const _hoisted_1$n = ["id", "aria-disabled", "aria-selected"];
      function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("li", {
          id: _ctx.id,
          class: normalizeClass(_ctx.containerKls),
          role: "option",
          "aria-disabled": _ctx.isDisabled || void 0,
          "aria-selected": _ctx.itemSelected,
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createElementVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
          ])
        ], 42, _hoisted_1$n)), [
          [vShow, _ctx.visible]
        ]);
      }
      var Option = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$c], ["__file", "option.vue"]]);
      const _sfc_main$t = defineComponent({
        name: "ElSelectDropdown",
        componentName: "ElSelectDropdown",
        setup() {
          const select = inject(selectKey);
          const ns = useNamespace("select");
          const popperClass = computed$1(() => select.props.popperClass);
          const isMultiple = computed$1(() => select.props.multiple);
          const isFitInputWidth = computed$1(() => select.props.fitInputWidth);
          const minWidth = ref("");
          function updateMinWidth() {
            var _a;
            minWidth.value = `${(_a = select.selectRef) == null ? void 0 : _a.offsetWidth}px`;
          }
          onMounted(() => {
            updateMinWidth();
            useResizeObserver(select.selectRef, updateMinWidth);
          });
          return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
          };
        }
      });
      function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
          style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
        }, [
          _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.ns.be("dropdown", "header"))
          }, [
            renderSlot(_ctx.$slots, "header")
          ], 2)) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default"),
          _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(_ctx.ns.be("dropdown", "footer"))
          }, [
            renderSlot(_ctx.$slots, "footer")
          ], 2)) : createCommentVNode("v-if", true)
        ], 6);
      }
      var ElSelectMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["render", _sfc_render$b], ["__file", "select-dropdown.vue"]]);
      function useInput(handleInput) {
        const isComposing = ref(false);
        const handleCompositionStart = () => {
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          const text = event.target.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          if (isComposing.value) {
            isComposing.value = false;
            if (isFunction$1(handleInput)) {
              handleInput(event);
            }
          }
        };
        return {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      const MINIMUM_INPUT_WIDTH = 11;
      const useSelect = (props, emit) => {
        const { t } = useLocale();
        const contentId = useId();
        const nsSelect = useNamespace("select");
        const nsInput = useNamespace("input");
        const states = reactive({
          inputValue: "",
          options: /* @__PURE__ */ new Map(),
          cachedOptions: /* @__PURE__ */ new Map(),
          disabledOptions: /* @__PURE__ */ new Map(),
          optionValues: [],
          selected: props.multiple ? [] : {},
          selectionWidth: 0,
          calculatorWidth: 0,
          collapseItemWidth: 0,
          selectedLabel: "",
          hoveringIndex: -1,
          previousQuery: null,
          inputHovering: false,
          menuVisibleOnFocus: false,
          isBeforeHide: false
        });
        const selectRef = ref(null);
        const selectionRef = ref(null);
        const tooltipRef = ref(null);
        const tagTooltipRef = ref(null);
        const inputRef = ref(null);
        const calculatorRef = ref(null);
        const prefixRef = ref(null);
        const suffixRef = ref(null);
        const menuRef = ref(null);
        const tagMenuRef = ref(null);
        const collapseItemRef = ref(null);
        const scrollbarRef = ref(null);
        const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(inputRef, {
          afterFocus() {
            if (props.automaticDropdown && !expanded.value) {
              expanded.value = true;
              states.menuVisibleOnFocus = true;
            }
          },
          beforeBlur(event) {
            var _a, _b;
            return ((_a = tooltipRef.value) == null ? void 0 : _a.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
          },
          afterBlur() {
            expanded.value = false;
            states.menuVisibleOnFocus = false;
          }
        });
        const expanded = ref(false);
        const hoverOption = ref();
        const { form, formItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const { valueOnClear, isEmptyValue: isEmptyValue2 } = useEmptyValues(props);
        const selectDisabled = computed$1(() => props.disabled || (form == null ? void 0 : form.disabled));
        const hasModelValue = computed$1(() => {
          return props.multiple ? isArray$1(props.modelValue) && props.modelValue.length > 0 : !isEmptyValue2(props.modelValue);
        });
        const showClose = computed$1(() => {
          return props.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
        });
        const iconComponent = computed$1(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
        const iconReverse = computed$1(() => nsSelect.is("reverse", iconComponent.value && expanded.value));
        const validateState = computed$1(() => (formItem == null ? void 0 : formItem.validateState) || "");
        const validateIcon = computed$1(() => ValidateComponentsMap[validateState.value]);
        const debounce$1 = computed$1(() => props.remote ? 300 : 0);
        const emptyText = computed$1(() => {
          if (props.loading) {
            return props.loadingText || t("el.select.loading");
          } else {
            if (props.remote && !states.inputValue && states.options.size === 0)
              return false;
            if (props.filterable && states.inputValue && states.options.size > 0 && filteredOptionsCount.value === 0) {
              return props.noMatchText || t("el.select.noMatch");
            }
            if (states.options.size === 0) {
              return props.noDataText || t("el.select.noData");
            }
          }
          return null;
        });
        const filteredOptionsCount = computed$1(() => optionsArray.value.filter((option) => option.visible).length);
        const optionsArray = computed$1(() => {
          const list = Array.from(states.options.values());
          const newList = [];
          states.optionValues.forEach((item) => {
            const index = list.findIndex((i) => i.value === item);
            if (index > -1) {
              newList.push(list[index]);
            }
          });
          return newList.length >= list.length ? newList : list;
        });
        const cachedOptionsArray = computed$1(() => Array.from(states.cachedOptions.values()));
        const showNewOption = computed$1(() => {
          const hasExistingOption = optionsArray.value.filter((option) => {
            return !option.created;
          }).some((option) => {
            return option.currentLabel === states.inputValue;
          });
          return props.filterable && props.allowCreate && states.inputValue !== "" && !hasExistingOption;
        });
        const updateOptions = () => {
          if (props.filterable && isFunction$1(props.filterMethod))
            return;
          if (props.filterable && props.remote && isFunction$1(props.remoteMethod))
            return;
          optionsArray.value.forEach((option) => {
            var _a;
            (_a = option.updateOption) == null ? void 0 : _a.call(option, states.inputValue);
          });
        };
        const selectSize = useFormSize();
        const collapseTagSize = computed$1(() => ["small"].includes(selectSize.value) ? "small" : "default");
        const dropdownMenuVisible = computed$1({
          get() {
            return expanded.value && emptyText.value !== false;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const shouldShowPlaceholder = computed$1(() => {
          if (isArray$1(props.modelValue)) {
            return props.modelValue.length === 0 && !states.inputValue;
          }
          return props.filterable ? !states.inputValue : true;
        });
        const currentPlaceholder = computed$1(() => {
          var _a;
          const _placeholder = (_a = props.placeholder) != null ? _a : t("el.select.placeholder");
          return props.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
        });
        watch(() => props.modelValue, (val, oldVal) => {
          if (props.multiple) {
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
              handleQueryChange("");
            }
          }
          setSelected();
          if (!isEqual(val, oldVal) && props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        }, {
          flush: "post",
          deep: true
        });
        watch(() => expanded.value, (val) => {
          if (val) {
            handleQueryChange(states.inputValue);
          } else {
            states.inputValue = "";
            states.previousQuery = null;
            states.isBeforeHide = true;
          }
          emit("visible-change", val);
        });
        watch(() => states.options.entries(), () => {
          var _a;
          if (!isClient)
            return;
          const inputs = ((_a = selectRef.value) == null ? void 0 : _a.querySelectorAll("input")) || [];
          if (!props.filterable && !props.defaultFirstOption && !isUndefined$1(props.modelValue) || !Array.from(inputs).includes(document.activeElement)) {
            setSelected();
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            checkDefaultFirstOption();
          }
        }, {
          flush: "post"
        });
        watch(() => states.hoveringIndex, (val) => {
          if (isNumber(val) && val > -1) {
            hoverOption.value = optionsArray.value[val] || {};
          } else {
            hoverOption.value = {};
          }
          optionsArray.value.forEach((option) => {
            option.hover = hoverOption.value === option;
          });
        });
        watchEffect(() => {
          if (states.isBeforeHide)
            return;
          updateOptions();
        });
        const handleQueryChange = (val) => {
          if (states.previousQuery === val) {
            return;
          }
          states.previousQuery = val;
          if (props.filterable && isFunction$1(props.filterMethod)) {
            props.filterMethod(val);
          } else if (props.filterable && props.remote && isFunction$1(props.remoteMethod)) {
            props.remoteMethod(val);
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            nextTick(checkDefaultFirstOption);
          } else {
            nextTick(updateHoveringIndex);
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
          const userCreatedOption = optionsInDropdown.find((n) => n.created);
          const firstOriginOption = optionsInDropdown[0];
          states.hoveringIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
        };
        const setSelected = () => {
          if (!props.multiple) {
            const option = getOption(props.modelValue);
            states.selectedLabel = option.currentLabel;
            states.selected = option;
            return;
          } else {
            states.selectedLabel = "";
          }
          const result = [];
          if (isArray$1(props.modelValue)) {
            props.modelValue.forEach((value) => {
              result.push(getOption(value));
            });
          }
          states.selected = result;
        };
        const getOption = (value) => {
          let option;
          const isObjectValue = toRawType(value).toLowerCase() === "object";
          const isNull = toRawType(value).toLowerCase() === "null";
          const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
          for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
            const cachedOption = cachedOptionsArray.value[i];
            const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
            if (isEqualValue) {
              option = {
                value,
                currentLabel: cachedOption.currentLabel,
                isDisabled: cachedOption.isDisabled
              };
              break;
            }
          }
          if (option)
            return option;
          const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
          const newOption = {
            value,
            currentLabel: label
          };
          return newOption;
        };
        const updateHoveringIndex = () => {
          if (!props.multiple) {
            states.hoveringIndex = optionsArray.value.findIndex((item) => {
              return getValueKey(item) === getValueKey(states.selected);
            });
          } else {
            states.hoveringIndex = optionsArray.value.findIndex((item) => states.selected.some((selected) => getValueKey(selected) === getValueKey(item)));
          }
        };
        const resetSelectionWidth = () => {
          states.selectionWidth = selectionRef.value.getBoundingClientRect().width;
        };
        const resetCalculatorWidth = () => {
          states.calculatorWidth = calculatorRef.value.getBoundingClientRect().width;
        };
        const resetCollapseItemWidth = () => {
          states.collapseItemWidth = collapseItemRef.value.getBoundingClientRect().width;
        };
        const updateTooltip = () => {
          var _a, _b;
          (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
        };
        const updateTagTooltip = () => {
          var _a, _b;
          (_b = (_a = tagTooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
        };
        const onInputChange = () => {
          if (states.inputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          handleQueryChange(states.inputValue);
        };
        const onInput = (event) => {
          states.inputValue = event.target.value;
          if (props.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const debouncedOnInputChange = debounce(() => {
          onInputChange();
        }, debounce$1.value);
        const emitChange = (val) => {
          if (!isEqual(props.modelValue, val)) {
            emit(CHANGE_EVENT, val);
          }
        };
        const getLastNotDisabledIndex = (value) => findLastIndex(value, (it2) => !states.disabledOptions.has(it2));
        const deletePrevTag = (e) => {
          if (!props.multiple)
            return;
          if (e.code === EVENT_CODE.delete)
            return;
          if (e.target.value.length <= 0) {
            const value = props.modelValue.slice();
            const lastNotDisabledIndex = getLastNotDisabledIndex(value);
            if (lastNotDisabledIndex < 0)
              return;
            value.splice(lastNotDisabledIndex, 1);
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
          }
        };
        const deleteTag = (event, tag) => {
          const index = states.selected.indexOf(tag);
          if (index > -1 && !selectDisabled.value) {
            const value = props.modelValue.slice();
            value.splice(index, 1);
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            emit("remove-tag", tag.value);
          }
          event.stopPropagation();
          focus();
        };
        const deleteSelected = (event) => {
          event.stopPropagation();
          const value = props.multiple ? [] : valueOnClear.value;
          if (props.multiple) {
            for (const item of states.selected) {
              if (item.isDisabled)
                value.push(item.value);
            }
          }
          emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          states.hoveringIndex = -1;
          expanded.value = false;
          emit("clear");
          focus();
        };
        const handleOptionSelect = (option) => {
          if (props.multiple) {
            const value = (props.modelValue || []).slice();
            const optionIndex = getValueIndex(value, option.value);
            if (optionIndex > -1) {
              value.splice(optionIndex, 1);
            } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
              value.push(option.value);
            }
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
              handleQueryChange("");
            }
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
            }
          } else {
            emit(UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            expanded.value = false;
          }
          focus();
          if (expanded.value)
            return;
          nextTick(() => {
            scrollToOption(option);
          });
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value))
            return arr.indexOf(value);
          const valueKey = props.valueKey;
          let index = -1;
          arr.some((item, i) => {
            if (toRaw$1(get(item, valueKey)) === get(value, valueKey)) {
              index = i;
              return true;
            }
            return false;
          });
          return index;
        };
        const scrollToOption = (option) => {
          var _a, _b, _c, _d, _e;
          const targetOption = isArray$1(option) ? option[0] : option;
          let target = null;
          if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item) => item.value === targetOption.value);
            if (options.length > 0) {
              target = options[0].$el;
            }
          }
          if (tooltipRef.value && target) {
            const menu = (_d = (_c = (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${nsSelect.be("dropdown", "wrap")}`);
            if (menu) {
              scrollIntoView(menu, target);
            }
          }
          (_e = scrollbarRef.value) == null ? void 0 : _e.handleScroll();
        };
        const onOptionCreate = (vm) => {
          states.options.set(vm.value, vm);
          states.cachedOptions.set(vm.value, vm);
          vm.disabled && states.disabledOptions.set(vm.value, vm);
        };
        const onOptionDestroy = (key, vm) => {
          if (states.options.get(key) === vm) {
            states.options.delete(key);
          }
        };
        const {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useInput((e) => onInput(e));
        const popperRef = computed$1(() => {
          var _a, _b;
          return (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
        });
        const handleMenuEnter = () => {
          states.isBeforeHide = false;
          nextTick(() => scrollToOption(states.selected));
        };
        const focus = () => {
          var _a;
          (_a = inputRef.value) == null ? void 0 : _a.focus();
        };
        const blur = () => {
          handleClickOutside();
        };
        const handleClearClick = (event) => {
          deleteSelected(event);
        };
        const handleClickOutside = (event) => {
          expanded.value = false;
          if (isFocused.value) {
            const _event2 = new FocusEvent("focus", event);
            nextTick(() => handleBlur(_event2));
          }
        };
        const handleEsc = () => {
          if (states.inputValue.length > 0) {
            states.inputValue = "";
          } else {
            expanded.value = false;
          }
        };
        const toggleMenu = () => {
          if (selectDisabled.value)
            return;
          if (states.menuVisibleOnFocus) {
            states.menuVisibleOnFocus = false;
          } else {
            expanded.value = !expanded.value;
          }
        };
        const selectOption = () => {
          if (!expanded.value) {
            toggleMenu();
          } else {
            if (optionsArray.value[states.hoveringIndex]) {
              handleOptionSelect(optionsArray.value[states.hoveringIndex]);
            }
          }
        };
        const getValueKey = (item) => {
          return isObject$1(item.value) ? get(item.value, props.valueKey) : item.value;
        };
        const optionsAllDisabled = computed$1(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
        const showTagList = computed$1(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(0, props.maxCollapseTags) : states.selected;
        });
        const collapseTagList = computed$1(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(props.maxCollapseTags) : [];
        });
        const navigateOptions = (direction) => {
          if (!expanded.value) {
            expanded.value = true;
            return;
          }
          if (states.options.size === 0 || filteredOptionsCount.value === 0)
            return;
          if (!optionsAllDisabled.value) {
            if (direction === "next") {
              states.hoveringIndex++;
              if (states.hoveringIndex === states.options.size) {
                states.hoveringIndex = 0;
              }
            } else if (direction === "prev") {
              states.hoveringIndex--;
              if (states.hoveringIndex < 0) {
                states.hoveringIndex = states.options.size - 1;
              }
            }
            const option = optionsArray.value[states.hoveringIndex];
            if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
              navigateOptions(direction);
            }
            nextTick(() => scrollToOption(hoverOption.value));
          }
        };
        const getGapWidth = () => {
          if (!selectionRef.value)
            return 0;
          const style = window.getComputedStyle(selectionRef.value);
          return Number.parseFloat(style.gap || "6px");
        };
        const tagStyle = computed$1(() => {
          const gapWidth = getGapWidth();
          const maxWidth = collapseItemRef.value && props.maxCollapseTags === 1 ? states.selectionWidth - states.collapseItemWidth - gapWidth : states.selectionWidth;
          return { maxWidth: `${maxWidth}px` };
        });
        const collapseTagStyle = computed$1(() => {
          return { maxWidth: `${states.selectionWidth}px` };
        });
        const inputStyle = computed$1(() => ({
          width: `${Math.max(states.calculatorWidth, MINIMUM_INPUT_WIDTH)}px`
        }));
        if (props.multiple && !isArray$1(props.modelValue)) {
          emit(UPDATE_MODEL_EVENT, []);
        }
        if (!props.multiple && isArray$1(props.modelValue)) {
          emit(UPDATE_MODEL_EVENT, "");
        }
        useResizeObserver(selectionRef, resetSelectionWidth);
        useResizeObserver(calculatorRef, resetCalculatorWidth);
        useResizeObserver(menuRef, updateTooltip);
        useResizeObserver(wrapperRef, updateTooltip);
        useResizeObserver(tagMenuRef, updateTagTooltip);
        useResizeObserver(collapseItemRef, resetCollapseItemWidth);
        onMounted(() => {
          setSelected();
        });
        return {
          inputId,
          contentId,
          nsSelect,
          nsInput,
          states,
          isFocused,
          expanded,
          optionsArray,
          hoverOption,
          selectSize,
          filteredOptionsCount,
          resetCalculatorWidth,
          updateTooltip,
          updateTagTooltip,
          debouncedOnInputChange,
          onInput,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          hasModelValue,
          shouldShowPlaceholder,
          currentPlaceholder,
          showClose,
          iconComponent,
          iconReverse,
          validateState,
          validateIcon,
          showNewOption,
          updateOptions,
          collapseTagSize,
          setSelected,
          selectDisabled,
          emptyText,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          handleFocus,
          focus,
          blur,
          handleBlur,
          handleClearClick,
          handleClickOutside,
          handleEsc,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          dropdownMenuVisible,
          showTagList,
          collapseTagList,
          tagStyle,
          collapseTagStyle,
          inputStyle,
          popperRef,
          inputRef,
          tooltipRef,
          tagTooltipRef,
          calculatorRef,
          prefixRef,
          suffixRef,
          selectRef,
          wrapperRef,
          selectionRef,
          scrollbarRef,
          menuRef,
          tagMenuRef,
          collapseItemRef
        };
      };
      var ElOptions = defineComponent({
        name: "ElOptions",
        setup(_2, { slots }) {
          const select = inject(selectKey);
          let cachedValueList = [];
          return () => {
            var _a, _b;
            const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
            const valueList = [];
            function filterOptions(children2) {
              if (!isArray$1(children2))
                return;
              children2.forEach((item) => {
                var _a2, _b2, _c, _d;
                const name = (_a2 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a2.name;
                if (name === "ElOptionGroup") {
                  filterOptions(!isString(item.children) && !isArray$1(item.children) && isFunction$1((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
                } else if (name === "ElOption") {
                  valueList.push((_d = item.props) == null ? void 0 : _d.value);
                } else if (isArray$1(item.children)) {
                  filterOptions(item.children);
                }
              });
            }
            if (children.length) {
              filterOptions((_b = children[0]) == null ? void 0 : _b.children);
            }
            if (!isEqual(valueList, cachedValueList)) {
              cachedValueList = valueList;
              if (select) {
                select.states.optionValues = valueList;
              }
            }
            return children;
          };
        }
      });
      const SelectProps = buildProps({
        name: String,
        id: String,
        modelValue: {
          type: [Array, String, Number, Boolean, Object],
          default: void 0
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        automaticDropdown: Boolean,
        size: useSizeProp,
        effect: {
          type: definePropType(String),
          default: "light"
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        allowCreate: Boolean,
        loading: Boolean,
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        remote: Boolean,
        loadingText: String,
        noMatchText: String,
        noDataText: String,
        remoteMethod: Function,
        filterMethod: Function,
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        placeholder: {
          type: String
        },
        defaultFirstOption: Boolean,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        valueKey: {
          type: String,
          default: "value"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: Boolean,
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: iconPropType,
          default: circle_close_default
        },
        fitInputWidth: Boolean,
        suffixIcon: {
          type: iconPropType,
          default: arrow_down_default
        },
        tagType: { ...tagProps.type, default: "info" },
        validateEvent: {
          type: Boolean,
          default: true
        },
        remoteShowSuffix: Boolean,
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: ["bottom-start", "top-start", "right", "left"]
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        ...useEmptyValuesProps
      });
      const COMPONENT_NAME$2 = "ElSelect";
      const _sfc_main$s = defineComponent({
        name: COMPONENT_NAME$2,
        componentName: COMPONENT_NAME$2,
        components: {
          ElInput,
          ElSelectMenu,
          ElOption: Option,
          ElOptions,
          ElTag,
          ElScrollbar,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: SelectProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props, { emit }) {
          const API = useSelect(props, emit);
          provide(selectKey, reactive({
            props,
            states: API.states,
            optionsArray: API.optionsArray,
            handleOptionSelect: API.handleOptionSelect,
            onOptionCreate: API.onOptionCreate,
            onOptionDestroy: API.onOptionDestroy,
            selectRef: API.selectRef,
            setSelected: API.setSelected
          }));
          return {
            ...API
          };
        }
      });
      const _hoisted_1$m = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"];
      const _hoisted_2$h = ["textContent"];
      function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_option = resolveComponent("el-option");
        const _component_el_options = resolveComponent("el-options");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectRef",
          class: normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
          onMouseenter: _cache[16] || (_cache[16] = ($event) => _ctx.states.inputHovering = true),
          onMouseleave: _cache[17] || (_cache[17] = ($event) => _ctx.states.inputHovering = false),
          onClick: _cache[18] || (_cache[18] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["prevent", "stop"]))
        }, [
          createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropdownMenuVisible,
            placement: _ctx.placement,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "popper-options": _ctx.popperOptions,
            "fallback-placements": _ctx.fallbackPlacements,
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: _ctx.persistent,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: _cache[15] || (_cache[15] = ($event) => _ctx.states.isBeforeHide = false)
          }, {
            default: withCtx(() => {
              var _a;
              return [
                createElementVNode("div", {
                  ref: "wrapperRef",
                  class: normalizeClass([
                    _ctx.nsSelect.e("wrapper"),
                    _ctx.nsSelect.is("focused", _ctx.isFocused),
                    _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                    _ctx.nsSelect.is("filterable", _ctx.filterable),
                    _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                  ])
                }, [
                  _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "prefixRef",
                    class: normalizeClass(_ctx.nsSelect.e("prefix"))
                  }, [
                    renderSlot(_ctx.$slots, "prefix")
                  ], 2)) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    ref: "selectionRef",
                    class: normalizeClass([
                      _ctx.nsSelect.e("selection"),
                      _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.states.selected.length)
                    ])
                  }, [
                    _ctx.multiple ? renderSlot(_ctx.$slots, "tag", { key: 0 }, () => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                        return openBlock(), createElementBlock("div", {
                          key: _ctx.getValueKey(item),
                          class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          createVNode(_component_el_tag, {
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            style: normalizeStyle(_ctx.tagStyle),
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createElementVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, toDisplayString(item.currentLabel), 3)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "type", "style", "onClose"])
                        ], 2);
                      }), 128)),
                      _ctx.collapseTags && _ctx.states.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tooltip, {
                        key: 0,
                        ref: "tagTooltipRef",
                        disabled: _ctx.dropdownMenuVisible || !_ctx.collapseTagsTooltip,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: _ctx.effect,
                        placement: "bottom",
                        teleported: _ctx.teleported
                      }, {
                        default: withCtx(() => [
                          createElementVNode("div", {
                            ref: "collapseItemRef",
                            class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                          }, [
                            createVNode(_component_el_tag, {
                              closable: false,
                              size: _ctx.collapseTagSize,
                              type: _ctx.tagType,
                              "disable-transitions": "",
                              style: normalizeStyle(_ctx.collapseTagStyle)
                            }, {
                              default: withCtx(() => [
                                createElementVNode("span", {
                                  class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                }, " + " + toDisplayString(_ctx.states.selected.length - _ctx.maxCollapseTags), 3)
                              ]),
                              _: 1
                            }, 8, ["size", "type", "style"])
                          ], 2)
                        ]),
                        content: withCtx(() => [
                          createElementVNode("div", {
                            ref: "tagMenuRef",
                            class: normalizeClass(_ctx.nsSelect.e("selection"))
                          }, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                              return openBlock(), createElementBlock("div", {
                                key: _ctx.getValueKey(item),
                                class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                              }, [
                                createVNode(_component_el_tag, {
                                  class: "in-tooltip",
                                  closable: !_ctx.selectDisabled && !item.isDisabled,
                                  size: _ctx.collapseTagSize,
                                  type: _ctx.tagType,
                                  "disable-transitions": "",
                                  onClose: ($event) => _ctx.deleteTag($event, item)
                                }, {
                                  default: withCtx(() => [
                                    createElementVNode("span", {
                                      class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                    }, toDisplayString(item.currentLabel), 3)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "type", "onClose"])
                              ], 2);
                            }), 128))
                          ], 2)
                        ]),
                        _: 1
                      }, 8, ["disabled", "effect", "teleported"])) : createCommentVNode("v-if", true)
                    ]) : createCommentVNode("v-if", true),
                    !_ctx.selectDisabled ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("input-wrapper"),
                        _ctx.nsSelect.is("hidden", !_ctx.filterable)
                      ])
                    }, [
                      withDirectives(createElementVNode("input", {
                        id: _ctx.inputId,
                        ref: "inputRef",
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.states.inputValue = $event),
                        type: "text",
                        class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                        disabled: _ctx.selectDisabled,
                        autocomplete: _ctx.autocomplete,
                        style: normalizeStyle(_ctx.inputStyle),
                        role: "combobox",
                        readonly: !_ctx.filterable,
                        spellcheck: "false",
                        "aria-activedescendant": ((_a = _ctx.hoverOption) == null ? void 0 : _a.id) || "",
                        "aria-controls": _ctx.contentId,
                        "aria-expanded": _ctx.dropdownMenuVisible,
                        "aria-label": _ctx.ariaLabel,
                        "aria-autocomplete": "none",
                        "aria-haspopup": "listbox",
                        onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                        onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                        onKeydown: [
                          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                          _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                          _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                          _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                          _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["stop"]), ["delete"]))
                        ],
                        onCompositionstart: _cache[8] || (_cache[8] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                        onCompositionupdate: _cache[9] || (_cache[9] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                        onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                        onInput: _cache[11] || (_cache[11] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                        onClick: _cache[12] || (_cache[12] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
                      }, null, 46, _hoisted_1$m), [
                        [vModelText, _ctx.states.inputValue]
                      ]),
                      _ctx.filterable ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        ref: "calculatorRef",
                        "aria-hidden": "true",
                        class: normalizeClass(_ctx.nsSelect.e("input-calculator")),
                        textContent: toDisplayString(_ctx.states.inputValue)
                      }, null, 10, _hoisted_2$h)) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true),
                    _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("div", {
                      key: 2,
                      class: normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("placeholder"),
                        _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                      ])
                    }, [
                      createElementVNode("span", null, toDisplayString(_ctx.currentPlaceholder), 1)
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 2),
                  createElementVNode("div", {
                    ref: "suffixRef",
                    class: normalizeClass(_ctx.nsSelect.e("suffix"))
                  }, [
                    _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                      key: 0,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 1,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                      onClick: _ctx.handleClearClick
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                    _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 2,
                      class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)
              ];
            }),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, { ref: "menuRef" }, {
                default: withCtx(() => [
                  _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "header")),
                    onClick: _cache[13] || (_cache[13] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    renderSlot(_ctx.$slots, "header")
                  ], 2)) : createCommentVNode("v-if", true),
                  withDirectives(createVNode(_component_el_scrollbar, {
                    id: _ctx.contentId,
                    ref: "scrollbarRef",
                    tag: "ul",
                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                    class: normalizeClass([_ctx.nsSelect.is("empty", _ctx.filteredOptionsCount === 0)]),
                    role: "listbox",
                    "aria-label": _ctx.ariaLabel,
                    "aria-orientation": "vertical"
                  }, {
                    default: withCtx(() => [
                      _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                        key: 0,
                        value: _ctx.states.inputValue,
                        created: true
                      }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                      createVNode(_component_el_options, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
                    [vShow, _ctx.states.options.size > 0 && !_ctx.loading]
                  ]),
                  _ctx.$slots.loading && _ctx.loading ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "loading"))
                  }, [
                    renderSlot(_ctx.$slots, "loading")
                  ], 2)) : _ctx.loading || _ctx.filteredOptionsCount === 0 ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                  }, [
                    renderSlot(_ctx.$slots, "empty", {}, () => [
                      createElementVNode("span", null, toDisplayString(_ctx.emptyText), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                    key: 3,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "footer")),
                    onClick: _cache[14] || (_cache[14] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    renderSlot(_ctx.$slots, "footer")
                  ], 2)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 512)
            ]),
            _: 3
          }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "onBeforeShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["render", _sfc_render$a], ["__file", "select.vue"]]);
      const _sfc_main$r = defineComponent({
        name: "ElOptionGroup",
        componentName: "ElOptionGroup",
        props: {
          label: String,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const groupRef = ref(null);
          const instance = getCurrentInstance();
          const children = ref([]);
          provide(selectGroupKey, reactive({
            ...toRefs(props)
          }));
          const visible = computed$1(() => children.value.some((option) => option.visible === true));
          const flattedChildren2 = (node) => {
            const children2 = [];
            if (isArray$1(node.children)) {
              node.children.forEach((child) => {
                var _a, _b;
                if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                  children2.push(child.component.proxy);
                } else if ((_a = child.children) == null ? void 0 : _a.length) {
                  children2.push(...flattedChildren2(child));
                } else if ((_b = child.component) == null ? void 0 : _b.subTree) {
                  children2.push(...flattedChildren2(child.component.subTree));
                }
              });
            }
            return children2;
          };
          const updateChildren = () => {
            children.value = flattedChildren2(instance.subTree);
          };
          onMounted(() => {
            updateChildren();
          });
          useMutationObserver(groupRef, updateChildren, {
            attributes: true,
            subtree: true,
            childList: true
          });
          return {
            groupRef,
            visible,
            ns
          };
        }
      });
      function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("ul", {
          ref: "groupRef",
          class: normalizeClass(_ctx.ns.be("group", "wrap"))
        }, [
          createElementVNode("li", {
            class: normalizeClass(_ctx.ns.be("group", "title"))
          }, toDisplayString(_ctx.label), 3),
          createElementVNode("li", null, [
            createElementVNode("ul", {
              class: normalizeClass(_ctx.ns.b("group"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ])
        ], 2)), [
          [vShow, _ctx.visible]
        ]);
      }
      var OptionGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["render", _sfc_render$9], ["__file", "option-group.vue"]]);
      const ElSelect = withInstall(Select, {
        Option,
        OptionGroup
      });
      const ElOption = withNoopInstall(Option);
      withNoopInstall(OptionGroup);
      const usePagination = () => inject(elPaginationKey, {});
      const paginationSizesProps = buildProps({
        pageSize: {
          type: Number,
          required: true
        },
        pageSizes: {
          type: definePropType(Array),
          default: () => mutable([10, 20, 30, 40, 50, 100])
        },
        popperClass: {
          type: String
        },
        disabled: Boolean,
        teleported: Boolean,
        size: {
          type: String,
          values: componentSizes
        }
      });
      const __default__$a = defineComponent({
        name: "ElPaginationSizes"
      });
      const _sfc_main$q = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        props: paginationSizesProps,
        emits: ["page-size-change"],
        setup(__props, { emit }) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const pagination = usePagination();
          const innerPageSize = ref(props.pageSize);
          watch(() => props.pageSizes, (newVal, oldVal) => {
            if (isEqual(newVal, oldVal))
              return;
            if (Array.isArray(newVal)) {
              const pageSize = newVal.includes(props.pageSize) ? props.pageSize : props.pageSizes[0];
              emit("page-size-change", pageSize);
            }
          });
          watch(() => props.pageSize, (newVal) => {
            innerPageSize.value = newVal;
          });
          const innerPageSizes = computed$1(() => props.pageSizes);
          function handleChange(val) {
            var _a;
            if (val !== innerPageSize.value) {
              innerPageSize.value = val;
              (_a = pagination.handleSizeChange) == null ? void 0 : _a.call(pagination, Number(val));
            }
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(ns).e("sizes"))
            }, [
              createVNode(unref(ElSelect), {
                "model-value": innerPageSize.value,
                disabled: _ctx.disabled,
                "popper-class": _ctx.popperClass,
                size: _ctx.size,
                teleported: _ctx.teleported,
                "validate-event": false,
                onChange: handleChange
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(innerPageSizes), (item) => {
                    return openBlock(), createBlock(unref(ElOption), {
                      key: item,
                      value: item,
                      label: item + unref(t)("el.pagination.pagesize")
                    }, null, 8, ["value", "label"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["model-value", "disabled", "popper-class", "size", "teleported"])
            ], 2);
          };
        }
      });
      var Sizes = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["__file", "sizes.vue"]]);
      const paginationJumperProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        }
      });
      const _hoisted_1$l = ["disabled"];
      const __default__$9 = defineComponent({
        name: "ElPaginationJumper"
      });
      const _sfc_main$p = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: paginationJumperProps,
        setup(__props) {
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const { pageCount, disabled, currentPage, changeEvent } = usePagination();
          const userInput = ref();
          const innerValue = computed$1(() => {
            var _a;
            return (_a = userInput.value) != null ? _a : currentPage == null ? void 0 : currentPage.value;
          });
          function handleInput(val) {
            userInput.value = val ? +val : "";
          }
          function handleChange(val) {
            val = Math.trunc(+val);
            changeEvent == null ? void 0 : changeEvent(val);
            userInput.value = void 0;
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(ns).e("jump")),
              disabled: unref(disabled)
            }, [
              createElementVNode("span", {
                class: normalizeClass([unref(ns).e("goto")])
              }, toDisplayString(unref(t)("el.pagination.goto")), 3),
              createVNode(unref(ElInput), {
                size: _ctx.size,
                class: normalizeClass([unref(ns).e("editor"), unref(ns).is("in-pagination")]),
                min: 1,
                max: unref(pageCount),
                disabled: unref(disabled),
                "model-value": unref(innerValue),
                "validate-event": false,
                label: unref(t)("el.pagination.page"),
                type: "number",
                "onUpdate:modelValue": handleInput,
                onChange: handleChange
              }, null, 8, ["size", "class", "max", "disabled", "model-value", "label"]),
              createElementVNode("span", {
                class: normalizeClass([unref(ns).e("classifier")])
              }, toDisplayString(unref(t)("el.pagination.pageClassifier")), 3)
            ], 10, _hoisted_1$l);
          };
        }
      });
      var Jumper = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["__file", "jumper.vue"]]);
      const paginationTotalProps = buildProps({
        total: {
          type: Number,
          default: 1e3
        }
      });
      const _hoisted_1$k = ["disabled"];
      const __default__$8 = defineComponent({
        name: "ElPaginationTotal"
      });
      const _sfc_main$o = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: paginationTotalProps,
        setup(__props) {
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const { disabled } = usePagination();
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(ns).e("total")),
              disabled: unref(disabled)
            }, toDisplayString(unref(t)("el.pagination.total", {
              total: _ctx.total
            })), 11, _hoisted_1$k);
          };
        }
      });
      var Total = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["__file", "total.vue"]]);
      const paginationPagerProps = buildProps({
        currentPage: {
          type: Number,
          default: 1
        },
        pageCount: {
          type: Number,
          required: true
        },
        pagerCount: {
          type: Number,
          default: 7
        },
        disabled: Boolean
      });
      const _hoisted_1$j = ["onKeyup"];
      const _hoisted_2$g = ["aria-current", "aria-label", "tabindex"];
      const _hoisted_3$d = ["tabindex", "aria-label"];
      const _hoisted_4$7 = ["aria-current", "aria-label", "tabindex"];
      const _hoisted_5$6 = ["tabindex", "aria-label"];
      const _hoisted_6$3 = ["aria-current", "aria-label", "tabindex"];
      const __default__$7 = defineComponent({
        name: "ElPaginationPager"
      });
      const _sfc_main$n = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: paginationPagerProps,
        emits: ["change"],
        setup(__props, { emit }) {
          const props = __props;
          const nsPager = useNamespace("pager");
          const nsIcon = useNamespace("icon");
          const { t } = useLocale();
          const showPrevMore = ref(false);
          const showNextMore = ref(false);
          const quickPrevHover = ref(false);
          const quickNextHover = ref(false);
          const quickPrevFocus = ref(false);
          const quickNextFocus = ref(false);
          const pagers = computed$1(() => {
            const pagerCount = props.pagerCount;
            const halfPagerCount = (pagerCount - 1) / 2;
            const currentPage = Number(props.currentPage);
            const pageCount = Number(props.pageCount);
            let showPrevMore2 = false;
            let showNextMore2 = false;
            if (pageCount > pagerCount) {
              if (currentPage > pagerCount - halfPagerCount) {
                showPrevMore2 = true;
              }
              if (currentPage < pageCount - halfPagerCount) {
                showNextMore2 = true;
              }
            }
            const array4 = [];
            if (showPrevMore2 && !showNextMore2) {
              const startPage = pageCount - (pagerCount - 2);
              for (let i = startPage; i < pageCount; i++) {
                array4.push(i);
              }
            } else if (!showPrevMore2 && showNextMore2) {
              for (let i = 2; i < pagerCount; i++) {
                array4.push(i);
              }
            } else if (showPrevMore2 && showNextMore2) {
              const offset = Math.floor(pagerCount / 2) - 1;
              for (let i = currentPage - offset; i <= currentPage + offset; i++) {
                array4.push(i);
              }
            } else {
              for (let i = 2; i < pageCount; i++) {
                array4.push(i);
              }
            }
            return array4;
          });
          const prevMoreKls = computed$1(() => [
            "more",
            "btn-quickprev",
            nsIcon.b(),
            nsPager.is("disabled", props.disabled)
          ]);
          const nextMoreKls = computed$1(() => [
            "more",
            "btn-quicknext",
            nsIcon.b(),
            nsPager.is("disabled", props.disabled)
          ]);
          const tabindex = computed$1(() => props.disabled ? -1 : 0);
          watchEffect(() => {
            const halfPagerCount = (props.pagerCount - 1) / 2;
            showPrevMore.value = false;
            showNextMore.value = false;
            if (props.pageCount > props.pagerCount) {
              if (props.currentPage > props.pagerCount - halfPagerCount) {
                showPrevMore.value = true;
              }
              if (props.currentPage < props.pageCount - halfPagerCount) {
                showNextMore.value = true;
              }
            }
          });
          function onMouseEnter(forward = false) {
            if (props.disabled)
              return;
            if (forward) {
              quickPrevHover.value = true;
            } else {
              quickNextHover.value = true;
            }
          }
          function onFocus(forward = false) {
            if (forward) {
              quickPrevFocus.value = true;
            } else {
              quickNextFocus.value = true;
            }
          }
          function onEnter(e) {
            const target = e.target;
            if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
              const newPage = Number(target.textContent);
              if (newPage !== props.currentPage) {
                emit("change", newPage);
              }
            } else if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("more")) {
              onPagerClick(e);
            }
          }
          function onPagerClick(event) {
            const target = event.target;
            if (target.tagName.toLowerCase() === "ul" || props.disabled) {
              return;
            }
            let newPage = Number(target.textContent);
            const pageCount = props.pageCount;
            const currentPage = props.currentPage;
            const pagerCountOffset = props.pagerCount - 2;
            if (target.className.includes("more")) {
              if (target.className.includes("quickprev")) {
                newPage = currentPage - pagerCountOffset;
              } else if (target.className.includes("quicknext")) {
                newPage = currentPage + pagerCountOffset;
              }
            }
            if (!Number.isNaN(+newPage)) {
              if (newPage < 1) {
                newPage = 1;
              }
              if (newPage > pageCount) {
                newPage = pageCount;
              }
            }
            if (newPage !== currentPage) {
              emit("change", newPage);
            }
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("ul", {
              class: normalizeClass(unref(nsPager).b()),
              onClick: onPagerClick,
              onKeyup: withKeys(onEnter, ["enter"])
            }, [
              _ctx.pageCount > 0 ? (openBlock(), createElementBlock("li", {
                key: 0,
                class: normalizeClass([[
                  unref(nsPager).is("active", _ctx.currentPage === 1),
                  unref(nsPager).is("disabled", _ctx.disabled)
                ], "number"]),
                "aria-current": _ctx.currentPage === 1,
                "aria-label": unref(t)("el.pagination.currentPage", { pager: 1 }),
                tabindex: unref(tabindex)
              }, " 1 ", 10, _hoisted_2$g)) : createCommentVNode("v-if", true),
              showPrevMore.value ? (openBlock(), createElementBlock("li", {
                key: 1,
                class: normalizeClass(unref(prevMoreKls)),
                tabindex: unref(tabindex),
                "aria-label": unref(t)("el.pagination.prevPages", { pager: _ctx.pagerCount - 2 }),
                onMouseenter: _cache[0] || (_cache[0] = ($event) => onMouseEnter(true)),
                onMouseleave: _cache[1] || (_cache[1] = ($event) => quickPrevHover.value = false),
                onFocus: _cache[2] || (_cache[2] = ($event) => onFocus(true)),
                onBlur: _cache[3] || (_cache[3] = ($event) => quickPrevFocus.value = false)
              }, [
                (quickPrevHover.value || quickPrevFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_left_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))
              ], 42, _hoisted_3$d)) : createCommentVNode("v-if", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(pagers), (pager) => {
                return openBlock(), createElementBlock("li", {
                  key: pager,
                  class: normalizeClass([[
                    unref(nsPager).is("active", _ctx.currentPage === pager),
                    unref(nsPager).is("disabled", _ctx.disabled)
                  ], "number"]),
                  "aria-current": _ctx.currentPage === pager,
                  "aria-label": unref(t)("el.pagination.currentPage", { pager }),
                  tabindex: unref(tabindex)
                }, toDisplayString(pager), 11, _hoisted_4$7);
              }), 128)),
              showNextMore.value ? (openBlock(), createElementBlock("li", {
                key: 2,
                class: normalizeClass(unref(nextMoreKls)),
                tabindex: unref(tabindex),
                "aria-label": unref(t)("el.pagination.nextPages", { pager: _ctx.pagerCount - 2 }),
                onMouseenter: _cache[4] || (_cache[4] = ($event) => onMouseEnter()),
                onMouseleave: _cache[5] || (_cache[5] = ($event) => quickNextHover.value = false),
                onFocus: _cache[6] || (_cache[6] = ($event) => onFocus()),
                onBlur: _cache[7] || (_cache[7] = ($event) => quickNextFocus.value = false)
              }, [
                (quickNextHover.value || quickNextFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_right_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))
              ], 42, _hoisted_5$6)) : createCommentVNode("v-if", true),
              _ctx.pageCount > 1 ? (openBlock(), createElementBlock("li", {
                key: 3,
                class: normalizeClass([[
                  unref(nsPager).is("active", _ctx.currentPage === _ctx.pageCount),
                  unref(nsPager).is("disabled", _ctx.disabled)
                ], "number"]),
                "aria-current": _ctx.currentPage === _ctx.pageCount,
                "aria-label": unref(t)("el.pagination.currentPage", { pager: _ctx.pageCount }),
                tabindex: unref(tabindex)
              }, toDisplayString(_ctx.pageCount), 11, _hoisted_6$3)) : createCommentVNode("v-if", true)
            ], 42, _hoisted_1$j);
          };
        }
      });
      var Pager = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "pager.vue"]]);
      const isAbsent = (v2) => typeof v2 !== "number";
      const paginationProps = buildProps({
        pageSize: Number,
        defaultPageSize: Number,
        total: Number,
        pageCount: Number,
        pagerCount: {
          type: Number,
          validator: (value) => {
            return isNumber(value) && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
          },
          default: 7
        },
        currentPage: Number,
        defaultCurrentPage: Number,
        layout: {
          type: String,
          default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
        },
        pageSizes: {
          type: definePropType(Array),
          default: () => mutable([10, 20, 30, 40, 50, 100])
        },
        popperClass: {
          type: String,
          default: ""
        },
        prevText: {
          type: String,
          default: ""
        },
        prevIcon: {
          type: iconPropType,
          default: () => arrow_left_default
        },
        nextText: {
          type: String,
          default: ""
        },
        nextIcon: {
          type: iconPropType,
          default: () => arrow_right_default
        },
        teleported: {
          type: Boolean,
          default: true
        },
        small: Boolean,
        background: Boolean,
        disabled: Boolean,
        hideOnSinglePage: Boolean
      });
      const paginationEmits = {
        "update:current-page": (val) => isNumber(val),
        "update:page-size": (val) => isNumber(val),
        "size-change": (val) => isNumber(val),
        change: (currentPage, pageSize) => isNumber(currentPage) && isNumber(pageSize),
        "current-change": (val) => isNumber(val),
        "prev-click": (val) => isNumber(val),
        "next-click": (val) => isNumber(val)
      };
      const componentName = "ElPagination";
      var Pagination = defineComponent({
        name: componentName,
        props: paginationProps,
        emits: paginationEmits,
        setup(props, { emit, slots }) {
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const vnodeProps = getCurrentInstance().vnode.props || {};
          const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
          const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
          const assertValidUsage = computed$1(() => {
            if (isAbsent(props.total) && isAbsent(props.pageCount))
              return false;
            if (!isAbsent(props.currentPage) && !hasCurrentPageListener)
              return false;
            if (props.layout.includes("sizes")) {
              if (!isAbsent(props.pageCount)) {
                if (!hasPageSizeListener)
                  return false;
              } else if (!isAbsent(props.total)) {
                if (!isAbsent(props.pageSize)) {
                  if (!hasPageSizeListener) {
                    return false;
                  }
                }
              }
            }
            return true;
          });
          const innerPageSize = ref(isAbsent(props.defaultPageSize) ? 10 : props.defaultPageSize);
          const innerCurrentPage = ref(isAbsent(props.defaultCurrentPage) ? 1 : props.defaultCurrentPage);
          const pageSizeBridge = computed$1({
            get() {
              return isAbsent(props.pageSize) ? innerPageSize.value : props.pageSize;
            },
            set(v2) {
              if (isAbsent(props.pageSize)) {
                innerPageSize.value = v2;
              }
              if (hasPageSizeListener) {
                emit("update:page-size", v2);
                emit("size-change", v2);
              }
            }
          });
          const pageCountBridge = computed$1(() => {
            let pageCount = 0;
            if (!isAbsent(props.pageCount)) {
              pageCount = props.pageCount;
            } else if (!isAbsent(props.total)) {
              pageCount = Math.max(1, Math.ceil(props.total / pageSizeBridge.value));
            }
            return pageCount;
          });
          const currentPageBridge = computed$1({
            get() {
              return isAbsent(props.currentPage) ? innerCurrentPage.value : props.currentPage;
            },
            set(v2) {
              let newCurrentPage = v2;
              if (v2 < 1) {
                newCurrentPage = 1;
              } else if (v2 > pageCountBridge.value) {
                newCurrentPage = pageCountBridge.value;
              }
              if (isAbsent(props.currentPage)) {
                innerCurrentPage.value = newCurrentPage;
              }
              if (hasCurrentPageListener) {
                emit("update:current-page", newCurrentPage);
                emit("current-change", newCurrentPage);
              }
            }
          });
          watch(pageCountBridge, (val) => {
            if (currentPageBridge.value > val)
              currentPageBridge.value = val;
          });
          watch([currentPageBridge, pageSizeBridge], (value) => {
            emit("change", ...value);
          }, { flush: "post" });
          function handleCurrentChange(val) {
            currentPageBridge.value = val;
          }
          function handleSizeChange(val) {
            pageSizeBridge.value = val;
            const newPageCount = pageCountBridge.value;
            if (currentPageBridge.value > newPageCount) {
              currentPageBridge.value = newPageCount;
            }
          }
          function prev() {
            if (props.disabled)
              return;
            currentPageBridge.value -= 1;
            emit("prev-click", currentPageBridge.value);
          }
          function next() {
            if (props.disabled)
              return;
            currentPageBridge.value += 1;
            emit("next-click", currentPageBridge.value);
          }
          function addClass2(element, cls) {
            if (element) {
              if (!element.props) {
                element.props = {};
              }
              element.props.class = [element.props.class, cls].join(" ");
            }
          }
          provide(elPaginationKey, {
            pageCount: pageCountBridge,
            disabled: computed$1(() => props.disabled),
            currentPage: currentPageBridge,
            changeEvent: handleCurrentChange,
            handleSizeChange
          });
          return () => {
            var _a, _b;
            if (!assertValidUsage.value) {
              debugWarn(componentName, t("el.pagination.deprecationWarning"));
              return null;
            }
            if (!props.layout)
              return null;
            if (props.hideOnSinglePage && pageCountBridge.value <= 1)
              return null;
            const rootChildren = [];
            const rightWrapperChildren = [];
            const rightWrapperRoot = h$1("div", { class: ns.e("rightwrapper") }, rightWrapperChildren);
            const TEMPLATE_MAP = {
              prev: h$1(Prev, {
                disabled: props.disabled,
                currentPage: currentPageBridge.value,
                prevText: props.prevText,
                prevIcon: props.prevIcon,
                onClick: prev
              }),
              jumper: h$1(Jumper, {
                size: props.small ? "small" : "default"
              }),
              pager: h$1(Pager, {
                currentPage: currentPageBridge.value,
                pageCount: pageCountBridge.value,
                pagerCount: props.pagerCount,
                onChange: handleCurrentChange,
                disabled: props.disabled
              }),
              next: h$1(Next, {
                disabled: props.disabled,
                currentPage: currentPageBridge.value,
                pageCount: pageCountBridge.value,
                nextText: props.nextText,
                nextIcon: props.nextIcon,
                onClick: next
              }),
              sizes: h$1(Sizes, {
                pageSize: pageSizeBridge.value,
                pageSizes: props.pageSizes,
                popperClass: props.popperClass,
                disabled: props.disabled,
                teleported: props.teleported,
                size: props.small ? "small" : "default"
              }),
              slot: (_b = (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : null,
              total: h$1(Total, { total: isAbsent(props.total) ? 0 : props.total })
            };
            const components = props.layout.split(",").map((item) => item.trim());
            let haveRightWrapper = false;
            components.forEach((c2) => {
              if (c2 === "->") {
                haveRightWrapper = true;
                return;
              }
              if (!haveRightWrapper) {
                rootChildren.push(TEMPLATE_MAP[c2]);
              } else {
                rightWrapperChildren.push(TEMPLATE_MAP[c2]);
              }
            });
            addClass2(rootChildren[0], ns.is("first"));
            addClass2(rootChildren[rootChildren.length - 1], ns.is("last"));
            if (haveRightWrapper && rightWrapperChildren.length > 0) {
              addClass2(rightWrapperChildren[0], ns.is("first"));
              addClass2(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
              rootChildren.push(rightWrapperRoot);
            }
            return h$1("div", {
              class: [
                ns.b(),
                ns.is("background", props.background),
                {
                  [ns.m("small")]: props.small
                }
              ]
            }, rootChildren);
          };
        }
      });
      const ElPagination = withInstall(Pagination);
      const progressProps = buildProps({
        type: {
          type: String,
          default: "line",
          values: ["line", "circle", "dashboard"]
        },
        percentage: {
          type: Number,
          default: 0,
          validator: (val) => val >= 0 && val <= 100
        },
        status: {
          type: String,
          default: "",
          values: ["", "success", "exception", "warning"]
        },
        indeterminate: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 3
        },
        strokeWidth: {
          type: Number,
          default: 6
        },
        strokeLinecap: {
          type: definePropType(String),
          default: "round"
        },
        textInside: {
          type: Boolean,
          default: false
        },
        width: {
          type: Number,
          default: 126
        },
        showText: {
          type: Boolean,
          default: true
        },
        color: {
          type: definePropType([
            String,
            Array,
            Function
          ]),
          default: ""
        },
        striped: Boolean,
        stripedFlow: Boolean,
        format: {
          type: definePropType(Function),
          default: (percentage) => `${percentage}%`
        }
      });
      const _hoisted_1$i = ["aria-valuenow"];
      const _hoisted_2$f = { viewBox: "0 0 100 100" };
      const _hoisted_3$c = ["d", "stroke", "stroke-linecap", "stroke-width"];
      const _hoisted_4$6 = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"];
      const _hoisted_5$5 = { key: 0 };
      const __default__$6 = defineComponent({
        name: "ElProgress"
      });
      const _sfc_main$m = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: progressProps,
        setup(__props) {
          const props = __props;
          const STATUS_COLOR_MAP = {
            success: "#13ce66",
            exception: "#ff4949",
            warning: "#e6a23c",
            default: "#20a0ff"
          };
          const ns = useNamespace("progress");
          const barStyle = computed$1(() => ({
            width: `${props.percentage}%`,
            animationDuration: `${props.duration}s`,
            backgroundColor: getCurrentColor(props.percentage)
          }));
          const relativeStrokeWidth = computed$1(() => (props.strokeWidth / props.width * 100).toFixed(1));
          const radius = computed$1(() => {
            if (["circle", "dashboard"].includes(props.type)) {
              return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
            }
            return 0;
          });
          const trackPath = computed$1(() => {
            const r = radius.value;
            const isDashboard = props.type === "dashboard";
            return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
          });
          const perimeter = computed$1(() => 2 * Math.PI * radius.value);
          const rate = computed$1(() => props.type === "dashboard" ? 0.75 : 1);
          const strokeDashoffset = computed$1(() => {
            const offset = -1 * perimeter.value * (1 - rate.value) / 2;
            return `${offset}px`;
          });
          const trailPathStyle = computed$1(() => ({
            strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value
          }));
          const circlePathStyle = computed$1(() => ({
            strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value,
            transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
          }));
          const stroke = computed$1(() => {
            let ret;
            if (props.color) {
              ret = getCurrentColor(props.percentage);
            } else {
              ret = STATUS_COLOR_MAP[props.status] || STATUS_COLOR_MAP.default;
            }
            return ret;
          });
          const statusIcon = computed$1(() => {
            if (props.status === "warning") {
              return warning_filled_default;
            }
            if (props.type === "line") {
              return props.status === "success" ? circle_check_default : circle_close_default;
            } else {
              return props.status === "success" ? check_default : close_default;
            }
          });
          const progressTextSize = computed$1(() => {
            return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
          });
          const content = computed$1(() => props.format(props.percentage));
          function getColors(color) {
            const span = 100 / color.length;
            const seriesColors = color.map((seriesColor, index) => {
              if (isString(seriesColor)) {
                return {
                  color: seriesColor,
                  percentage: (index + 1) * span
                };
              }
              return seriesColor;
            });
            return seriesColors.sort((a2, b2) => a2.percentage - b2.percentage);
          }
          const getCurrentColor = (percentage) => {
            var _a;
            const { color } = props;
            if (isFunction$1(color)) {
              return color(percentage);
            } else if (isString(color)) {
              return color;
            } else {
              const colors = getColors(color);
              for (const color2 of colors) {
                if (color2.percentage > percentage)
                  return color2.color;
              }
              return (_a = colors[colors.length - 1]) == null ? void 0 : _a.color;
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(_ctx.type),
                unref(ns).is(_ctx.status),
                {
                  [unref(ns).m("without-text")]: !_ctx.showText,
                  [unref(ns).m("text-inside")]: _ctx.textInside
                }
              ]),
              role: "progressbar",
              "aria-valuenow": _ctx.percentage,
              "aria-valuemin": "0",
              "aria-valuemax": "100"
            }, [
              _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).b("bar"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).be("bar", "outer")),
                  style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
                }, [
                  createElementVNode("div", {
                    class: normalizeClass([
                      unref(ns).be("bar", "inner"),
                      { [unref(ns).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate },
                      { [unref(ns).bem("bar", "inner", "striped")]: _ctx.striped },
                      { [unref(ns).bem("bar", "inner", "striped-flow")]: _ctx.stripedFlow }
                    ]),
                    style: normalizeStyle(unref(barStyle))
                  }, [
                    (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(unref(ns).be("bar", "innerText"))
                    }, [
                      renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                        createElementVNode("span", null, toDisplayString(unref(content)), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 6)
                ], 6)
              ], 2)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).b("circle")),
                style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
              }, [
                (openBlock(), createElementBlock("svg", _hoisted_2$f, [
                  createElementVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "track")),
                    d: unref(trackPath),
                    stroke: `var(${unref(ns).cssVarName("fill-color-light")}, #e5e9f2)`,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    fill: "none",
                    style: normalizeStyle(unref(trailPathStyle))
                  }, null, 14, _hoisted_3$c),
                  createElementVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "path")),
                    d: unref(trackPath),
                    stroke: unref(stroke),
                    fill: "none",
                    opacity: _ctx.percentage ? 1 : 0,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    style: normalizeStyle(unref(circlePathStyle))
                  }, null, 14, _hoisted_4$6)
                ]))
              ], 6)),
              (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
                key: 2,
                class: normalizeClass(unref(ns).e("text")),
                style: normalizeStyle({ fontSize: `${unref(progressTextSize)}px` })
              }, [
                renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                  !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_5$5, toDisplayString(unref(content)), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(statusIcon))))
                    ]),
                    _: 1
                  }))
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 10, _hoisted_1$i);
          };
        }
      });
      var Progress = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__file", "progress.vue"]]);
      const ElProgress = withInstall(Progress);
      const switchProps = buildProps({
        modelValue: {
          type: [Boolean, String, Number],
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        },
        loading: {
          type: Boolean,
          default: false
        },
        size: {
          type: String,
          validator: isValidComponentSize
        },
        width: {
          type: [String, Number],
          default: ""
        },
        inlinePrompt: {
          type: Boolean,
          default: false
        },
        inactiveActionIcon: {
          type: iconPropType
        },
        activeActionIcon: {
          type: iconPropType
        },
        activeIcon: {
          type: iconPropType
        },
        inactiveIcon: {
          type: iconPropType
        },
        activeText: {
          type: String,
          default: ""
        },
        inactiveText: {
          type: String,
          default: ""
        },
        activeValue: {
          type: [Boolean, String, Number],
          default: true
        },
        inactiveValue: {
          type: [Boolean, String, Number],
          default: false
        },
        name: {
          type: String,
          default: ""
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        beforeChange: {
          type: definePropType(Function)
        },
        id: String,
        tabindex: {
          type: [String, Number]
        },
        label: {
          type: String,
          default: void 0
        }
      });
      const switchEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val),
        [CHANGE_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val),
        [INPUT_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val)
      };
      const _hoisted_1$h = ["onClick"];
      const _hoisted_2$e = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"];
      const _hoisted_3$b = ["aria-hidden"];
      const _hoisted_4$5 = ["aria-hidden"];
      const _hoisted_5$4 = ["aria-hidden"];
      const COMPONENT_NAME$1 = "ElSwitch";
      const __default__$5 = defineComponent({
        name: COMPONENT_NAME$1
      });
      const _sfc_main$l = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: switchProps,
        emits: switchEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const { formItem } = useFormItem();
          const switchSize = useFormSize();
          const ns = useNamespace("switch");
          const { inputId } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const switchDisabled = useFormDisabled(computed$1(() => props.loading));
          const isControlled = ref(props.modelValue !== false);
          const input = ref();
          const core = ref();
          const switchKls = computed$1(() => [
            ns.b(),
            ns.m(switchSize.value),
            ns.is("disabled", switchDisabled.value),
            ns.is("checked", checked.value)
          ]);
          const labelLeftKls = computed$1(() => [
            ns.e("label"),
            ns.em("label", "left"),
            ns.is("active", !checked.value)
          ]);
          const labelRightKls = computed$1(() => [
            ns.e("label"),
            ns.em("label", "right"),
            ns.is("active", checked.value)
          ]);
          const coreStyle = computed$1(() => ({
            width: addUnit(props.width)
          }));
          watch(() => props.modelValue, () => {
            isControlled.value = true;
          });
          const actualValue = computed$1(() => {
            return isControlled.value ? props.modelValue : false;
          });
          const checked = computed$1(() => actualValue.value === props.activeValue);
          if (![props.activeValue, props.inactiveValue].includes(actualValue.value)) {
            emit(UPDATE_MODEL_EVENT, props.inactiveValue);
            emit(CHANGE_EVENT, props.inactiveValue);
            emit(INPUT_EVENT, props.inactiveValue);
          }
          watch(checked, (val) => {
            var _a;
            input.value.checked = val;
            if (props.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch((err) => debugWarn());
            }
          });
          const handleChange = () => {
            const val = checked.value ? props.inactiveValue : props.activeValue;
            emit(UPDATE_MODEL_EVENT, val);
            emit(CHANGE_EVENT, val);
            emit(INPUT_EVENT, val);
            nextTick(() => {
              input.value.checked = checked.value;
            });
          };
          const switchValue = () => {
            if (switchDisabled.value)
              return;
            const { beforeChange } = props;
            if (!beforeChange) {
              handleChange();
              return;
            }
            const shouldChange = beforeChange();
            const isPromiseOrBool = [
              isPromise(shouldChange),
              isBoolean(shouldChange)
            ].includes(true);
            if (!isPromiseOrBool) {
              throwError(COMPONENT_NAME$1, "beforeChange must return type `Promise<boolean>` or `boolean`");
            }
            if (isPromise(shouldChange)) {
              shouldChange.then((result) => {
                if (result) {
                  handleChange();
                }
              }).catch((e) => {
              });
            } else if (shouldChange) {
              handleChange();
            }
          };
          const focus = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
          };
          onMounted(() => {
            input.value.checked = checked.value;
          });
          expose({
            focus,
            checked
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(switchKls)),
              onClick: withModifiers(switchValue, ["prevent"])
            }, [
              createElementVNode("input", {
                id: unref(inputId),
                ref_key: "input",
                ref: input,
                class: normalizeClass(unref(ns).e("input")),
                type: "checkbox",
                role: "switch",
                "aria-checked": unref(checked),
                "aria-disabled": unref(switchDisabled),
                "aria-label": _ctx.label,
                name: _ctx.name,
                "true-value": _ctx.activeValue,
                "false-value": _ctx.inactiveValue,
                disabled: unref(switchDisabled),
                tabindex: _ctx.tabindex,
                onChange: handleChange,
                onKeydown: withKeys(switchValue, ["enter"])
              }, null, 42, _hoisted_2$e),
              !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(unref(labelLeftKls))
              }, [
                _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  "aria-hidden": unref(checked)
                }, toDisplayString(_ctx.inactiveText), 9, _hoisted_3$b)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("span", {
                ref_key: "core",
                ref: core,
                class: normalizeClass(unref(ns).e("core")),
                style: normalizeStyle(unref(coreStyle))
              }, [
                _ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("inner"))
                }, [
                  _ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).is("icon"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(checked) ? _ctx.activeIcon : _ctx.inactiveIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : _ctx.activeText || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(ns).is("text")),
                    "aria-hidden": !unref(checked)
                  }, toDisplayString(unref(checked) ? _ctx.activeText : _ctx.inactiveText), 11, _hoisted_4$5)) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("action"))
                }, [
                  _ctx.loading ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(loading_default))
                    ]),
                    _: 1
                  }, 8, ["class"])) : unref(checked) ? renderSlot(_ctx.$slots, "active-action", { key: 1 }, () => [
                    _ctx.activeActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeActionIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]) : !unref(checked) ? renderSlot(_ctx.$slots, "inactive-action", { key: 2 }, () => [
                    _ctx.inactiveActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveActionIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]) : createCommentVNode("v-if", true)
                ], 2)
              ], 6),
              !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
                key: 1,
                class: normalizeClass(unref(labelRightKls))
              }, [
                _ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  "aria-hidden": !unref(checked)
                }, toDisplayString(_ctx.activeText), 9, _hoisted_5$4)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true)
            ], 10, _hoisted_1$h);
          };
        }
      });
      var Switch = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__file", "switch.vue"]]);
      const ElSwitch = withInstall(Switch);
      const getCell = function(event) {
        var _a;
        return (_a = event.target) == null ? void 0 : _a.closest("td");
      };
      const orderBy = function(array4, sortKey, reverse, sortMethod, sortBy) {
        if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
          return array4;
        }
        if (typeof reverse === "string") {
          reverse = reverse === "descending" ? -1 : 1;
        } else {
          reverse = reverse && reverse < 0 ? -1 : 1;
        }
        const getKey = sortMethod ? null : function(value, index) {
          if (sortBy) {
            if (!Array.isArray(sortBy)) {
              sortBy = [sortBy];
            }
            return sortBy.map((by) => {
              if (typeof by === "string") {
                return get(value, by);
              } else {
                return by(value, index, array4);
              }
            });
          }
          if (sortKey !== "$key") {
            if (isObject$1(value) && "$value" in value)
              value = value.$value;
          }
          return [isObject$1(value) ? get(value, sortKey) : value];
        };
        const compare = function(a2, b2) {
          if (sortMethod) {
            return sortMethod(a2.value, b2.value);
          }
          for (let i = 0, len = a2.key.length; i < len; i++) {
            if (a2.key[i] < b2.key[i]) {
              return -1;
            }
            if (a2.key[i] > b2.key[i]) {
              return 1;
            }
          }
          return 0;
        };
        return array4.map((value, index) => {
          return {
            value,
            index,
            key: getKey ? getKey(value, index) : null
          };
        }).sort((a2, b2) => {
          let order = compare(a2, b2);
          if (!order) {
            order = a2.index - b2.index;
          }
          return order * +reverse;
        }).map((item) => item.value);
      };
      const getColumnById = function(table, columnId) {
        let column = null;
        table.columns.forEach((item) => {
          if (item.id === columnId) {
            column = item;
          }
        });
        return column;
      };
      const getColumnByKey = function(table, columnKey) {
        let column = null;
        for (let i = 0; i < table.columns.length; i++) {
          const item = table.columns[i];
          if (item.columnKey === columnKey) {
            column = item;
            break;
          }
        }
        if (!column)
          throwError("ElTable", `No column matching with column-key: ${columnKey}`);
        return column;
      };
      const getColumnByCell = function(table, cell, namespace) {
        const matches = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
        if (matches) {
          return getColumnById(table, matches[0]);
        }
        return null;
      };
      const getRowIdentity = (row, rowKey) => {
        if (!row)
          throw new Error("Row is required when get row identity");
        if (typeof rowKey === "string") {
          if (!rowKey.includes(".")) {
            return `${row[rowKey]}`;
          }
          const key = rowKey.split(".");
          let current = row;
          for (const element of key) {
            current = current[element];
          }
          return `${current}`;
        } else if (typeof rowKey === "function") {
          return rowKey.call(null, row);
        }
      };
      const getKeysMap = function(array4, rowKey) {
        const arrayMap2 = {};
        (array4 || []).forEach((row, index) => {
          arrayMap2[getRowIdentity(row, rowKey)] = { row, index };
        });
        return arrayMap2;
      };
      function mergeOptions(defaults, config) {
        const options = {};
        let key;
        for (key in defaults) {
          options[key] = defaults[key];
        }
        for (key in config) {
          if (hasOwn(config, key)) {
            const value = config[key];
            if (typeof value !== "undefined") {
              options[key] = value;
            }
          }
        }
        return options;
      }
      function parseWidth(width) {
        if (width === "")
          return width;
        if (width !== void 0) {
          width = Number.parseInt(width, 10);
          if (Number.isNaN(width)) {
            width = "";
          }
        }
        return width;
      }
      function parseMinWidth(minWidth) {
        if (minWidth === "")
          return minWidth;
        if (minWidth !== void 0) {
          minWidth = parseWidth(minWidth);
          if (Number.isNaN(minWidth)) {
            minWidth = 80;
          }
        }
        return minWidth;
      }
      function parseHeight(height) {
        if (typeof height === "number") {
          return height;
        }
        if (typeof height === "string") {
          if (/^\d+(?:px)?$/.test(height)) {
            return Number.parseInt(height, 10);
          } else {
            return height;
          }
        }
        return null;
      }
      function compose(...funcs) {
        if (funcs.length === 0) {
          return (arg) => arg;
        }
        if (funcs.length === 1) {
          return funcs[0];
        }
        return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
      }
      function toggleRowStatus(statusArr, row, newVal) {
        let changed = false;
        const index = statusArr.indexOf(row);
        const included = index !== -1;
        const toggleStatus = (type4) => {
          if (type4 === "add") {
            statusArr.push(row);
          } else {
            statusArr.splice(index, 1);
          }
          changed = true;
          if (isArray$1(row.children)) {
            row.children.forEach((item) => {
              toggleRowStatus(statusArr, item, newVal != null ? newVal : !included);
            });
          }
        };
        if (isBoolean(newVal)) {
          if (newVal && !included) {
            toggleStatus("add");
          } else if (!newVal && included) {
            toggleStatus("remove");
          }
        } else {
          included ? toggleStatus("remove") : toggleStatus("add");
        }
        return changed;
      }
      function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
        const isNil2 = (array4) => !(Array.isArray(array4) && array4.length);
        function _walker(parent, children, level) {
          cb(parent, children, level);
          children.forEach((item) => {
            if (item[lazyKey]) {
              cb(item, null, level + 1);
              return;
            }
            const children2 = item[childrenKey];
            if (!isNil2(children2)) {
              _walker(item, children2, level + 1);
            }
          });
        }
        root2.forEach((item) => {
          if (item[lazyKey]) {
            cb(item, null, 0);
            return;
          }
          const children = item[childrenKey];
          if (!isNil2(children)) {
            _walker(item, children, 0);
          }
        });
      }
      let removePopper = null;
      function createTablePopper(props, popperContent, trigger, table) {
        if ((removePopper == null ? void 0 : removePopper.trigger) === trigger) {
          return;
        }
        removePopper == null ? void 0 : removePopper();
        const parentNode = table == null ? void 0 : table.refs.tableWrapper;
        const ns = parentNode == null ? void 0 : parentNode.dataset.prefix;
        const popperOptions = {
          strategy: "fixed",
          ...props.popperOptions
        };
        const vm = createVNode(ElTooltip, {
          content: popperContent,
          virtualTriggering: true,
          virtualRef: trigger,
          appendTo: parentNode,
          placement: "top",
          transition: "none",
          offset: 0,
          hideAfter: 0,
          ...props,
          popperOptions,
          onHide: () => {
            removePopper == null ? void 0 : removePopper();
          }
        });
        vm.appContext = { ...table.appContext, ...table };
        const container = document.createElement("div");
        render(vm, container);
        vm.component.exposed.onOpen();
        const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns}-scrollbar__wrap`);
        removePopper = () => {
          render(null, container);
          scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", removePopper);
          removePopper = null;
        };
        removePopper.trigger = trigger;
        scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", removePopper);
      }
      function getCurrentColumns(column) {
        if (column.children) {
          return flatMap(column.children, getCurrentColumns);
        } else {
          return [column];
        }
      }
      function getColSpan(colSpan, column) {
        return colSpan + column.colSpan;
      }
      const isFixedColumn = (index, fixed, store, realColumns) => {
        let start = 0;
        let after = index;
        const columns = store.states.columns.value;
        if (realColumns) {
          const curColumns = getCurrentColumns(realColumns[index]);
          const preColumns = columns.slice(0, columns.indexOf(curColumns[0]));
          start = preColumns.reduce(getColSpan, 0);
          after = start + curColumns.reduce(getColSpan, 0) - 1;
        } else {
          start = index;
        }
        let fixedLayout;
        switch (fixed) {
          case "left":
            if (after < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            }
            break;
          case "right":
            if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
            break;
          default:
            if (after < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            } else if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
        }
        return fixedLayout ? {
          direction: fixedLayout,
          start,
          after
        } : {};
      };
      const getFixedColumnsClass = (namespace, index, fixed, store, realColumns, offset = 0) => {
        const classes = [];
        const { direction, start, after } = isFixedColumn(index, fixed, store, realColumns);
        if (direction) {
          const isLeft = direction === "left";
          classes.push(`${namespace}-fixed-column--${direction}`);
          if (isLeft && after + offset === store.states.fixedLeafColumnsLength.value - 1) {
            classes.push("is-last-column");
          } else if (!isLeft && start - offset === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
            classes.push("is-first-column");
          }
        }
        return classes;
      };
      function getOffset(offset, column) {
        return offset + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
      }
      const getFixedColumnOffset = (index, fixed, store, realColumns) => {
        const {
          direction,
          start = 0,
          after = 0
        } = isFixedColumn(index, fixed, store, realColumns);
        if (!direction) {
          return;
        }
        const styles = {};
        const isLeft = direction === "left";
        const columns = store.states.columns.value;
        if (isLeft) {
          styles.left = columns.slice(0, start).reduce(getOffset, 0);
        } else {
          styles.right = columns.slice(after + 1).reverse().reduce(getOffset, 0);
        }
        return styles;
      };
      const ensurePosition = (style, key) => {
        if (!style)
          return;
        if (!Number.isNaN(style[key])) {
          style[key] = `${style[key]}px`;
        }
      };
      function useExpand(watcherData) {
        const instance = getCurrentInstance();
        const defaultExpandAll = ref(false);
        const expandRows = ref([]);
        const updateExpandRows = () => {
          const data = watcherData.data.value || [];
          const rowKey = watcherData.rowKey.value;
          if (defaultExpandAll.value) {
            expandRows.value = data.slice();
          } else if (rowKey) {
            const expandRowsMap = getKeysMap(expandRows.value, rowKey);
            expandRows.value = data.reduce((prev, row) => {
              const rowId = getRowIdentity(row, rowKey);
              const rowInfo = expandRowsMap[rowId];
              if (rowInfo) {
                prev.push(row);
              }
              return prev;
            }, []);
          } else {
            expandRows.value = [];
          }
        };
        const toggleRowExpansion = (row, expanded) => {
          const changed = toggleRowStatus(expandRows.value, row, expanded);
          if (changed) {
            instance.emit("expand-change", row, expandRows.value.slice());
          }
        };
        const setExpandRowKeys = (rowKeys) => {
          instance.store.assertRowKey();
          const data = watcherData.data.value || [];
          const rowKey = watcherData.rowKey.value;
          const keysMap = getKeysMap(data, rowKey);
          expandRows.value = rowKeys.reduce((prev, cur) => {
            const info = keysMap[cur];
            if (info) {
              prev.push(info.row);
            }
            return prev;
          }, []);
        };
        const isRowExpanded = (row) => {
          const rowKey = watcherData.rowKey.value;
          if (rowKey) {
            const expandMap = getKeysMap(expandRows.value, rowKey);
            return !!expandMap[getRowIdentity(row, rowKey)];
          }
          return expandRows.value.includes(row);
        };
        return {
          updateExpandRows,
          toggleRowExpansion,
          setExpandRowKeys,
          isRowExpanded,
          states: {
            expandRows,
            defaultExpandAll
          }
        };
      }
      function useCurrent(watcherData) {
        const instance = getCurrentInstance();
        const _currentRowKey = ref(null);
        const currentRow = ref(null);
        const setCurrentRowKey = (key) => {
          instance.store.assertRowKey();
          _currentRowKey.value = key;
          setCurrentRowByKey(key);
        };
        const restoreCurrentRowKey = () => {
          _currentRowKey.value = null;
        };
        const setCurrentRowByKey = (key) => {
          const { data, rowKey } = watcherData;
          let _currentRow = null;
          if (rowKey.value) {
            _currentRow = (unref(data) || []).find((item) => getRowIdentity(item, rowKey.value) === key);
          }
          currentRow.value = _currentRow;
          instance.emit("current-change", currentRow.value, null);
        };
        const updateCurrentRow = (_currentRow) => {
          const oldCurrentRow = currentRow.value;
          if (_currentRow && _currentRow !== oldCurrentRow) {
            currentRow.value = _currentRow;
            instance.emit("current-change", currentRow.value, oldCurrentRow);
            return;
          }
          if (!_currentRow && oldCurrentRow) {
            currentRow.value = null;
            instance.emit("current-change", null, oldCurrentRow);
          }
        };
        const updateCurrentRowData = () => {
          const rowKey = watcherData.rowKey.value;
          const data = watcherData.data.value || [];
          const oldCurrentRow = currentRow.value;
          if (!data.includes(oldCurrentRow) && oldCurrentRow) {
            if (rowKey) {
              const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
              setCurrentRowByKey(currentRowKey);
            } else {
              currentRow.value = null;
            }
            if (currentRow.value === null) {
              instance.emit("current-change", null, oldCurrentRow);
            }
          } else if (_currentRowKey.value) {
            setCurrentRowByKey(_currentRowKey.value);
            restoreCurrentRowKey();
          }
        };
        return {
          setCurrentRowKey,
          restoreCurrentRowKey,
          setCurrentRowByKey,
          updateCurrentRow,
          updateCurrentRowData,
          states: {
            _currentRowKey,
            currentRow
          }
        };
      }
      function useTree(watcherData) {
        const expandRowKeys = ref([]);
        const treeData = ref({});
        const indent = ref(16);
        const lazy = ref(false);
        const lazyTreeNodeMap = ref({});
        const lazyColumnIdentifier = ref("hasChildren");
        const childrenColumnName = ref("children");
        const instance = getCurrentInstance();
        const normalizedData = computed$1(() => {
          if (!watcherData.rowKey.value)
            return {};
          const data = watcherData.data.value || [];
          return normalize(data);
        });
        const normalizedLazyNode = computed$1(() => {
          const rowKey = watcherData.rowKey.value;
          const keys2 = Object.keys(lazyTreeNodeMap.value);
          const res = {};
          if (!keys2.length)
            return res;
          keys2.forEach((key) => {
            if (lazyTreeNodeMap.value[key].length) {
              const item = { children: [] };
              lazyTreeNodeMap.value[key].forEach((row) => {
                const currentRowKey = getRowIdentity(row, rowKey);
                item.children.push(currentRowKey);
                if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
                  res[currentRowKey] = { children: [] };
                }
              });
              res[key] = item;
            }
          });
          return res;
        });
        const normalize = (data) => {
          const rowKey = watcherData.rowKey.value;
          const res = {};
          walkTreeNode(data, (parent, children, level) => {
            const parentId = getRowIdentity(parent, rowKey);
            if (Array.isArray(children)) {
              res[parentId] = {
                children: children.map((row) => getRowIdentity(row, rowKey)),
                level
              };
            } else if (lazy.value) {
              res[parentId] = {
                children: [],
                lazy: true,
                level
              };
            }
          }, childrenColumnName.value, lazyColumnIdentifier.value);
          return res;
        };
        const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a) => (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value)()) => {
          var _a2;
          const nested = normalizedData.value;
          const normalizedLazyNode_ = normalizedLazyNode.value;
          const keys2 = Object.keys(nested);
          const newTreeData = {};
          if (keys2.length) {
            const oldTreeData = unref(treeData);
            const rootLazyRowKeys = [];
            const getExpanded = (oldValue, key) => {
              if (ifChangeExpandRowKeys) {
                if (expandRowKeys.value) {
                  return ifExpandAll || expandRowKeys.value.includes(key);
                } else {
                  return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
                }
              } else {
                const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
                return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
              }
            };
            keys2.forEach((key) => {
              const oldValue = oldTreeData[key];
              const newValue = { ...nested[key] };
              newValue.expanded = getExpanded(oldValue, key);
              if (newValue.lazy) {
                const { loaded = false, loading = false } = oldValue || {};
                newValue.loaded = !!loaded;
                newValue.loading = !!loading;
                rootLazyRowKeys.push(key);
              }
              newTreeData[key] = newValue;
            });
            const lazyKeys = Object.keys(normalizedLazyNode_);
            if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
              lazyKeys.forEach((key) => {
                const oldValue = oldTreeData[key];
                const lazyNodeChildren = normalizedLazyNode_[key].children;
                if (rootLazyRowKeys.includes(key)) {
                  if (newTreeData[key].children.length !== 0) {
                    throw new Error("[ElTable]children must be an empty array.");
                  }
                  newTreeData[key].children = lazyNodeChildren;
                } else {
                  const { loaded = false, loading = false } = oldValue || {};
                  newTreeData[key] = {
                    lazy: true,
                    loaded: !!loaded,
                    loading: !!loading,
                    expanded: getExpanded(oldValue, key),
                    children: lazyNodeChildren,
                    level: ""
                  };
                }
              });
            }
          }
          treeData.value = newTreeData;
          (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
        };
        watch(() => expandRowKeys.value, () => {
          updateTreeData(true);
        });
        watch(() => normalizedData.value, () => {
          updateTreeData();
        });
        watch(() => normalizedLazyNode.value, () => {
          updateTreeData();
        });
        const updateTreeExpandKeys = (value) => {
          expandRowKeys.value = value;
          updateTreeData();
        };
        const toggleTreeExpansion = (row, expanded) => {
          instance.store.assertRowKey();
          const rowKey = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey);
          const data = id && treeData.value[id];
          if (id && data && "expanded" in data) {
            const oldExpanded = data.expanded;
            expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
            treeData.value[id].expanded = expanded;
            if (oldExpanded !== expanded) {
              instance.emit("expand-change", row, expanded);
            }
            instance.store.updateTableScrollY();
          }
        };
        const loadOrToggle = (row) => {
          instance.store.assertRowKey();
          const rowKey = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey);
          const data = treeData.value[id];
          if (lazy.value && data && "loaded" in data && !data.loaded) {
            loadData(row, id, data);
          } else {
            toggleTreeExpansion(row, void 0);
          }
        };
        const loadData = (row, key, treeNode) => {
          const { load } = instance.props;
          if (load && !treeData.value[key].loaded) {
            treeData.value[key].loading = true;
            load(row, treeNode, (data) => {
              if (!Array.isArray(data)) {
                throw new TypeError("[ElTable] data must be an array");
              }
              treeData.value[key].loading = false;
              treeData.value[key].loaded = true;
              treeData.value[key].expanded = true;
              if (data.length) {
                lazyTreeNodeMap.value[key] = data;
              }
              instance.emit("expand-change", row, true);
            });
          }
        };
        return {
          loadData,
          loadOrToggle,
          toggleTreeExpansion,
          updateTreeExpandKeys,
          updateTreeData,
          normalize,
          states: {
            expandRowKeys,
            treeData,
            indent,
            lazy,
            lazyTreeNodeMap,
            lazyColumnIdentifier,
            childrenColumnName
          }
        };
      }
      const sortData = (data, states) => {
        const sortingColumn = states.sortingColumn;
        if (!sortingColumn || typeof sortingColumn.sortable === "string") {
          return data;
        }
        return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
      };
      const doFlattenColumns = (columns) => {
        const result = [];
        columns.forEach((column) => {
          if (column.children && column.children.length > 0) {
            result.push.apply(result, doFlattenColumns(column.children));
          } else {
            result.push(column);
          }
        });
        return result;
      };
      function useWatcher$1() {
        var _a;
        const instance = getCurrentInstance();
        const { size: tableSize } = toRefs((_a = instance.proxy) == null ? void 0 : _a.$props);
        const rowKey = ref(null);
        const data = ref([]);
        const _data = ref([]);
        const isComplex = ref(false);
        const _columns = ref([]);
        const originColumns = ref([]);
        const columns = ref([]);
        const fixedColumns = ref([]);
        const rightFixedColumns = ref([]);
        const leafColumns = ref([]);
        const fixedLeafColumns = ref([]);
        const rightFixedLeafColumns = ref([]);
        const updateOrderFns = [];
        const leafColumnsLength = ref(0);
        const fixedLeafColumnsLength = ref(0);
        const rightFixedLeafColumnsLength = ref(0);
        const isAllSelected = ref(false);
        const selection = ref([]);
        const reserveSelection = ref(false);
        const selectOnIndeterminate = ref(false);
        const selectable = ref(null);
        const filters = ref({});
        const filteredData = ref(null);
        const sortingColumn = ref(null);
        const sortProp = ref(null);
        const sortOrder = ref(null);
        const hoverRow = ref(null);
        watch(data, () => instance.state && scheduleLayout(false), {
          deep: true
        });
        const assertRowKey = () => {
          if (!rowKey.value)
            throw new Error("[ElTable] prop row-key is required");
        };
        const updateChildFixed = (column) => {
          var _a2;
          (_a2 = column.children) == null ? void 0 : _a2.forEach((childColumn) => {
            childColumn.fixed = column.fixed;
            updateChildFixed(childColumn);
          });
        };
        const updateColumns = () => {
          _columns.value.forEach((column) => {
            updateChildFixed(column);
          });
          fixedColumns.value = _columns.value.filter((column) => column.fixed === true || column.fixed === "left");
          rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
          if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
            _columns.value[0].fixed = true;
            fixedColumns.value.unshift(_columns.value[0]);
          }
          const notFixedColumns = _columns.value.filter((column) => !column.fixed);
          originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
          const leafColumns2 = doFlattenColumns(notFixedColumns);
          const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
          const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
          leafColumnsLength.value = leafColumns2.length;
          fixedLeafColumnsLength.value = fixedLeafColumns2.length;
          rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
          columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
          isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
        };
        const scheduleLayout = (needUpdateColumns, immediate = false) => {
          if (needUpdateColumns) {
            updateColumns();
          }
          if (immediate) {
            instance.state.doLayout();
          } else {
            instance.state.debouncedUpdateLayout();
          }
        };
        const isSelected = (row) => {
          return selection.value.includes(row);
        };
        const clearSelection = () => {
          isAllSelected.value = false;
          const oldSelection = selection.value;
          if (oldSelection.length) {
            selection.value = [];
            instance.emit("selection-change", []);
          }
        };
        const cleanSelection = () => {
          let deleted;
          if (rowKey.value) {
            deleted = [];
            const selectedMap = getKeysMap(selection.value, rowKey.value);
            const dataMap = getKeysMap(data.value, rowKey.value);
            for (const key in selectedMap) {
              if (hasOwn(selectedMap, key) && !dataMap[key]) {
                deleted.push(selectedMap[key].row);
              }
            }
          } else {
            deleted = selection.value.filter((item) => !data.value.includes(item));
          }
          if (deleted.length) {
            const newSelection = selection.value.filter((item) => !deleted.includes(item));
            selection.value = newSelection;
            instance.emit("selection-change", newSelection.slice());
          }
        };
        const getSelectionRows = () => {
          return (selection.value || []).slice();
        };
        const toggleRowSelection = (row, selected = void 0, emitChange = true) => {
          const changed = toggleRowStatus(selection.value, row, selected);
          if (changed) {
            const newSelection = (selection.value || []).slice();
            if (emitChange) {
              instance.emit("select", newSelection, row);
            }
            instance.emit("selection-change", newSelection);
          }
        };
        const _toggleAllSelection = () => {
          var _a2, _b;
          const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
          isAllSelected.value = value;
          let selectionChanged = false;
          let childrenCount = 0;
          const rowKey2 = (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.rowKey.value;
          data.value.forEach((row, index) => {
            const rowIndex = index + childrenCount;
            if (selectable.value) {
              if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value)) {
                selectionChanged = true;
              }
            } else {
              if (toggleRowStatus(selection.value, row, value)) {
                selectionChanged = true;
              }
            }
            childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));
          });
          if (selectionChanged) {
            instance.emit("selection-change", selection.value ? selection.value.slice() : []);
          }
          instance.emit("select-all", selection.value);
        };
        const updateSelectionByRowKey = () => {
          const selectedMap = getKeysMap(selection.value, rowKey.value);
          data.value.forEach((row) => {
            const rowId = getRowIdentity(row, rowKey.value);
            const rowInfo = selectedMap[rowId];
            if (rowInfo) {
              selection.value[rowInfo.index] = row;
            }
          });
        };
        const updateAllSelected = () => {
          var _a2, _b, _c;
          if (((_a2 = data.value) == null ? void 0 : _a2.length) === 0) {
            isAllSelected.value = false;
            return;
          }
          let selectedMap;
          if (rowKey.value) {
            selectedMap = getKeysMap(selection.value, rowKey.value);
          }
          const isSelected2 = function(row) {
            if (selectedMap) {
              return !!selectedMap[getRowIdentity(row, rowKey.value)];
            } else {
              return selection.value.includes(row);
            }
          };
          let isAllSelected_ = true;
          let selectedCount = 0;
          let childrenCount = 0;
          for (let i = 0, j = (data.value || []).length; i < j; i++) {
            const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
            const rowIndex = i + childrenCount;
            const item = data.value[i];
            const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);
            if (!isSelected2(item)) {
              if (!selectable.value || isRowSelectable) {
                isAllSelected_ = false;
                break;
              }
            } else {
              selectedCount++;
            }
            childrenCount += getChildrenCount(getRowIdentity(item, keyProp));
          }
          if (selectedCount === 0)
            isAllSelected_ = false;
          isAllSelected.value = isAllSelected_;
        };
        const getChildrenCount = (rowKey2) => {
          var _a2;
          if (!instance || !instance.store)
            return 0;
          const { treeData } = instance.store.states;
          let count = 0;
          const children = (_a2 = treeData.value[rowKey2]) == null ? void 0 : _a2.children;
          if (children) {
            count += children.length;
            children.forEach((childKey) => {
              count += getChildrenCount(childKey);
            });
          }
          return count;
        };
        const updateFilters = (columns2, values) => {
          if (!Array.isArray(columns2)) {
            columns2 = [columns2];
          }
          const filters_ = {};
          columns2.forEach((col) => {
            filters.value[col.id] = values;
            filters_[col.columnKey || col.id] = values;
          });
          return filters_;
        };
        const updateSort = (column, prop, order) => {
          if (sortingColumn.value && sortingColumn.value !== column) {
            sortingColumn.value.order = null;
          }
          sortingColumn.value = column;
          sortProp.value = prop;
          sortOrder.value = order;
        };
        const execFilter = () => {
          let sourceData = unref(_data);
          Object.keys(filters.value).forEach((columnId) => {
            const values = filters.value[columnId];
            if (!values || values.length === 0)
              return;
            const column = getColumnById({
              columns: columns.value
            }, columnId);
            if (column && column.filterMethod) {
              sourceData = sourceData.filter((row) => {
                return values.some((value) => column.filterMethod.call(null, value, row, column));
              });
            }
          });
          filteredData.value = sourceData;
        };
        const execSort = () => {
          data.value = sortData(filteredData.value, {
            sortingColumn: sortingColumn.value,
            sortProp: sortProp.value,
            sortOrder: sortOrder.value
          });
        };
        const execQuery = (ignore = void 0) => {
          if (!(ignore && ignore.filter)) {
            execFilter();
          }
          execSort();
        };
        const clearFilter = (columnKeys) => {
          const { tableHeaderRef } = instance.refs;
          if (!tableHeaderRef)
            return;
          const panels = Object.assign({}, tableHeaderRef.filterPanels);
          const keys2 = Object.keys(panels);
          if (!keys2.length)
            return;
          if (typeof columnKeys === "string") {
            columnKeys = [columnKeys];
          }
          if (Array.isArray(columnKeys)) {
            const columns_ = columnKeys.map((key) => getColumnByKey({
              columns: columns.value
            }, key));
            keys2.forEach((key) => {
              const column = columns_.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            instance.store.commit("filterChange", {
              column: columns_,
              values: [],
              silent: true,
              multi: true
            });
          } else {
            keys2.forEach((key) => {
              const column = columns.value.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            filters.value = {};
            instance.store.commit("filterChange", {
              column: {},
              values: [],
              silent: true
            });
          }
        };
        const clearSort = () => {
          if (!sortingColumn.value)
            return;
          updateSort(null, null, null);
          instance.store.commit("changeSortCondition", {
            silent: true
          });
        };
        const {
          setExpandRowKeys,
          toggleRowExpansion,
          updateExpandRows,
          states: expandStates,
          isRowExpanded
        } = useExpand({
          data,
          rowKey
        });
        const {
          updateTreeExpandKeys,
          toggleTreeExpansion,
          updateTreeData,
          loadOrToggle,
          states: treeStates
        } = useTree({
          data,
          rowKey
        });
        const {
          updateCurrentRowData,
          updateCurrentRow,
          setCurrentRowKey,
          states: currentData
        } = useCurrent({
          data,
          rowKey
        });
        const setExpandRowKeysAdapter = (val) => {
          setExpandRowKeys(val);
          updateTreeExpandKeys(val);
        };
        const toggleRowExpansionAdapter = (row, expanded) => {
          const hasExpandColumn = columns.value.some(({ type: type4 }) => type4 === "expand");
          if (hasExpandColumn) {
            toggleRowExpansion(row, expanded);
          } else {
            toggleTreeExpansion(row, expanded);
          }
        };
        return {
          assertRowKey,
          updateColumns,
          scheduleLayout,
          isSelected,
          clearSelection,
          cleanSelection,
          getSelectionRows,
          toggleRowSelection,
          _toggleAllSelection,
          toggleAllSelection: null,
          updateSelectionByRowKey,
          updateAllSelected,
          updateFilters,
          updateCurrentRow,
          updateSort,
          execFilter,
          execSort,
          execQuery,
          clearFilter,
          clearSort,
          toggleRowExpansion,
          setExpandRowKeysAdapter,
          setCurrentRowKey,
          toggleRowExpansionAdapter,
          isRowExpanded,
          updateExpandRows,
          updateCurrentRowData,
          loadOrToggle,
          updateTreeData,
          states: {
            tableSize,
            rowKey,
            data,
            _data,
            isComplex,
            _columns,
            originColumns,
            columns,
            fixedColumns,
            rightFixedColumns,
            leafColumns,
            fixedLeafColumns,
            rightFixedLeafColumns,
            updateOrderFns,
            leafColumnsLength,
            fixedLeafColumnsLength,
            rightFixedLeafColumnsLength,
            isAllSelected,
            selection,
            reserveSelection,
            selectOnIndeterminate,
            selectable,
            filters,
            filteredData,
            sortingColumn,
            sortProp,
            sortOrder,
            hoverRow,
            ...expandStates,
            ...treeStates,
            ...currentData
          }
        };
      }
      function replaceColumn(array4, column) {
        return array4.map((item) => {
          var _a;
          if (item.id === column.id) {
            return column;
          } else if ((_a = item.children) == null ? void 0 : _a.length) {
            item.children = replaceColumn(item.children, column);
          }
          return item;
        });
      }
      function sortColumn(array4) {
        array4.forEach((item) => {
          var _a, _b;
          item.no = (_a = item.getColumnIndex) == null ? void 0 : _a.call(item);
          if ((_b = item.children) == null ? void 0 : _b.length) {
            sortColumn(item.children);
          }
        });
        array4.sort((cur, pre) => cur.no - pre.no);
      }
      function useStore() {
        const instance = getCurrentInstance();
        const watcher = useWatcher$1();
        const ns = useNamespace("table");
        const mutations = {
          setData(states, data) {
            const dataInstanceChanged = unref(states._data) !== data;
            states.data.value = data;
            states._data.value = data;
            instance.store.execQuery();
            instance.store.updateCurrentRowData();
            instance.store.updateExpandRows();
            instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
            if (unref(states.reserveSelection)) {
              instance.store.assertRowKey();
              instance.store.updateSelectionByRowKey();
            } else {
              if (dataInstanceChanged) {
                instance.store.clearSelection();
              } else {
                instance.store.cleanSelection();
              }
            }
            instance.store.updateAllSelected();
            if (instance.$ready) {
              instance.store.scheduleLayout();
            }
          },
          insertColumn(states, column, parent, updateColumnOrder) {
            const array4 = unref(states._columns);
            let newColumns = [];
            if (!parent) {
              array4.push(column);
              newColumns = array4;
            } else {
              if (parent && !parent.children) {
                parent.children = [];
              }
              parent.children.push(column);
              newColumns = replaceColumn(array4, parent);
            }
            sortColumn(newColumns);
            states._columns.value = newColumns;
            states.updateOrderFns.push(updateColumnOrder);
            if (column.type === "selection") {
              states.selectable.value = column.selectable;
              states.reserveSelection.value = column.reserveSelection;
            }
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          updateColumnOrder(states, column) {
            var _a;
            const newColumnIndex = (_a = column.getColumnIndex) == null ? void 0 : _a.call(column);
            if (newColumnIndex === column.no)
              return;
            sortColumn(states._columns.value);
            if (instance.$ready) {
              instance.store.updateColumns();
            }
          },
          removeColumn(states, column, parent, updateColumnOrder) {
            const array4 = unref(states._columns) || [];
            if (parent) {
              parent.children.splice(parent.children.findIndex((item) => item.id === column.id), 1);
              nextTick(() => {
                var _a;
                if (((_a = parent.children) == null ? void 0 : _a.length) === 0) {
                  delete parent.children;
                }
              });
              states._columns.value = replaceColumn(array4, parent);
            } else {
              const index = array4.indexOf(column);
              if (index > -1) {
                array4.splice(index, 1);
                states._columns.value = array4;
              }
            }
            const updateFnIndex = states.updateOrderFns.indexOf(updateColumnOrder);
            updateFnIndex > -1 && states.updateOrderFns.splice(updateFnIndex, 1);
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          sort(states, options) {
            const { prop, order, init } = options;
            if (prop) {
              const column = unref(states.columns).find((column2) => column2.property === prop);
              if (column) {
                column.order = order;
                instance.store.updateSort(column, prop, order);
                instance.store.commit("changeSortCondition", { init });
              }
            }
          },
          changeSortCondition(states, options) {
            const { sortingColumn, sortProp, sortOrder } = states;
            const columnValue = unref(sortingColumn), propValue = unref(sortProp), orderValue = unref(sortOrder);
            if (orderValue === null) {
              states.sortingColumn.value = null;
              states.sortProp.value = null;
            }
            const ignore = { filter: true };
            instance.store.execQuery(ignore);
            if (!options || !(options.silent || options.init)) {
              instance.emit("sort-change", {
                column: columnValue,
                prop: propValue,
                order: orderValue
              });
            }
            instance.store.updateTableScrollY();
          },
          filterChange(_states, options) {
            const { column, values, silent } = options;
            const newFilters = instance.store.updateFilters(column, values);
            instance.store.execQuery();
            if (!silent) {
              instance.emit("filter-change", newFilters);
            }
            instance.store.updateTableScrollY();
          },
          toggleAllSelection() {
            instance.store.toggleAllSelection();
          },
          rowSelectedChanged(_states, row) {
            instance.store.toggleRowSelection(row);
            instance.store.updateAllSelected();
          },
          setHoverRow(states, row) {
            states.hoverRow.value = row;
          },
          setCurrentRow(_states, row) {
            instance.store.updateCurrentRow(row);
          }
        };
        const commit = function(name, ...args) {
          const mutations2 = instance.store.mutations;
          if (mutations2[name]) {
            mutations2[name].apply(instance, [instance.store.states].concat(args));
          } else {
            throw new Error(`Action not found: ${name}`);
          }
        };
        const updateTableScrollY = function() {
          nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
        };
        return {
          ns,
          ...watcher,
          mutations,
          commit,
          updateTableScrollY
        };
      }
      const InitialStateMap = {
        rowKey: "rowKey",
        defaultExpandAll: "defaultExpandAll",
        selectOnIndeterminate: "selectOnIndeterminate",
        indent: "indent",
        lazy: "lazy",
        data: "data",
        ["treeProps.hasChildren"]: {
          key: "lazyColumnIdentifier",
          default: "hasChildren"
        },
        ["treeProps.children"]: {
          key: "childrenColumnName",
          default: "children"
        }
      };
      function createStore(table, props) {
        if (!table) {
          throw new Error("Table is required.");
        }
        const store = useStore();
        store.toggleAllSelection = debounce(store._toggleAllSelection, 10);
        Object.keys(InitialStateMap).forEach((key) => {
          handleValue(getArrKeysValue(props, key), key, store);
        });
        proxyTableProps(store, props);
        return store;
      }
      function proxyTableProps(store, props) {
        Object.keys(InitialStateMap).forEach((key) => {
          watch(() => getArrKeysValue(props, key), (value) => {
            handleValue(value, key, store);
          });
        });
      }
      function handleValue(value, propsKey, store) {
        let newVal = value;
        let storeKey = InitialStateMap[propsKey];
        if (typeof InitialStateMap[propsKey] === "object") {
          storeKey = storeKey.key;
          newVal = newVal || InitialStateMap[propsKey].default;
        }
        store.states[storeKey].value = newVal;
      }
      function getArrKeysValue(props, keys2) {
        if (keys2.includes(".")) {
          const keyList = keys2.split(".");
          let value = props;
          keyList.forEach((key) => {
            value = value[key];
          });
          return value;
        } else {
          return props[keys2];
        }
      }
      class TableLayout {
        constructor(options) {
          this.observers = [];
          this.table = null;
          this.store = null;
          this.columns = [];
          this.fit = true;
          this.showHeader = true;
          this.height = ref(null);
          this.scrollX = ref(false);
          this.scrollY = ref(false);
          this.bodyWidth = ref(null);
          this.fixedWidth = ref(null);
          this.rightFixedWidth = ref(null);
          this.gutterWidth = 0;
          for (const name in options) {
            if (hasOwn(options, name)) {
              if (isRef(this[name])) {
                this[name].value = options[name];
              } else {
                this[name] = options[name];
              }
            }
          }
          if (!this.table) {
            throw new Error("Table is required for Table Layout");
          }
          if (!this.store) {
            throw new Error("Store is required for Table Layout");
          }
        }
        updateScrollY() {
          const height = this.height.value;
          if (height === null)
            return false;
          const scrollBarRef = this.table.refs.scrollBarRef;
          if (this.table.vnode.el && (scrollBarRef == null ? void 0 : scrollBarRef.wrapRef)) {
            let scrollY = true;
            const prevScrollY = this.scrollY.value;
            scrollY = scrollBarRef.wrapRef.scrollHeight > scrollBarRef.wrapRef.clientHeight;
            this.scrollY.value = scrollY;
            return prevScrollY !== scrollY;
          }
          return false;
        }
        setHeight(value, prop = "height") {
          if (!isClient)
            return;
          const el = this.table.vnode.el;
          value = parseHeight(value);
          this.height.value = Number(value);
          if (!el && (value || value === 0))
            return nextTick(() => this.setHeight(value, prop));
          if (typeof value === "number") {
            el.style[prop] = `${value}px`;
            this.updateElsHeight();
          } else if (typeof value === "string") {
            el.style[prop] = value;
            this.updateElsHeight();
          }
        }
        setMaxHeight(value) {
          this.setHeight(value, "max-height");
        }
        getFlattenColumns() {
          const flattenColumns = [];
          const columns = this.table.store.states.columns.value;
          columns.forEach((column) => {
            if (column.isColumnGroup) {
              flattenColumns.push.apply(flattenColumns, column.columns);
            } else {
              flattenColumns.push(column);
            }
          });
          return flattenColumns;
        }
        updateElsHeight() {
          this.updateScrollY();
          this.notifyObservers("scrollable");
        }
        headerDisplayNone(elm) {
          if (!elm)
            return true;
          let headerChild = elm;
          while (headerChild.tagName !== "DIV") {
            if (getComputedStyle(headerChild).display === "none") {
              return true;
            }
            headerChild = headerChild.parentElement;
          }
          return false;
        }
        updateColumnsWidth() {
          if (!isClient)
            return;
          const fit = this.fit;
          const bodyWidth = this.table.vnode.el.clientWidth;
          let bodyMinWidth = 0;
          const flattenColumns = this.getFlattenColumns();
          const flexColumns = flattenColumns.filter((column) => typeof column.width !== "number");
          flattenColumns.forEach((column) => {
            if (typeof column.width === "number" && column.realWidth)
              column.realWidth = null;
          });
          if (flexColumns.length > 0 && fit) {
            flattenColumns.forEach((column) => {
              bodyMinWidth += Number(column.width || column.minWidth || 80);
            });
            if (bodyMinWidth <= bodyWidth) {
              this.scrollX.value = false;
              const totalFlexWidth = bodyWidth - bodyMinWidth;
              if (flexColumns.length === 1) {
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
              } else {
                const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);
                const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
                let noneFirstWidth = 0;
                flexColumns.forEach((column, index) => {
                  if (index === 0)
                    return;
                  const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
                  noneFirstWidth += flexWidth;
                  column.realWidth = Number(column.minWidth || 80) + flexWidth;
                });
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
              }
            } else {
              this.scrollX.value = true;
              flexColumns.forEach((column) => {
                column.realWidth = Number(column.minWidth);
              });
            }
            this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
            this.table.state.resizeState.value.width = this.bodyWidth.value;
          } else {
            flattenColumns.forEach((column) => {
              if (!column.width && !column.minWidth) {
                column.realWidth = 80;
              } else {
                column.realWidth = Number(column.width || column.minWidth);
              }
              bodyMinWidth += column.realWidth;
            });
            this.scrollX.value = bodyMinWidth > bodyWidth;
            this.bodyWidth.value = bodyMinWidth;
          }
          const fixedColumns = this.store.states.fixedColumns.value;
          if (fixedColumns.length > 0) {
            let fixedWidth = 0;
            fixedColumns.forEach((column) => {
              fixedWidth += Number(column.realWidth || column.width);
            });
            this.fixedWidth.value = fixedWidth;
          }
          const rightFixedColumns = this.store.states.rightFixedColumns.value;
          if (rightFixedColumns.length > 0) {
            let rightFixedWidth = 0;
            rightFixedColumns.forEach((column) => {
              rightFixedWidth += Number(column.realWidth || column.width);
            });
            this.rightFixedWidth.value = rightFixedWidth;
          }
          this.notifyObservers("columns");
        }
        addObserver(observer) {
          this.observers.push(observer);
        }
        removeObserver(observer) {
          const index = this.observers.indexOf(observer);
          if (index !== -1) {
            this.observers.splice(index, 1);
          }
        }
        notifyObservers(event) {
          const observers = this.observers;
          observers.forEach((observer) => {
            var _a, _b;
            switch (event) {
              case "columns":
                (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);
                break;
              case "scrollable":
                (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
                break;
              default:
                throw new Error(`Table Layout don't have event ${event}.`);
            }
          });
        }
      }
      const { CheckboxGroup: ElCheckboxGroup } = ElCheckbox;
      const _sfc_main$k = defineComponent({
        name: "ElTableFilterPanel",
        components: {
          ElCheckbox,
          ElCheckboxGroup,
          ElScrollbar,
          ElTooltip,
          ElIcon,
          ArrowDown: arrow_down_default,
          ArrowUp: arrow_up_default
        },
        directives: { ClickOutside },
        props: {
          placement: {
            type: String,
            default: "bottom-start"
          },
          store: {
            type: Object
          },
          column: {
            type: Object
          },
          upDataColumn: {
            type: Function
          }
        },
        setup(props) {
          const instance = getCurrentInstance();
          const { t } = useLocale();
          const ns = useNamespace("table-filter");
          const parent = instance == null ? void 0 : instance.parent;
          if (!parent.filterPanels.value[props.column.id]) {
            parent.filterPanels.value[props.column.id] = instance;
          }
          const tooltipVisible = ref(false);
          const tooltip = ref(null);
          const filters = computed$1(() => {
            return props.column && props.column.filters;
          });
          const filterClassName = computed$1(() => {
            if (props.column.filterClassName) {
              return `${ns.b()} ${props.column.filterClassName}`;
            }
            return ns.b();
          });
          const filterValue = computed$1({
            get: () => {
              var _a;
              return (((_a = props.column) == null ? void 0 : _a.filteredValue) || [])[0];
            },
            set: (value) => {
              if (filteredValue.value) {
                if (typeof value !== "undefined" && value !== null) {
                  filteredValue.value.splice(0, 1, value);
                } else {
                  filteredValue.value.splice(0, 1);
                }
              }
            }
          });
          const filteredValue = computed$1({
            get() {
              if (props.column) {
                return props.column.filteredValue || [];
              }
              return [];
            },
            set(value) {
              if (props.column) {
                props.upDataColumn("filteredValue", value);
              }
            }
          });
          const multiple = computed$1(() => {
            if (props.column) {
              return props.column.filterMultiple;
            }
            return true;
          });
          const isActive = (filter) => {
            return filter.value === filterValue.value;
          };
          const hidden = () => {
            tooltipVisible.value = false;
          };
          const showFilterPanel = (e) => {
            e.stopPropagation();
            tooltipVisible.value = !tooltipVisible.value;
          };
          const hideFilterPanel = () => {
            tooltipVisible.value = false;
          };
          const handleConfirm = () => {
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleReset = () => {
            filteredValue.value = [];
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleSelect = (_filterValue) => {
            filterValue.value = _filterValue;
            if (typeof _filterValue !== "undefined" && _filterValue !== null) {
              confirmFilter(filteredValue.value);
            } else {
              confirmFilter([]);
            }
            hidden();
          };
          const confirmFilter = (filteredValue2) => {
            props.store.commit("filterChange", {
              column: props.column,
              values: filteredValue2
            });
            props.store.updateAllSelected();
          };
          watch(tooltipVisible, (value) => {
            if (props.column) {
              props.upDataColumn("filterOpened", value);
            }
          }, {
            immediate: true
          });
          const popperPaneRef = computed$1(() => {
            var _a, _b;
            return (_b = (_a = tooltip.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
          });
          return {
            tooltipVisible,
            multiple,
            filterClassName,
            filteredValue,
            filterValue,
            filters,
            handleConfirm,
            handleReset,
            handleSelect,
            isActive,
            t,
            ns,
            showFilterPanel,
            hideFilterPanel,
            popperPaneRef,
            tooltip
          };
        }
      });
      const _hoisted_1$g = { key: 0 };
      const _hoisted_2$d = ["disabled"];
      const _hoisted_3$a = ["label", "onClick"];
      function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_checkbox = resolveComponent("el-checkbox");
        const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_arrow_up = resolveComponent("arrow-up");
        const _component_arrow_down = resolveComponent("arrow-down");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _directive_click_outside = resolveDirective("click-outside");
        return openBlock(), createBlock(_component_el_tooltip, {
          ref: "tooltip",
          visible: _ctx.tooltipVisible,
          offset: 0,
          placement: _ctx.placement,
          "show-arrow": false,
          "stop-popper-mouse-event": false,
          teleported: "",
          effect: "light",
          pure: "",
          "popper-class": _ctx.filterClassName,
          persistent: ""
        }, {
          content: withCtx(() => [
            _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_1$g, [
              createElementVNode("div", {
                class: normalizeClass(_ctx.ns.e("content"))
              }, [
                createVNode(_component_el_scrollbar, {
                  "wrap-class": _ctx.ns.e("wrap")
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_checkbox_group, {
                      modelValue: _ctx.filteredValue,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filteredValue = $event),
                      class: normalizeClass(_ctx.ns.e("checkbox-group"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
                          return openBlock(), createBlock(_component_el_checkbox, {
                            key: filter.value,
                            value: filter.value
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(filter.text), 1)
                            ]),
                            _: 2
                          }, 1032, ["value"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue", "class"])
                  ]),
                  _: 1
                }, 8, ["wrap-class"])
              ], 2),
              createElementVNode("div", {
                class: normalizeClass(_ctx.ns.e("bottom"))
              }, [
                createElementVNode("button", {
                  class: normalizeClass({ [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0 }),
                  disabled: _ctx.filteredValue.length === 0,
                  type: "button",
                  onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
                }, toDisplayString(_ctx.t("el.table.confirmFilter")), 11, _hoisted_2$d),
                createElementVNode("button", {
                  type: "button",
                  onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
                }, toDisplayString(_ctx.t("el.table.resetFilter")), 1)
              ], 2)
            ])) : (openBlock(), createElementBlock("ul", {
              key: 1,
              class: normalizeClass(_ctx.ns.e("list"))
            }, [
              createElementVNode("li", {
                class: normalizeClass([
                  _ctx.ns.e("list-item"),
                  {
                    [_ctx.ns.is("active")]: _ctx.filterValue === void 0 || _ctx.filterValue === null
                  }
                ]),
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleSelect(null))
              }, toDisplayString(_ctx.t("el.table.clearFilter")), 3),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
                return openBlock(), createElementBlock("li", {
                  key: filter.value,
                  class: normalizeClass([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter))]),
                  label: filter.value,
                  onClick: ($event) => _ctx.handleSelect(filter.value)
                }, toDisplayString(filter.text), 11, _hoisted_3$a);
              }), 128))
            ], 2))
          ]),
          default: withCtx(() => [
            withDirectives((openBlock(), createElementBlock("span", {
              class: normalizeClass([
                `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
                `${_ctx.ns.namespace.value}-none-outline`
              ]),
              onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
            }, [
              createVNode(_component_el_icon, null, {
                default: withCtx(() => [
                  _ctx.column.filterOpened ? (openBlock(), createBlock(_component_arrow_up, { key: 0 })) : (openBlock(), createBlock(_component_arrow_down, { key: 1 }))
                ]),
                _: 1
              })
            ], 2)), [
              [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
            ])
          ]),
          _: 1
        }, 8, ["visible", "placement", "popper-class"]);
      }
      var FilterPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$8], ["__file", "filter-panel.vue"]]);
      function useLayoutObserver(root2) {
        const instance = getCurrentInstance();
        onBeforeMount(() => {
          tableLayout.value.addObserver(instance);
        });
        onMounted(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUpdated(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUnmounted(() => {
          tableLayout.value.removeObserver(instance);
        });
        const tableLayout = computed$1(() => {
          const layout = root2.layout;
          if (!layout) {
            throw new Error("Can not find table layout.");
          }
          return layout;
        });
        const onColumnsChange = (layout) => {
          var _a;
          const cols = ((_a = root2.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col")) || [];
          if (!cols.length)
            return;
          const flattenColumns = layout.getFlattenColumns();
          const columnsMap = {};
          flattenColumns.forEach((column) => {
            columnsMap[column.id] = column;
          });
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            const name = col.getAttribute("name");
            const column = columnsMap[name];
            if (column) {
              col.setAttribute("width", column.realWidth || column.width);
            }
          }
        };
        const onScrollableChange = (layout) => {
          var _a, _b;
          const cols = ((_a = root2.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col[name=gutter]")) || [];
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            col.setAttribute("width", layout.scrollY.value ? layout.gutterWidth : "0");
          }
          const ths = ((_b = root2.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];
          for (let i = 0, j = ths.length; i < j; i++) {
            const th = ths[i];
            th.style.width = layout.scrollY.value ? `${layout.gutterWidth}px` : "0";
            th.style.display = layout.scrollY.value ? "" : "none";
          }
        };
        return {
          tableLayout: tableLayout.value,
          onColumnsChange,
          onScrollableChange
        };
      }
      const TABLE_INJECTION_KEY = Symbol("ElTable");
      function useEvent(props, emit) {
        const instance = getCurrentInstance();
        const parent = inject(TABLE_INJECTION_KEY);
        const handleFilterClick = (event) => {
          event.stopPropagation();
          return;
        };
        const handleHeaderClick = (event, column) => {
          if (!column.filters && column.sortable) {
            handleSortClick(event, column, false);
          } else if (column.filterable && !column.sortable) {
            handleFilterClick(event);
          }
          parent == null ? void 0 : parent.emit("header-click", column, event);
        };
        const handleHeaderContextMenu = (event, column) => {
          parent == null ? void 0 : parent.emit("header-contextmenu", column, event);
        };
        const draggingColumn = ref(null);
        const dragging = ref(false);
        const dragState = ref({});
        const handleMouseDown = (event, column) => {
          if (!isClient)
            return;
          if (column.children && column.children.length > 0)
            return;
          if (draggingColumn.value && props.border) {
            dragging.value = true;
            const table = parent;
            emit("set-drag-visible", true);
            const tableEl = table == null ? void 0 : table.vnode.el;
            const tableLeft = tableEl.getBoundingClientRect().left;
            const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
            const columnRect = columnEl.getBoundingClientRect();
            const minLeft = columnRect.left - tableLeft + 30;
            addClass(columnEl, "noclick");
            dragState.value = {
              startMouseLeft: event.clientX,
              startLeft: columnRect.right - tableLeft,
              startColumnLeft: columnRect.left - tableLeft,
              tableLeft
            };
            const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
            resizeProxy.style.left = `${dragState.value.startLeft}px`;
            document.onselectstart = function() {
              return false;
            };
            document.ondragstart = function() {
              return false;
            };
            const handleMouseMove2 = (event2) => {
              const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
              const proxyLeft = dragState.value.startLeft + deltaLeft;
              resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
            };
            const handleMouseUp = () => {
              if (dragging.value) {
                const { startColumnLeft, startLeft } = dragState.value;
                const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
                const columnWidth = finalLeft - startColumnLeft;
                column.width = column.realWidth = columnWidth;
                table == null ? void 0 : table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
                requestAnimationFrame(() => {
                  props.store.scheduleLayout(false, true);
                });
                document.body.style.cursor = "";
                dragging.value = false;
                draggingColumn.value = null;
                dragState.value = {};
                emit("set-drag-visible", false);
              }
              document.removeEventListener("mousemove", handleMouseMove2);
              document.removeEventListener("mouseup", handleMouseUp);
              document.onselectstart = null;
              document.ondragstart = null;
              setTimeout(() => {
                removeClass(columnEl, "noclick");
              }, 0);
            };
            document.addEventListener("mousemove", handleMouseMove2);
            document.addEventListener("mouseup", handleMouseUp);
          }
        };
        const handleMouseMove = (event, column) => {
          if (column.children && column.children.length > 0)
            return;
          const el = event.target;
          if (!isElement(el)) {
            return;
          }
          const target = el == null ? void 0 : el.closest("th");
          if (!column || !column.resizable)
            return;
          if (!dragging.value && props.border) {
            const rect = target.getBoundingClientRect();
            const bodyStyle = document.body.style;
            if (rect.width > 12 && rect.right - event.pageX < 8) {
              bodyStyle.cursor = "col-resize";
              if (hasClass(target, "is-sortable")) {
                target.style.cursor = "col-resize";
              }
              draggingColumn.value = column;
            } else if (!dragging.value) {
              bodyStyle.cursor = "";
              if (hasClass(target, "is-sortable")) {
                target.style.cursor = "pointer";
              }
              draggingColumn.value = null;
            }
          }
        };
        const handleMouseOut = () => {
          if (!isClient)
            return;
          document.body.style.cursor = "";
        };
        const toggleOrder = ({ order, sortOrders }) => {
          if (order === "")
            return sortOrders[0];
          const index = sortOrders.indexOf(order || null);
          return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
        };
        const handleSortClick = (event, column, givenOrder) => {
          var _a;
          event.stopPropagation();
          const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
          const target = (_a = event.target) == null ? void 0 : _a.closest("th");
          if (target) {
            if (hasClass(target, "noclick")) {
              removeClass(target, "noclick");
              return;
            }
          }
          if (!column.sortable)
            return;
          const states = props.store.states;
          let sortProp = states.sortProp.value;
          let sortOrder;
          const sortingColumn = states.sortingColumn.value;
          if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
            if (sortingColumn) {
              sortingColumn.order = null;
            }
            states.sortingColumn.value = column;
            sortProp = column.property;
          }
          if (!order) {
            sortOrder = column.order = null;
          } else {
            sortOrder = column.order = order;
          }
          states.sortProp.value = sortProp;
          states.sortOrder.value = sortOrder;
          parent == null ? void 0 : parent.store.commit("changeSortCondition");
        };
        return {
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleMouseOut,
          handleSortClick,
          handleFilterClick
        };
      }
      function useStyle$2(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getHeaderRowStyle = (rowIndex) => {
          const headerRowStyle = parent == null ? void 0 : parent.props.headerRowStyle;
          if (typeof headerRowStyle === "function") {
            return headerRowStyle.call(null, { rowIndex });
          }
          return headerRowStyle;
        };
        const getHeaderRowClass = (rowIndex) => {
          const classes = [];
          const headerRowClassName = parent == null ? void 0 : parent.props.headerRowClassName;
          if (typeof headerRowClassName === "string") {
            classes.push(headerRowClassName);
          } else if (typeof headerRowClassName === "function") {
            classes.push(headerRowClassName.call(null, { rowIndex }));
          }
          return classes.join(" ");
        };
        const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
          var _a;
          let headerCellStyles = (_a = parent == null ? void 0 : parent.props.headerCellStyle) != null ? _a : {};
          if (typeof headerCellStyles === "function") {
            headerCellStyles = headerCellStyles.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, column.fixed, props.store, row);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, headerCellStyles, fixedStyle);
        };
        const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, column.fixed, props.store, row);
          const classes = [
            column.id,
            column.order,
            column.headerAlign,
            column.className,
            column.labelClassName,
            ...fixedClasses
          ];
          if (!column.children) {
            classes.push("is-leaf");
          }
          if (column.sortable) {
            classes.push("is-sortable");
          }
          const headerCellClassName = parent == null ? void 0 : parent.props.headerCellClassName;
          if (typeof headerCellClassName === "string") {
            classes.push(headerCellClassName);
          } else if (typeof headerCellClassName === "function") {
            classes.push(headerCellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        return {
          getHeaderRowStyle,
          getHeaderRowClass,
          getHeaderCellStyle,
          getHeaderCellClass
        };
      }
      const getAllColumns = (columns) => {
        const result = [];
        columns.forEach((column) => {
          if (column.children) {
            result.push(column);
            result.push.apply(result, getAllColumns(column.children));
          } else {
            result.push(column);
          }
        });
        return result;
      };
      const convertToRows = (originColumns) => {
        let maxLevel = 1;
        const traverse = (column, parent) => {
          if (parent) {
            column.level = parent.level + 1;
            if (maxLevel < column.level) {
              maxLevel = column.level;
            }
          }
          if (column.children) {
            let colSpan = 0;
            column.children.forEach((subColumn) => {
              traverse(subColumn, column);
              colSpan += subColumn.colSpan;
            });
            column.colSpan = colSpan;
          } else {
            column.colSpan = 1;
          }
        };
        originColumns.forEach((column) => {
          column.level = 1;
          traverse(column, void 0);
        });
        const rows = [];
        for (let i = 0; i < maxLevel; i++) {
          rows.push([]);
        }
        const allColumns = getAllColumns(originColumns);
        allColumns.forEach((column) => {
          if (!column.children) {
            column.rowSpan = maxLevel - column.level + 1;
          } else {
            column.rowSpan = 1;
            column.children.forEach((col) => col.isSubColumn = true);
          }
          rows[column.level - 1].push(column);
        });
        return rows;
      };
      function useUtils$1(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const columnRows = computed$1(() => {
          return convertToRows(props.store.states.originColumns.value);
        });
        const isGroup = computed$1(() => {
          const result = columnRows.value.length > 1;
          if (result && parent) {
            parent.state.isGroup.value = true;
          }
          return result;
        });
        const toggleAllSelection = (event) => {
          event.stopPropagation();
          parent == null ? void 0 : parent.store.commit("toggleAllSelection");
        };
        return {
          isGroup,
          toggleAllSelection,
          columnRows
        };
      }
      var TableHeader = defineComponent({
        name: "ElTableHeader",
        components: {
          ElCheckbox
        },
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          }
        },
        setup(props, { emit }) {
          const instance = getCurrentInstance();
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const filterPanels = ref({});
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
          onMounted(async () => {
            await nextTick();
            await nextTick();
            const { prop, order } = props.defaultSort;
            parent == null ? void 0 : parent.store.commit("sort", { prop, order, init: true });
          });
          const {
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick
          } = useEvent(props, emit);
          const {
            getHeaderRowStyle,
            getHeaderRowClass,
            getHeaderCellStyle,
            getHeaderCellClass
          } = useStyle$2(props);
          const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props);
          instance.state = {
            onColumnsChange,
            onScrollableChange
          };
          instance.filterPanels = filterPanels;
          return {
            ns,
            filterPanels,
            onColumnsChange,
            onScrollableChange,
            columnRows,
            getHeaderRowClass,
            getHeaderRowStyle,
            getHeaderCellClass,
            getHeaderCellStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick,
            isGroup,
            toggleAllSelection
          };
        },
        render() {
          const {
            ns,
            isGroup,
            columnRows,
            getHeaderCellStyle,
            getHeaderCellClass,
            getHeaderRowClass,
            getHeaderRowStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleSortClick,
            handleMouseOut,
            store,
            $parent
          } = this;
          let rowSpan = 1;
          return h$1("thead", {
            class: { [ns.is("group")]: isGroup }
          }, columnRows.map((subColumns, rowIndex) => h$1("tr", {
            class: getHeaderRowClass(rowIndex),
            key: rowIndex,
            style: getHeaderRowStyle(rowIndex)
          }, subColumns.map((column, cellIndex) => {
            if (column.rowSpan > rowSpan) {
              rowSpan = column.rowSpan;
            }
            return h$1("th", {
              class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
              colspan: column.colSpan,
              key: `${column.id}-thead`,
              rowspan: column.rowSpan,
              style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
              onClick: ($event) => handleHeaderClick($event, column),
              onContextmenu: ($event) => handleHeaderContextMenu($event, column),
              onMousedown: ($event) => handleMouseDown($event, column),
              onMousemove: ($event) => handleMouseMove($event, column),
              onMouseout: handleMouseOut
            }, [
              h$1("div", {
                class: [
                  "cell",
                  column.filteredValue && column.filteredValue.length > 0 ? "highlight" : ""
                ]
              }, [
                column.renderHeader ? column.renderHeader({
                  column,
                  $index: cellIndex,
                  store,
                  _self: $parent
                }) : column.label,
                column.sortable && h$1("span", {
                  onClick: ($event) => handleSortClick($event, column),
                  class: "caret-wrapper"
                }, [
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "ascending"),
                    class: "sort-caret ascending"
                  }),
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "descending"),
                    class: "sort-caret descending"
                  })
                ]),
                column.filterable && h$1(FilterPanel, {
                  store,
                  placement: column.filterPlacement || "bottom-start",
                  column,
                  upDataColumn: (key, value) => {
                    column[key] = value;
                  }
                })
              ])
            ]);
          }))));
        }
      });
      function useEvents(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const tooltipContent = ref("");
        const tooltipTrigger = ref(h$1("div"));
        const handleEvent = (event, row, name) => {
          var _a;
          const table = parent;
          const cell = getCell(event);
          let column;
          const namespace = (_a = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a.dataset.prefix;
          if (cell) {
            column = getColumnByCell({
              columns: props.store.states.columns.value
            }, cell, namespace);
            if (column) {
              table == null ? void 0 : table.emit(`cell-${name}`, row, column, cell, event);
            }
          }
          table == null ? void 0 : table.emit(`row-${name}`, row, column, event);
        };
        const handleDoubleClick = (event, row) => {
          handleEvent(event, row, "dblclick");
        };
        const handleClick = (event, row) => {
          props.store.commit("setCurrentRow", row);
          handleEvent(event, row, "click");
        };
        const handleContextMenu = (event, row) => {
          handleEvent(event, row, "contextmenu");
        };
        const handleMouseEnter = debounce((index) => {
          props.store.commit("setHoverRow", index);
        }, 30);
        const handleMouseLeave = debounce(() => {
          props.store.commit("setHoverRow", null);
        }, 30);
        const getPadding = (el) => {
          const style = window.getComputedStyle(el, null);
          const paddingLeft = Number.parseInt(style.paddingLeft, 10) || 0;
          const paddingRight = Number.parseInt(style.paddingRight, 10) || 0;
          const paddingTop = Number.parseInt(style.paddingTop, 10) || 0;
          const paddingBottom = Number.parseInt(style.paddingBottom, 10) || 0;
          return {
            left: paddingLeft,
            right: paddingRight,
            top: paddingTop,
            bottom: paddingBottom
          };
        };
        const toggleRowClassByCell = (rowSpan, event, toggle) => {
          let node = event.target.parentNode;
          while (rowSpan > 1) {
            node = node == null ? void 0 : node.nextSibling;
            if (!node || node.nodeName !== "TR")
              break;
            toggle(node, "hover-row hover-fixed-row");
            rowSpan--;
          }
        };
        const handleCellMouseEnter = (event, row, tooltipOptions) => {
          var _a;
          const table = parent;
          const cell = getCell(event);
          const namespace = (_a = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a.dataset.prefix;
          if (cell) {
            const column = getColumnByCell({
              columns: props.store.states.columns.value
            }, cell, namespace);
            if (cell.rowSpan > 1) {
              toggleRowClassByCell(cell.rowSpan, event, addClass);
            }
            const hoverState = table.hoverState = { cell, column, row };
            table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
          }
          if (!tooltipOptions) {
            return;
          }
          const cellChild = event.target.querySelector(".cell");
          if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
            return;
          }
          const range3 = document.createRange();
          range3.setStart(cellChild, 0);
          range3.setEnd(cellChild, cellChild.childNodes.length);
          let rangeWidth = range3.getBoundingClientRect().width;
          let rangeHeight = range3.getBoundingClientRect().height;
          const offsetWidth = rangeWidth - Math.floor(rangeWidth);
          if (offsetWidth < 1e-3) {
            rangeWidth = Math.floor(rangeWidth);
          }
          const offsetHeight = rangeHeight - Math.floor(rangeHeight);
          if (offsetHeight < 1e-3) {
            rangeHeight = Math.floor(rangeHeight);
          }
          const { top, left, right, bottom } = getPadding(cellChild);
          const horizontalPadding = left + right;
          const verticalPadding = top + bottom;
          if (rangeWidth + horizontalPadding > cellChild.offsetWidth || rangeHeight + verticalPadding > cellChild.offsetHeight || cellChild.scrollWidth > cellChild.offsetWidth) {
            createTablePopper(tooltipOptions, cell.innerText || cell.textContent, cell, table);
          }
        };
        const handleCellMouseLeave = (event) => {
          const cell = getCell(event);
          if (!cell)
            return;
          if (cell.rowSpan > 1) {
            toggleRowClassByCell(cell.rowSpan, event, removeClass);
          }
          const oldHoverState = parent == null ? void 0 : parent.hoverState;
          parent == null ? void 0 : parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
        };
        return {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        };
      }
      function useStyles(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getRowStyle = (row, rowIndex) => {
          const rowStyle = parent == null ? void 0 : parent.props.rowStyle;
          if (typeof rowStyle === "function") {
            return rowStyle.call(null, {
              row,
              rowIndex
            });
          }
          return rowStyle || null;
        };
        const getRowClass = (row, rowIndex) => {
          const classes = [ns.e("row")];
          if ((parent == null ? void 0 : parent.props.highlightCurrentRow) && row === props.store.states.currentRow.value) {
            classes.push("current-row");
          }
          if (props.stripe && rowIndex % 2 === 1) {
            classes.push(ns.em("row", "striped"));
          }
          const rowClassName = parent == null ? void 0 : parent.props.rowClassName;
          if (typeof rowClassName === "string") {
            classes.push(rowClassName);
          } else if (typeof rowClassName === "function") {
            classes.push(rowClassName.call(null, {
              row,
              rowIndex
            }));
          }
          return classes;
        };
        const getCellStyle = (rowIndex, columnIndex, row, column) => {
          const cellStyle = parent == null ? void 0 : parent.props.cellStyle;
          let cellStyles = cellStyle != null ? cellStyle : {};
          if (typeof cellStyle === "function") {
            cellStyles = cellStyle.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, props == null ? void 0 : props.fixed, props.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, cellStyles, fixedStyle);
        };
        const getCellClass = (rowIndex, columnIndex, row, column, offset) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, props == null ? void 0 : props.fixed, props.store, void 0, offset);
          const classes = [column.id, column.align, column.className, ...fixedClasses];
          const cellClassName = parent == null ? void 0 : parent.props.cellClassName;
          if (typeof cellClassName === "string") {
            classes.push(cellClassName);
          } else if (typeof cellClassName === "function") {
            classes.push(cellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        const getSpan = (row, column, rowIndex, columnIndex) => {
          let rowspan = 1;
          let colspan = 1;
          const fn2 = parent == null ? void 0 : parent.props.spanMethod;
          if (typeof fn2 === "function") {
            const result = fn2({
              row,
              column,
              rowIndex,
              columnIndex
            });
            if (Array.isArray(result)) {
              rowspan = result[0];
              colspan = result[1];
            } else if (typeof result === "object") {
              rowspan = result.rowspan;
              colspan = result.colspan;
            }
          }
          return { rowspan, colspan };
        };
        const getColspanRealWidth = (columns, colspan, index) => {
          if (colspan < 1) {
            return columns[index].realWidth;
          }
          const widthArr = columns.map(({ realWidth, width }) => realWidth || width).slice(index, index + colspan);
          return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
        };
        return {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        };
      }
      function useRender$1(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        } = useEvents(props);
        const {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        } = useStyles(props);
        const firstDefaultColumnIndex = computed$1(() => {
          return props.store.states.columns.value.findIndex(({ type: type4 }) => type4 === "default");
        });
        const getKeyOfRow = (row, index) => {
          const rowKey = parent.props.rowKey;
          if (rowKey) {
            return getRowIdentity(row, rowKey);
          }
          return index;
        };
        const rowRender = (row, $index, treeRowData, expanded = false) => {
          const { tooltipEffect, tooltipOptions, store } = props;
          const { indent, columns } = store.states;
          const rowClasses = getRowClass(row, $index);
          let display = true;
          if (treeRowData) {
            rowClasses.push(ns.em("row", `level-${treeRowData.level}`));
            display = treeRowData.display;
          }
          const displayStyle = display ? null : {
            display: "none"
          };
          return h$1("tr", {
            style: [displayStyle, getRowStyle(row, $index)],
            class: rowClasses,
            key: getKeyOfRow(row, $index),
            onDblclick: ($event) => handleDoubleClick($event, row),
            onClick: ($event) => handleClick($event, row),
            onContextmenu: ($event) => handleContextMenu($event, row),
            onMouseenter: () => handleMouseEnter($index),
            onMouseleave: handleMouseLeave
          }, columns.value.map((column, cellIndex) => {
            const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
            if (!rowspan || !colspan) {
              return null;
            }
            const columnData = Object.assign({}, column);
            columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
            const data = {
              store: props.store,
              _self: props.context || parent,
              column: columnData,
              row,
              $index,
              cellIndex,
              expanded
            };
            if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
              data.treeNode = {
                indent: treeRowData.level * indent.value,
                level: treeRowData.level
              };
              if (typeof treeRowData.expanded === "boolean") {
                data.treeNode.expanded = treeRowData.expanded;
                if ("loading" in treeRowData) {
                  data.treeNode.loading = treeRowData.loading;
                }
                if ("noLazyChildren" in treeRowData) {
                  data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
                }
              }
            }
            const baseKey = `${$index},${cellIndex}`;
            const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
            const tdChildren = cellChildren(cellIndex, column, data);
            const mergedTooltipOptions = column.showOverflowTooltip && merge$1({
              effect: tooltipEffect
            }, tooltipOptions, column.showOverflowTooltip);
            return h$1("td", {
              style: getCellStyle($index, cellIndex, row, column),
              class: getCellClass($index, cellIndex, row, column, colspan - 1),
              key: `${patchKey}${baseKey}`,
              rowspan,
              colspan,
              onMouseenter: ($event) => handleCellMouseEnter($event, row, mergedTooltipOptions),
              onMouseleave: handleCellMouseLeave
            }, [tdChildren]);
          }));
        };
        const cellChildren = (cellIndex, column, data) => {
          return column.renderCell(data);
        };
        const wrappedRowRender = (row, $index) => {
          const store = props.store;
          const { isRowExpanded, assertRowKey } = store;
          const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey } = store.states;
          const columns = store.states.columns.value;
          const hasExpandColumn = columns.some(({ type: type4 }) => type4 === "expand");
          if (hasExpandColumn) {
            const expanded = isRowExpanded(row);
            const tr = rowRender(row, $index, void 0, expanded);
            const renderExpanded = parent.renderExpanded;
            if (expanded) {
              if (!renderExpanded) {
                console.error("[Element Error]renderExpanded is required.");
                return tr;
              }
              return [
                [
                  tr,
                  h$1("tr", {
                    key: `expanded-row__${tr.key}`
                  }, [
                    h$1("td", {
                      colspan: columns.length,
                      class: `${ns.e("cell")} ${ns.e("expanded-cell")}`
                    }, [renderExpanded({ row, $index, store, expanded })])
                  ])
                ]
              ];
            } else {
              return [[tr]];
            }
          } else if (Object.keys(treeData.value).length) {
            assertRowKey();
            const key = getRowIdentity(row, rowKey.value);
            let cur = treeData.value[key];
            let treeRowData = null;
            if (cur) {
              treeRowData = {
                expanded: cur.expanded,
                level: cur.level,
                display: true
              };
              if (typeof cur.lazy === "boolean") {
                if (typeof cur.loaded === "boolean" && cur.loaded) {
                  treeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }
                treeRowData.loading = cur.loading;
              }
            }
            const tmp = [rowRender(row, $index, treeRowData)];
            if (cur) {
              let i = 0;
              const traverse = (children, parent2) => {
                if (!(children && children.length && parent2))
                  return;
                children.forEach((node) => {
                  const innerTreeRowData = {
                    display: parent2.display && parent2.expanded,
                    level: parent2.level + 1,
                    expanded: false,
                    noLazyChildren: false,
                    loading: false
                  };
                  const childKey = getRowIdentity(node, rowKey.value);
                  if (childKey === void 0 || childKey === null) {
                    throw new Error("For nested data item, row-key is required.");
                  }
                  cur = { ...treeData.value[childKey] };
                  if (cur) {
                    innerTreeRowData.expanded = cur.expanded;
                    cur.level = cur.level || innerTreeRowData.level;
                    cur.display = !!(cur.expanded && innerTreeRowData.display);
                    if (typeof cur.lazy === "boolean") {
                      if (typeof cur.loaded === "boolean" && cur.loaded) {
                        innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                      }
                      innerTreeRowData.loading = cur.loading;
                    }
                  }
                  i++;
                  tmp.push(rowRender(node, $index + i, innerTreeRowData));
                  if (cur) {
                    const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
                    traverse(nodes2, cur);
                  }
                });
              };
              cur.display = true;
              const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
              traverse(nodes, cur);
            }
            return tmp;
          } else {
            return rowRender(row, $index, void 0);
          }
        };
        return {
          wrappedRowRender,
          tooltipContent,
          tooltipTrigger
        };
      }
      const defaultProps$2 = {
        store: {
          required: true,
          type: Object
        },
        stripe: Boolean,
        tooltipEffect: String,
        tooltipOptions: {
          type: Object
        },
        context: {
          default: () => ({}),
          type: Object
        },
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        fixed: {
          type: String,
          default: ""
        },
        highlight: Boolean
      };
      var TableBody = defineComponent({
        name: "ElTableBody",
        props: defaultProps$2,
        setup(props) {
          const instance = getCurrentInstance();
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender$1(props);
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
          const hoveredCellList = [];
          watch(props.store.states.hoverRow, (newVal, oldVal) => {
            var _a;
            const el = instance == null ? void 0 : instance.vnode.el;
            const rows = Array.from((el == null ? void 0 : el.children) || []).filter((e) => e == null ? void 0 : e.classList.contains(`${ns.e("row")}`));
            let rowNum = newVal;
            const childNodes = (_a = rows[rowNum]) == null ? void 0 : _a.childNodes;
            if (childNodes == null ? void 0 : childNodes.length) {
              let control = 0;
              const indexes = Array.from(childNodes).reduce((acc, item, index) => {
                var _a2, _b;
                if (((_a2 = childNodes[index]) == null ? void 0 : _a2.colSpan) > 1) {
                  control = (_b = childNodes[index]) == null ? void 0 : _b.colSpan;
                }
                if (item.nodeName !== "TD" && control === 0) {
                  acc.push(index);
                }
                control > 0 && control--;
                return acc;
              }, []);
              indexes.forEach((rowIndex) => {
                var _a2;
                while (rowNum > 0) {
                  const preChildNodes = (_a2 = rows[rowNum - 1]) == null ? void 0 : _a2.childNodes;
                  if (preChildNodes[rowIndex] && preChildNodes[rowIndex].nodeName === "TD" && preChildNodes[rowIndex].rowSpan > 1) {
                    addClass(preChildNodes[rowIndex], "hover-cell");
                    hoveredCellList.push(preChildNodes[rowIndex]);
                    break;
                  }
                  rowNum--;
                }
              });
            } else {
              hoveredCellList.forEach((item) => removeClass(item, "hover-cell"));
              hoveredCellList.length = 0;
            }
            if (!props.store.states.isComplex.value || !isClient)
              return;
            rAF(() => {
              const oldRow = rows[oldVal];
              const newRow = rows[newVal];
              if (oldRow && !oldRow.classList.contains("hover-fixed-row")) {
                removeClass(oldRow, "hover-row");
              }
              if (newRow) {
                addClass(newRow, "hover-row");
              }
            });
          });
          onUnmounted(() => {
            var _a;
            (_a = removePopper) == null ? void 0 : _a();
          });
          return {
            ns,
            onColumnsChange,
            onScrollableChange,
            wrappedRowRender,
            tooltipContent,
            tooltipTrigger
          };
        },
        render() {
          const { wrappedRowRender, store } = this;
          const data = store.states.data.value || [];
          return h$1("tbody", { tabIndex: -1 }, [
            data.reduce((acc, row) => {
              return acc.concat(wrappedRowRender(row, acc.length));
            }, [])
          ]);
        }
      });
      function useMapState() {
        const table = inject(TABLE_INJECTION_KEY);
        const store = table == null ? void 0 : table.store;
        const leftFixedLeafCount = computed$1(() => {
          return store.states.fixedLeafColumnsLength.value;
        });
        const rightFixedLeafCount = computed$1(() => {
          return store.states.rightFixedColumns.value.length;
        });
        const columnsCount = computed$1(() => {
          return store.states.columns.value.length;
        });
        const leftFixedCount = computed$1(() => {
          return store.states.fixedColumns.value.length;
        });
        const rightFixedCount = computed$1(() => {
          return store.states.rightFixedColumns.value.length;
        });
        return {
          leftFixedLeafCount,
          rightFixedLeafCount,
          columnsCount,
          leftFixedCount,
          rightFixedCount,
          columns: store.states.columns
        };
      }
      function useStyle$1(props) {
        const { columns } = useMapState();
        const ns = useNamespace("table");
        const getCellClasses = (columns2, cellIndex) => {
          const column = columns2[cellIndex];
          const classes = [
            ns.e("cell"),
            column.id,
            column.align,
            column.labelClassName,
            ...getFixedColumnsClass(ns.b(), cellIndex, column.fixed, props.store)
          ];
          if (column.className) {
            classes.push(column.className);
          }
          if (!column.children) {
            classes.push(ns.is("leaf"));
          }
          return classes;
        };
        const getCellStyles = (column, cellIndex) => {
          const fixedStyle = getFixedColumnOffset(cellIndex, column.fixed, props.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return fixedStyle;
        };
        return {
          getCellClasses,
          getCellStyles,
          columns
        };
      }
      var TableFooter = defineComponent({
        name: "ElTableFooter",
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          summaryMethod: Function,
          sumText: String,
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          }
        },
        setup(props) {
          const { getCellClasses, getCellStyles, columns } = useStyle$1(props);
          const ns = useNamespace("table");
          return {
            ns,
            getCellClasses,
            getCellStyles,
            columns
          };
        },
        render() {
          const { columns, getCellStyles, getCellClasses, summaryMethod, sumText } = this;
          const data = this.store.states.data.value;
          let sums = [];
          if (summaryMethod) {
            sums = summaryMethod({
              columns,
              data
            });
          } else {
            columns.forEach((column, index) => {
              if (index === 0) {
                sums[index] = sumText;
                return;
              }
              const values = data.map((item) => Number(item[column.property]));
              const precisions = [];
              let notNumber = true;
              values.forEach((value) => {
                if (!Number.isNaN(+value)) {
                  notNumber = false;
                  const decimal = `${value}`.split(".")[1];
                  precisions.push(decimal ? decimal.length : 0);
                }
              });
              const precision = Math.max.apply(null, precisions);
              if (!notNumber) {
                sums[index] = values.reduce((prev, curr) => {
                  const value = Number(curr);
                  if (!Number.isNaN(+value)) {
                    return Number.parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
                  } else {
                    return prev;
                  }
                }, 0);
              } else {
                sums[index] = "";
              }
            });
          }
          return h$1(h$1("tfoot", [
            h$1("tr", {}, [
              ...columns.map((column, cellIndex) => h$1("td", {
                key: cellIndex,
                colspan: column.colSpan,
                rowspan: column.rowSpan,
                class: getCellClasses(columns, cellIndex),
                style: getCellStyles(column, cellIndex)
              }, [
                h$1("div", {
                  class: ["cell", column.labelClassName]
                }, [sums[cellIndex]])
              ]))
            ])
          ]));
        }
      });
      function useUtils(store) {
        const setCurrentRow = (row) => {
          store.commit("setCurrentRow", row);
        };
        const getSelectionRows = () => {
          return store.getSelectionRows();
        };
        const toggleRowSelection = (row, selected) => {
          store.toggleRowSelection(row, selected, false);
          store.updateAllSelected();
        };
        const clearSelection = () => {
          store.clearSelection();
        };
        const clearFilter = (columnKeys) => {
          store.clearFilter(columnKeys);
        };
        const toggleAllSelection = () => {
          store.commit("toggleAllSelection");
        };
        const toggleRowExpansion = (row, expanded) => {
          store.toggleRowExpansionAdapter(row, expanded);
        };
        const clearSort = () => {
          store.clearSort();
        };
        const sort = (prop, order) => {
          store.commit("sort", { prop, order });
        };
        return {
          setCurrentRow,
          getSelectionRows,
          toggleRowSelection,
          clearSelection,
          clearFilter,
          toggleAllSelection,
          toggleRowExpansion,
          clearSort,
          sort
        };
      }
      function useStyle(props, layout, store, table) {
        const isHidden2 = ref(false);
        const renderExpanded = ref(null);
        const resizeProxyVisible = ref(false);
        const setDragVisible = (visible) => {
          resizeProxyVisible.value = visible;
        };
        const resizeState = ref({
          width: null,
          height: null,
          headerHeight: null
        });
        const isGroup = ref(false);
        const scrollbarViewStyle = {
          display: "inline-block",
          verticalAlign: "middle"
        };
        const tableWidth = ref();
        const tableScrollHeight = ref(0);
        const bodyScrollHeight = ref(0);
        const headerScrollHeight = ref(0);
        const footerScrollHeight = ref(0);
        const appendScrollHeight = ref(0);
        watchEffect(() => {
          layout.setHeight(props.height);
        });
        watchEffect(() => {
          layout.setMaxHeight(props.maxHeight);
        });
        watch(() => [props.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey]) => {
          if (!unref(rowKey) || !unref(currentRowKey))
            return;
          store.setCurrentRowKey(`${currentRowKey}`);
        }, {
          immediate: true
        });
        watch(() => props.data, (data) => {
          table.store.commit("setData", data);
        }, {
          immediate: true,
          deep: true
        });
        watchEffect(() => {
          if (props.expandRowKeys) {
            store.setExpandRowKeysAdapter(props.expandRowKeys);
          }
        });
        const handleMouseLeave = () => {
          table.store.commit("setHoverRow", null);
          if (table.hoverState)
            table.hoverState = null;
        };
        const handleHeaderFooterMousewheel = (event, data) => {
          const { pixelX, pixelY } = data;
          if (Math.abs(pixelX) >= Math.abs(pixelY)) {
            table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
          }
        };
        const shouldUpdateHeight = computed$1(() => {
          return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
        });
        const tableBodyStyles = computed$1(() => {
          return {
            width: layout.bodyWidth.value ? `${layout.bodyWidth.value}px` : ""
          };
        });
        const doLayout = () => {
          if (shouldUpdateHeight.value) {
            layout.updateElsHeight();
          }
          layout.updateColumnsWidth();
          requestAnimationFrame(syncPosition);
        };
        onMounted(async () => {
          await nextTick();
          store.updateColumns();
          bindEvents();
          requestAnimationFrame(doLayout);
          const el = table.vnode.el;
          const tableHeader = table.refs.headerWrapper;
          if (props.flexible && el && el.parentElement) {
            el.parentElement.style.minWidth = "0";
          }
          resizeState.value = {
            width: tableWidth.value = el.offsetWidth,
            height: el.offsetHeight,
            headerHeight: props.showHeader && tableHeader ? tableHeader.offsetHeight : null
          };
          store.states.columns.value.forEach((column) => {
            if (column.filteredValue && column.filteredValue.length) {
              table.store.commit("filterChange", {
                column,
                values: column.filteredValue,
                silent: true
              });
            }
          });
          table.$ready = true;
        });
        const setScrollClassByEl = (el, className) => {
          if (!el)
            return;
          const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
          classList.push(layout.scrollX.value ? className : "is-scrolling-none");
          el.className = classList.join(" ");
        };
        const setScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          setScrollClassByEl(tableWrapper, className);
        };
        const hasScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          return !!(tableWrapper && tableWrapper.classList.contains(className));
        };
        const syncPosition = function() {
          if (!table.refs.scrollBarRef)
            return;
          if (!layout.scrollX.value) {
            const scrollingNoneClass = "is-scrolling-none";
            if (!hasScrollClass(scrollingNoneClass)) {
              setScrollClass(scrollingNoneClass);
            }
            return;
          }
          const scrollContainer = table.refs.scrollBarRef.wrapRef;
          if (!scrollContainer)
            return;
          const { scrollLeft, offsetWidth, scrollWidth } = scrollContainer;
          const { headerWrapper, footerWrapper } = table.refs;
          if (headerWrapper)
            headerWrapper.scrollLeft = scrollLeft;
          if (footerWrapper)
            footerWrapper.scrollLeft = scrollLeft;
          const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
          if (scrollLeft >= maxScrollLeftPosition) {
            setScrollClass("is-scrolling-right");
          } else if (scrollLeft === 0) {
            setScrollClass("is-scrolling-left");
          } else {
            setScrollClass("is-scrolling-middle");
          }
        };
        const bindEvents = () => {
          if (!table.refs.scrollBarRef)
            return;
          if (table.refs.scrollBarRef.wrapRef) {
            useEventListener(table.refs.scrollBarRef.wrapRef, "scroll", syncPosition, {
              passive: true
            });
          }
          if (props.fit) {
            useResizeObserver(table.vnode.el, resizeListener);
          } else {
            useEventListener(window, "resize", resizeListener);
          }
          useResizeObserver(table.refs.bodyWrapper, () => {
            var _a, _b;
            resizeListener();
            (_b = (_a = table.refs) == null ? void 0 : _a.scrollBarRef) == null ? void 0 : _b.update();
          });
        };
        const resizeListener = () => {
          var _a, _b, _c, _d;
          const el = table.vnode.el;
          if (!table.$ready || !el)
            return;
          let shouldUpdateLayout = false;
          const {
            width: oldWidth,
            height: oldHeight,
            headerHeight: oldHeaderHeight
          } = resizeState.value;
          const width = tableWidth.value = el.offsetWidth;
          if (oldWidth !== width) {
            shouldUpdateLayout = true;
          }
          const height = el.offsetHeight;
          if ((props.height || shouldUpdateHeight.value) && oldHeight !== height) {
            shouldUpdateLayout = true;
          }
          const tableHeader = props.tableLayout === "fixed" ? table.refs.headerWrapper : (_a = table.refs.tableHeaderRef) == null ? void 0 : _a.$el;
          if (props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) !== oldHeaderHeight) {
            shouldUpdateLayout = true;
          }
          tableScrollHeight.value = ((_b = table.refs.tableWrapper) == null ? void 0 : _b.scrollHeight) || 0;
          headerScrollHeight.value = (tableHeader == null ? void 0 : tableHeader.scrollHeight) || 0;
          footerScrollHeight.value = ((_c = table.refs.footerWrapper) == null ? void 0 : _c.offsetHeight) || 0;
          appendScrollHeight.value = ((_d = table.refs.appendWrapper) == null ? void 0 : _d.offsetHeight) || 0;
          bodyScrollHeight.value = tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value - appendScrollHeight.value;
          if (shouldUpdateLayout) {
            resizeState.value = {
              width,
              height,
              headerHeight: props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) || 0
            };
            doLayout();
          }
        };
        const tableSize = useFormSize();
        const bodyWidth = computed$1(() => {
          const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout;
          return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
        });
        const tableLayout = computed$1(() => {
          if (props.maxHeight)
            return "fixed";
          return props.tableLayout;
        });
        const emptyBlockStyle = computed$1(() => {
          if (props.data && props.data.length)
            return null;
          let height = "100%";
          if (props.height && bodyScrollHeight.value) {
            height = `${bodyScrollHeight.value}px`;
          }
          const width = tableWidth.value;
          return {
            width: width ? `${width}px` : "",
            height
          };
        });
        const tableInnerStyle = computed$1(() => {
          if (props.height) {
            return {
              height: !Number.isNaN(Number(props.height)) ? `${props.height}px` : props.height
            };
          }
          if (props.maxHeight) {
            return {
              maxHeight: !Number.isNaN(Number(props.maxHeight)) ? `${props.maxHeight}px` : props.maxHeight
            };
          }
          return {};
        });
        const scrollbarStyle = computed$1(() => {
          if (props.height) {
            return {
              height: "100%"
            };
          }
          if (props.maxHeight) {
            if (!Number.isNaN(Number(props.maxHeight))) {
              return {
                maxHeight: `${props.maxHeight - headerScrollHeight.value - footerScrollHeight.value}px`
              };
            } else {
              return {
                maxHeight: `calc(${props.maxHeight} - ${headerScrollHeight.value + footerScrollHeight.value}px)`
              };
            }
          }
          return {};
        });
        const handleFixedMousewheel = (event, data) => {
          const bodyWrapper = table.refs.bodyWrapper;
          if (Math.abs(data.spinY) > 0) {
            const currentScrollTop = bodyWrapper.scrollTop;
            if (data.pixelY < 0 && currentScrollTop !== 0) {
              event.preventDefault();
            }
            if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
              event.preventDefault();
            }
            bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
          } else {
            bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
          }
        };
        return {
          isHidden: isHidden2,
          renderExpanded,
          setDragVisible,
          isGroup,
          handleMouseLeave,
          handleHeaderFooterMousewheel,
          tableSize,
          emptyBlockStyle,
          handleFixedMousewheel,
          resizeProxyVisible,
          bodyWidth,
          resizeState,
          doLayout,
          tableBodyStyles,
          tableLayout,
          scrollbarViewStyle,
          tableInnerStyle,
          scrollbarStyle
        };
      }
      function useKeyRender(table) {
        const observer = ref();
        const initWatchDom = () => {
          const el = table.vnode.el;
          const columnsWrapper = el.querySelector(".hidden-columns");
          const config = { childList: true, subtree: true };
          const updateOrderFns = table.store.states.updateOrderFns;
          observer.value = new MutationObserver(() => {
            updateOrderFns.forEach((fn2) => fn2());
          });
          observer.value.observe(columnsWrapper, config);
        };
        onMounted(() => {
          initWatchDom();
        });
        onUnmounted(() => {
          var _a;
          (_a = observer.value) == null ? void 0 : _a.disconnect();
        });
      }
      var defaultProps$1 = {
        data: {
          type: Array,
          default: () => []
        },
        size: useSizeProp,
        width: [String, Number],
        height: [String, Number],
        maxHeight: [String, Number],
        fit: {
          type: Boolean,
          default: true
        },
        stripe: Boolean,
        border: Boolean,
        rowKey: [String, Function],
        showHeader: {
          type: Boolean,
          default: true
        },
        showSummary: Boolean,
        sumText: String,
        summaryMethod: Function,
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        cellClassName: [String, Function],
        cellStyle: [Object, Function],
        headerRowClassName: [String, Function],
        headerRowStyle: [Object, Function],
        headerCellClassName: [String, Function],
        headerCellStyle: [Object, Function],
        highlightCurrentRow: Boolean,
        currentRowKey: [String, Number],
        emptyText: String,
        expandRowKeys: Array,
        defaultExpandAll: Boolean,
        defaultSort: Object,
        tooltipEffect: String,
        tooltipOptions: Object,
        spanMethod: Function,
        selectOnIndeterminate: {
          type: Boolean,
          default: true
        },
        indent: {
          type: Number,
          default: 16
        },
        treeProps: {
          type: Object,
          default: () => {
            return {
              hasChildren: "hasChildren",
              children: "children"
            };
          }
        },
        lazy: Boolean,
        load: Function,
        style: {
          type: Object,
          default: () => ({})
        },
        className: {
          type: String,
          default: ""
        },
        tableLayout: {
          type: String,
          default: "fixed"
        },
        scrollbarAlwaysOn: Boolean,
        flexible: Boolean,
        showOverflowTooltip: [Boolean, Object]
      };
      function hColgroup(props) {
        const isAuto = props.tableLayout === "auto";
        let columns = props.columns || [];
        if (isAuto) {
          if (columns.every((column) => column.width === void 0)) {
            columns = [];
          }
        }
        const getPropsData = (column) => {
          const propsData = {
            key: `${props.tableLayout}_${column.id}`,
            style: {},
            name: void 0
          };
          if (isAuto) {
            propsData.style = {
              width: `${column.width}px`
            };
          } else {
            propsData.name = column.id;
          }
          return propsData;
        };
        return h$1("colgroup", {}, columns.map((column) => h$1("col", getPropsData(column))));
      }
      hColgroup.props = ["columns", "tableLayout"];
      const useScrollbar = () => {
        const scrollBarRef = ref();
        const scrollTo = (options, yCoord) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar) {
            scrollbar.scrollTo(options, yCoord);
          }
        };
        const setScrollPosition = (position, offset) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar && isNumber(offset) && ["Top", "Left"].includes(position)) {
            scrollbar[`setScroll${position}`](offset);
          }
        };
        const setScrollTop = (top) => setScrollPosition("Top", top);
        const setScrollLeft = (left) => setScrollPosition("Left", left);
        return {
          scrollBarRef,
          scrollTo,
          setScrollTop,
          setScrollLeft
        };
      };
      let tableIdSeed = 1;
      const _sfc_main$j = defineComponent({
        name: "ElTable",
        directives: {
          Mousewheel
        },
        components: {
          TableHeader,
          TableBody,
          TableFooter,
          ElScrollbar,
          hColgroup
        },
        props: defaultProps$1,
        emits: [
          "select",
          "select-all",
          "selection-change",
          "cell-mouse-enter",
          "cell-mouse-leave",
          "cell-contextmenu",
          "cell-click",
          "cell-dblclick",
          "row-click",
          "row-contextmenu",
          "row-dblclick",
          "header-click",
          "header-contextmenu",
          "sort-change",
          "filter-change",
          "current-change",
          "header-dragend",
          "expand-change"
        ],
        setup(props) {
          const { t } = useLocale();
          const ns = useNamespace("table");
          const table = getCurrentInstance();
          provide(TABLE_INJECTION_KEY, table);
          const store = createStore(table, props);
          table.store = store;
          const layout = new TableLayout({
            store: table.store,
            table,
            fit: props.fit,
            showHeader: props.showHeader
          });
          table.layout = layout;
          const isEmpty2 = computed$1(() => (store.states.data.value || []).length === 0);
          const {
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            sort
          } = useUtils(store);
          const {
            isHidden: isHidden2,
            renderExpanded,
            setDragVisible,
            isGroup,
            handleMouseLeave,
            handleHeaderFooterMousewheel,
            tableSize,
            emptyBlockStyle,
            handleFixedMousewheel,
            resizeProxyVisible,
            bodyWidth,
            resizeState,
            doLayout,
            tableBodyStyles,
            tableLayout,
            scrollbarViewStyle,
            tableInnerStyle,
            scrollbarStyle
          } = useStyle(props, layout, store, table);
          const { scrollBarRef, scrollTo, setScrollLeft, setScrollTop } = useScrollbar();
          const debouncedUpdateLayout = debounce(doLayout, 50);
          const tableId = `${ns.namespace.value}-table_${tableIdSeed++}`;
          table.tableId = tableId;
          table.state = {
            isGroup,
            resizeState,
            doLayout,
            debouncedUpdateLayout
          };
          const computedSumText = computed$1(() => props.sumText || t("el.table.sumText"));
          const computedEmptyText = computed$1(() => {
            return props.emptyText || t("el.table.emptyText");
          });
          useKeyRender(table);
          return {
            ns,
            layout,
            store,
            handleHeaderFooterMousewheel,
            handleMouseLeave,
            tableId,
            tableSize,
            isHidden: isHidden2,
            isEmpty: isEmpty2,
            renderExpanded,
            resizeProxyVisible,
            resizeState,
            isGroup,
            bodyWidth,
            tableBodyStyles,
            emptyBlockStyle,
            debouncedUpdateLayout,
            handleFixedMousewheel,
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            doLayout,
            sort,
            t,
            setDragVisible,
            context: table,
            computedSumText,
            computedEmptyText,
            tableLayout,
            scrollbarViewStyle,
            tableInnerStyle,
            scrollbarStyle,
            scrollBarRef,
            scrollTo,
            setScrollLeft,
            setScrollTop
          };
        }
      });
      const _hoisted_1$f = ["data-prefix"];
      const _hoisted_2$c = {
        ref: "hiddenColumns",
        class: "hidden-columns"
      };
      function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_hColgroup = resolveComponent("hColgroup");
        const _component_table_header = resolveComponent("table-header");
        const _component_table_body = resolveComponent("table-body");
        const _component_table_footer = resolveComponent("table-footer");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _directive_mousewheel = resolveDirective("mousewheel");
        return openBlock(), createElementBlock("div", {
          ref: "tableWrapper",
          class: normalizeClass([
            {
              [_ctx.ns.m("fit")]: _ctx.fit,
              [_ctx.ns.m("striped")]: _ctx.stripe,
              [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
              [_ctx.ns.m("hidden")]: _ctx.isHidden,
              [_ctx.ns.m("group")]: _ctx.isGroup,
              [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
              [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
              [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
              [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
              [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
              "has-footer": _ctx.showSummary
            },
            _ctx.ns.m(_ctx.tableSize),
            _ctx.className,
            _ctx.ns.b(),
            _ctx.ns.m(`layout-${_ctx.tableLayout}`)
          ]),
          style: normalizeStyle(_ctx.style),
          "data-prefix": _ctx.ns.namespace.value,
          onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args))
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("inner-wrapper")),
            style: normalizeStyle(_ctx.tableInnerStyle)
          }, [
            createElementVNode("div", _hoisted_2$c, [
              renderSlot(_ctx.$slots, "default")
            ], 512),
            _ctx.showHeader && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              ref: "headerWrapper",
              class: normalizeClass(_ctx.ns.e("header-wrapper"))
            }, [
              createElementVNode("table", {
                ref: "tableHeader",
                class: normalizeClass(_ctx.ns.e("header")),
                style: normalizeStyle(_ctx.tableBodyStyles),
                border: "0",
                cellpadding: "0",
                cellspacing: "0"
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_header, {
                  ref: "tableHeaderRef",
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  onSetDragVisible: _ctx.setDragVisible
                }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
              ], 6)
            ], 2)), [
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            createElementVNode("div", {
              ref: "bodyWrapper",
              class: normalizeClass(_ctx.ns.e("body-wrapper"))
            }, [
              createVNode(_component_el_scrollbar, {
                ref: "scrollBarRef",
                "view-style": _ctx.scrollbarViewStyle,
                "wrap-style": _ctx.scrollbarStyle,
                always: _ctx.scrollbarAlwaysOn
              }, {
                default: withCtx(() => [
                  createElementVNode("table", {
                    ref: "tableBody",
                    class: normalizeClass(_ctx.ns.e("body")),
                    cellspacing: "0",
                    cellpadding: "0",
                    border: "0",
                    style: normalizeStyle({
                      width: _ctx.bodyWidth,
                      tableLayout: _ctx.tableLayout
                    })
                  }, [
                    createVNode(_component_hColgroup, {
                      columns: _ctx.store.states.columns.value,
                      "table-layout": _ctx.tableLayout
                    }, null, 8, ["columns", "table-layout"]),
                    _ctx.showHeader && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_header, {
                      key: 0,
                      ref: "tableHeaderRef",
                      class: normalizeClass(_ctx.ns.e("body-header")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      onSetDragVisible: _ctx.setDragVisible
                    }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : createCommentVNode("v-if", true),
                    createVNode(_component_table_body, {
                      context: _ctx.context,
                      highlight: _ctx.highlightCurrentRow,
                      "row-class-name": _ctx.rowClassName,
                      "tooltip-effect": _ctx.tooltipEffect,
                      "tooltip-options": _ctx.tooltipOptions,
                      "row-style": _ctx.rowStyle,
                      store: _ctx.store,
                      stripe: _ctx.stripe
                    }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
                    _ctx.showSummary && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_footer, {
                      key: 1,
                      class: normalizeClass(_ctx.ns.e("body-footer")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      "sum-text": _ctx.computedSumText,
                      "summary-method": _ctx.summaryMethod
                    }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : createCommentVNode("v-if", true)
                  ], 6),
                  _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "emptyBlock",
                    style: normalizeStyle(_ctx.emptyBlockStyle),
                    class: normalizeClass(_ctx.ns.e("empty-block"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(_ctx.ns.e("empty-text"))
                    }, [
                      renderSlot(_ctx.$slots, "empty", {}, () => [
                        createTextVNode(toDisplayString(_ctx.computedEmptyText), 1)
                      ])
                    ], 2)
                  ], 6)) : createCommentVNode("v-if", true),
                  _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    ref: "appendWrapper",
                    class: normalizeClass(_ctx.ns.e("append-wrapper"))
                  }, [
                    renderSlot(_ctx.$slots, "append")
                  ], 2)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["view-style", "wrap-style", "always"])
            ], 2),
            _ctx.showSummary && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 1,
              ref: "footerWrapper",
              class: normalizeClass(_ctx.ns.e("footer-wrapper"))
            }, [
              createElementVNode("table", {
                class: normalizeClass(_ctx.ns.e("footer")),
                cellspacing: "0",
                cellpadding: "0",
                border: "0",
                style: normalizeStyle(_ctx.tableBodyStyles)
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_footer, {
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  "sum-text": _ctx.computedSumText,
                  "summary-method": _ctx.summaryMethod
                }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
              ], 6)
            ], 2)), [
              [vShow, !_ctx.isEmpty],
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            _ctx.border || _ctx.isGroup ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(_ctx.ns.e("border-left-patch"))
            }, null, 2)) : createCommentVNode("v-if", true)
          ], 6),
          withDirectives(createElementVNode("div", {
            ref: "resizeProxy",
            class: normalizeClass(_ctx.ns.e("column-resize-proxy"))
          }, null, 2), [
            [vShow, _ctx.resizeProxyVisible]
          ])
        ], 46, _hoisted_1$f);
      }
      var Table = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["render", _sfc_render$7], ["__file", "table.vue"]]);
      const defaultClassNames = {
        selection: "table-column--selection",
        expand: "table__expand-column"
      };
      const cellStarts = {
        default: {
          order: ""
        },
        selection: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        expand: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        index: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        }
      };
      const getDefaultClassName = (type4) => {
        return defaultClassNames[type4] || "";
      };
      const cellForced = {
        selection: {
          renderHeader({ store, column }) {
            function isDisabled() {
              return store.states.data.value && store.states.data.value.length === 0;
            }
            return h$1(ElCheckbox, {
              disabled: isDisabled(),
              size: store.states.tableSize.value,
              indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
              "onUpdate:modelValue": store.toggleAllSelection,
              modelValue: store.states.isAllSelected.value,
              ariaLabel: column.label
            });
          },
          renderCell({
            row,
            column,
            store,
            $index
          }) {
            return h$1(ElCheckbox, {
              disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
              size: store.states.tableSize.value,
              onChange: () => {
                store.commit("rowSelectedChanged", row);
              },
              onClick: (event) => event.stopPropagation(),
              modelValue: store.isSelected(row),
              ariaLabel: column.label
            });
          },
          sortable: false,
          resizable: false
        },
        index: {
          renderHeader({ column }) {
            return column.label || "#";
          },
          renderCell({
            column,
            $index
          }) {
            let i = $index + 1;
            const index = column.index;
            if (typeof index === "number") {
              i = $index + index;
            } else if (typeof index === "function") {
              i = index($index);
            }
            return h$1("div", {}, [i]);
          },
          sortable: false
        },
        expand: {
          renderHeader({ column }) {
            return column.label || "";
          },
          renderCell({
            row,
            store,
            expanded
          }) {
            const { ns } = store;
            const classes = [ns.e("expand-icon")];
            if (expanded) {
              classes.push(ns.em("expand-icon", "expanded"));
            }
            const callback = function(e) {
              e.stopPropagation();
              store.toggleRowExpansion(row);
            };
            return h$1("div", {
              class: classes,
              onClick: callback
            }, {
              default: () => {
                return [
                  h$1(ElIcon, null, {
                    default: () => {
                      return [h$1(arrow_right_default)];
                    }
                  })
                ];
              }
            });
          },
          sortable: false,
          resizable: false
        }
      };
      function defaultRenderCell({
        row,
        column,
        $index
      }) {
        var _a;
        const property2 = column.property;
        const value = property2 && getProp(row, property2).value;
        if (column && column.formatter) {
          return column.formatter(row, column, value, $index);
        }
        return ((_a = value == null ? void 0 : value.toString) == null ? void 0 : _a.call(value)) || "";
      }
      function treeCellPrefix({
        row,
        treeNode,
        store
      }, createPlaceholder = false) {
        const { ns } = store;
        if (!treeNode) {
          if (createPlaceholder) {
            return [
              h$1("span", {
                class: ns.e("placeholder")
              })
            ];
          }
          return null;
        }
        const ele = [];
        const callback = function(e) {
          e.stopPropagation();
          if (treeNode.loading) {
            return;
          }
          store.loadOrToggle(row);
        };
        if (treeNode.indent) {
          ele.push(h$1("span", {
            class: ns.e("indent"),
            style: { "padding-left": `${treeNode.indent}px` }
          }));
        }
        if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
          const expandClasses = [
            ns.e("expand-icon"),
            treeNode.expanded ? ns.em("expand-icon", "expanded") : ""
          ];
          let icon = arrow_right_default;
          if (treeNode.loading) {
            icon = loading_default;
          }
          ele.push(h$1("div", {
            class: expandClasses,
            onClick: callback
          }, {
            default: () => {
              return [
                h$1(ElIcon, { class: { [ns.is("loading")]: treeNode.loading } }, {
                  default: () => [h$1(icon)]
                })
              ];
            }
          }));
        } else {
          ele.push(h$1("span", {
            class: ns.e("placeholder")
          }));
        }
        return ele;
      }
      function getAllAliases(props, aliases) {
        return props.reduce((prev, cur) => {
          prev[cur] = cur;
          return prev;
        }, aliases);
      }
      function useWatcher(owner, props_) {
        const instance = getCurrentInstance();
        const registerComplexWatchers = () => {
          const props = ["fixed"];
          const aliases = {
            realWidth: "width",
            realMinWidth: "minWidth"
          };
          const allAliases = getAllAliases(props, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                let value = newVal;
                if (columnKey === "width" && key === "realWidth") {
                  value = parseWidth(newVal);
                }
                if (columnKey === "minWidth" && key === "realMinWidth") {
                  value = parseMinWidth(newVal);
                }
                instance.columnConfig.value[columnKey] = value;
                instance.columnConfig.value[key] = value;
                const updateColumns = columnKey === "fixed";
                owner.value.store.scheduleLayout(updateColumns);
              });
            }
          });
        };
        const registerNormalWatchers = () => {
          const props = [
            "label",
            "filters",
            "filterMultiple",
            "filteredValue",
            "sortable",
            "index",
            "formatter",
            "className",
            "labelClassName",
            "filterClassName",
            "showOverflowTooltip"
          ];
          const aliases = {
            property: "prop",
            align: "realAlign",
            headerAlign: "realHeaderAlign"
          };
          const allAliases = getAllAliases(props, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                instance.columnConfig.value[key] = newVal;
              });
            }
          });
        };
        return {
          registerComplexWatchers,
          registerNormalWatchers
        };
      }
      function useRender(props, slots, owner) {
        const instance = getCurrentInstance();
        const columnId = ref("");
        const isSubColumn = ref(false);
        const realAlign = ref();
        const realHeaderAlign = ref();
        const ns = useNamespace("table");
        watchEffect(() => {
          realAlign.value = props.align ? `is-${props.align}` : null;
          realAlign.value;
        });
        watchEffect(() => {
          realHeaderAlign.value = props.headerAlign ? `is-${props.headerAlign}` : realAlign.value;
          realHeaderAlign.value;
        });
        const columnOrTableParent = computed$1(() => {
          let parent = instance.vnode.vParent || instance.parent;
          while (parent && !parent.tableId && !parent.columnId) {
            parent = parent.vnode.vParent || parent.parent;
          }
          return parent;
        });
        const hasTreeColumn = computed$1(() => {
          const { store } = instance.parent;
          if (!store)
            return false;
          const { treeData } = store.states;
          const treeDataValue = treeData.value;
          return treeDataValue && Object.keys(treeDataValue).length > 0;
        });
        const realWidth = ref(parseWidth(props.width));
        const realMinWidth = ref(parseMinWidth(props.minWidth));
        const setColumnWidth = (column) => {
          if (realWidth.value)
            column.width = realWidth.value;
          if (realMinWidth.value) {
            column.minWidth = realMinWidth.value;
          }
          if (!realWidth.value && realMinWidth.value) {
            column.width = void 0;
          }
          if (!column.minWidth) {
            column.minWidth = 80;
          }
          column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
          return column;
        };
        const setColumnForcedProps = (column) => {
          const type4 = column.type;
          const source = cellForced[type4] || {};
          Object.keys(source).forEach((prop) => {
            const value = source[prop];
            if (prop !== "className" && value !== void 0) {
              column[prop] = value;
            }
          });
          const className = getDefaultClassName(type4);
          if (className) {
            const forceClass = `${unref(ns.namespace)}-${className}`;
            column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
          }
          return column;
        };
        const checkSubColumn = (children) => {
          if (Array.isArray(children)) {
            children.forEach((child) => check(child));
          } else {
            check(children);
          }
          function check(item) {
            var _a;
            if (((_a = item == null ? void 0 : item.type) == null ? void 0 : _a.name) === "ElTableColumn") {
              item.vParent = instance;
            }
          }
        };
        const setColumnRenders = (column) => {
          if (props.renderHeader)
            ;
          else if (column.type !== "selection") {
            column.renderHeader = (scope) => {
              instance.columnConfig.value["label"];
              return renderSlot(slots, "header", scope, () => [column.label]);
            };
          }
          let originRenderCell = column.renderCell;
          if (column.type === "expand") {
            column.renderCell = (data) => h$1("div", {
              class: "cell"
            }, [originRenderCell(data)]);
            owner.value.renderExpanded = (data) => {
              return slots.default ? slots.default(data) : slots.default;
            };
          } else {
            originRenderCell = originRenderCell || defaultRenderCell;
            column.renderCell = (data) => {
              let children = null;
              if (slots.default) {
                const vnodes = slots.default(data);
                children = vnodes.some((v2) => v2.type !== Comment) ? vnodes : originRenderCell(data);
              } else {
                children = originRenderCell(data);
              }
              const { columns } = owner.value.store.states;
              const firstUserColumnIndex = columns.value.findIndex((item) => item.type === "default");
              const shouldCreatePlaceholder = hasTreeColumn.value && data.cellIndex === firstUserColumnIndex;
              const prefix = treeCellPrefix(data, shouldCreatePlaceholder);
              const props2 = {
                class: "cell",
                style: {}
              };
              if (column.showOverflowTooltip) {
                props2.class = `${props2.class} ${unref(ns.namespace)}-tooltip`;
                props2.style = {
                  width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
                };
              }
              checkSubColumn(children);
              return h$1("div", props2, [prefix, children]);
            };
          }
          return column;
        };
        const getPropsData = (...propsKey) => {
          return propsKey.reduce((prev, cur) => {
            if (Array.isArray(cur)) {
              cur.forEach((key) => {
                prev[key] = props[key];
              });
            }
            return prev;
          }, {});
        };
        const getColumnElIndex = (children, child) => {
          return Array.prototype.indexOf.call(children, child);
        };
        const updateColumnOrder = () => {
          owner.value.store.commit("updateColumnOrder", instance.columnConfig.value);
        };
        return {
          columnId,
          realAlign,
          isSubColumn,
          realHeaderAlign,
          columnOrTableParent,
          setColumnWidth,
          setColumnForcedProps,
          setColumnRenders,
          getPropsData,
          getColumnElIndex,
          updateColumnOrder
        };
      }
      var defaultProps = {
        type: {
          type: String,
          default: "default"
        },
        label: String,
        className: String,
        labelClassName: String,
        property: String,
        prop: String,
        width: {
          type: [String, Number],
          default: ""
        },
        minWidth: {
          type: [String, Number],
          default: ""
        },
        renderHeader: Function,
        sortable: {
          type: [Boolean, String],
          default: false
        },
        sortMethod: Function,
        sortBy: [String, Function, Array],
        resizable: {
          type: Boolean,
          default: true
        },
        columnKey: String,
        align: String,
        headerAlign: String,
        showOverflowTooltip: {
          type: [Boolean, Object],
          default: void 0
        },
        fixed: [Boolean, String],
        formatter: Function,
        selectable: Function,
        reserveSelection: Boolean,
        filterMethod: Function,
        filteredValue: Array,
        filters: Array,
        filterPlacement: String,
        filterMultiple: {
          type: Boolean,
          default: true
        },
        filterClassName: String,
        index: [Number, Function],
        sortOrders: {
          type: Array,
          default: () => {
            return ["ascending", "descending", null];
          },
          validator: (val) => {
            return val.every((order) => ["ascending", "descending", null].includes(order));
          }
        }
      };
      let columnIdSeed = 1;
      var ElTableColumn$1 = defineComponent({
        name: "ElTableColumn",
        components: {
          ElCheckbox
        },
        props: defaultProps,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const columnConfig = ref({});
          const owner = computed$1(() => {
            let parent2 = instance.parent;
            while (parent2 && !parent2.tableId) {
              parent2 = parent2.parent;
            }
            return parent2;
          });
          const { registerNormalWatchers, registerComplexWatchers } = useWatcher(owner, props);
          const {
            columnId,
            isSubColumn,
            realHeaderAlign,
            columnOrTableParent,
            setColumnWidth,
            setColumnForcedProps,
            setColumnRenders,
            getPropsData,
            getColumnElIndex,
            realAlign,
            updateColumnOrder
          } = useRender(props, slots, owner);
          const parent = columnOrTableParent.value;
          columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
          onBeforeMount(() => {
            isSubColumn.value = owner.value !== parent;
            const type4 = props.type || "default";
            const sortable = props.sortable === "" ? true : props.sortable;
            const showOverflowTooltip = isUndefined$1(props.showOverflowTooltip) ? parent.props.showOverflowTooltip : props.showOverflowTooltip;
            const defaults = {
              ...cellStarts[type4],
              id: columnId.value,
              type: type4,
              property: props.prop || props.property,
              align: realAlign,
              headerAlign: realHeaderAlign,
              showOverflowTooltip,
              filterable: props.filters || props.filterMethod,
              filteredValue: [],
              filterPlacement: "",
              filterClassName: "",
              isColumnGroup: false,
              isSubColumn: false,
              filterOpened: false,
              sortable,
              index: props.index,
              rawColumnKey: instance.vnode.key
            };
            const basicProps = [
              "columnKey",
              "label",
              "className",
              "labelClassName",
              "type",
              "renderHeader",
              "formatter",
              "fixed",
              "resizable"
            ];
            const sortProps = ["sortMethod", "sortBy", "sortOrders"];
            const selectProps = ["selectable", "reserveSelection"];
            const filterProps = [
              "filterMethod",
              "filters",
              "filterMultiple",
              "filterOpened",
              "filteredValue",
              "filterPlacement",
              "filterClassName"
            ];
            let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
            column = mergeOptions(defaults, column);
            const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
            column = chains(column);
            columnConfig.value = column;
            registerNormalWatchers();
            registerComplexWatchers();
          });
          onMounted(() => {
            var _a;
            const parent2 = columnOrTableParent.value;
            const children = isSubColumn.value ? parent2.vnode.el.children : (_a = parent2.refs.hiddenColumns) == null ? void 0 : _a.children;
            const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
            columnConfig.value.getColumnIndex = getColumnIndex;
            const columnIndex = getColumnIndex();
            columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null, updateColumnOrder);
          });
          onBeforeUnmount(() => {
            owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null, updateColumnOrder);
          });
          instance.columnId = columnId.value;
          instance.columnConfig = columnConfig;
          return;
        },
        render() {
          var _a, _b, _c;
          try {
            const renderDefault = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, {
              row: {},
              column: {},
              $index: -1
            });
            const children = [];
            if (Array.isArray(renderDefault)) {
              for (const childNode of renderDefault) {
                if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
                  children.push(childNode);
                } else if (childNode.type === Fragment && Array.isArray(childNode.children)) {
                  childNode.children.forEach((vnode2) => {
                    if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !isString(vnode2 == null ? void 0 : vnode2.children)) {
                      children.push(vnode2);
                    }
                  });
                }
              }
            }
            const vnode = h$1("div", children);
            return vnode;
          } catch (e) {
            return h$1("div", []);
          }
        }
      });
      const ElTable = withInstall(Table, {
        TableColumn: ElTableColumn$1
      });
      const ElTableColumn = withNoopInstall(ElTableColumn$1);
      const textProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger", ""],
          default: ""
        },
        size: {
          type: String,
          values: componentSizes,
          default: ""
        },
        truncated: {
          type: Boolean
        },
        lineClamp: {
          type: [String, Number]
        },
        tag: {
          type: String,
          default: "span"
        }
      });
      const __default__$4 = defineComponent({
        name: "ElText"
      });
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: textProps,
        setup(__props) {
          const props = __props;
          const textSize = useFormSize();
          const ns = useNamespace("text");
          const textKls = computed$1(() => [
            ns.b(),
            ns.m(props.type),
            ns.m(textSize.value),
            ns.is("truncated", props.truncated),
            ns.is("line-clamp", !isUndefined$1(props.lineClamp))
          ]);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              class: normalizeClass(unref(textKls)),
              style: normalizeStyle({ "-webkit-line-clamp": _ctx.lineClamp })
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Text = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "text.vue"]]);
      const ElText = withInstall(Text);
      const uploadContextKey = Symbol("uploadContextKey");
      const SCOPE$1 = "ElUpload";
      class UploadAjaxError extends Error {
        constructor(message, status, method4, url2) {
          super(message);
          this.name = "UploadAjaxError";
          this.status = status;
          this.method = method4;
          this.url = url2;
        }
      }
      function getError(action, option, xhr) {
        let msg;
        if (xhr.response) {
          msg = `${xhr.response.error || xhr.response}`;
        } else if (xhr.responseText) {
          msg = `${xhr.responseText}`;
        } else {
          msg = `fail to ${option.method} ${action} ${xhr.status}`;
        }
        return new UploadAjaxError(msg, xhr.status, option.method, action);
      }
      function getBody(xhr) {
        const text = xhr.responseText || xhr.response;
        if (!text) {
          return text;
        }
        try {
          return JSON.parse(text);
        } catch (e) {
          return text;
        }
      }
      const ajaxUpload = (option) => {
        if (typeof XMLHttpRequest === "undefined")
          throwError(SCOPE$1, "XMLHttpRequest is undefined");
        const xhr = new XMLHttpRequest();
        const action = option.action;
        if (xhr.upload) {
          xhr.upload.addEventListener("progress", (evt) => {
            const progressEvt = evt;
            progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;
            option.onProgress(progressEvt);
          });
        }
        const formData = new FormData();
        if (option.data) {
          for (const [key, value] of Object.entries(option.data)) {
            if (isArray$1(value) && value.length)
              formData.append(key, ...value);
            else
              formData.append(key, value);
          }
        }
        formData.append(option.filename, option.file, option.file.name);
        xhr.addEventListener("error", () => {
          option.onError(getError(action, option, xhr));
        });
        xhr.addEventListener("load", () => {
          if (xhr.status < 200 || xhr.status >= 300) {
            return option.onError(getError(action, option, xhr));
          }
          option.onSuccess(getBody(xhr));
        });
        xhr.open(option.method, action, true);
        if (option.withCredentials && "withCredentials" in xhr) {
          xhr.withCredentials = true;
        }
        const headers = option.headers || {};
        if (headers instanceof Headers) {
          headers.forEach((value, key) => xhr.setRequestHeader(key, value));
        } else {
          for (const [key, value] of Object.entries(headers)) {
            if (isNil(value))
              continue;
            xhr.setRequestHeader(key, String(value));
          }
        }
        xhr.send(formData);
        return xhr;
      };
      const uploadListTypes = ["text", "picture", "picture-card"];
      let fileId = 1;
      const genFileId = () => Date.now() + fileId++;
      const uploadBaseProps = buildProps({
        action: {
          type: String,
          default: "#"
        },
        headers: {
          type: definePropType(Object)
        },
        method: {
          type: String,
          default: "post"
        },
        data: {
          type: definePropType([Object, Function, Promise]),
          default: () => mutable({})
        },
        multiple: {
          type: Boolean,
          default: false
        },
        name: {
          type: String,
          default: "file"
        },
        drag: {
          type: Boolean,
          default: false
        },
        withCredentials: Boolean,
        showFileList: {
          type: Boolean,
          default: true
        },
        accept: {
          type: String,
          default: ""
        },
        fileList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        autoUpload: {
          type: Boolean,
          default: true
        },
        listType: {
          type: String,
          values: uploadListTypes,
          default: "text"
        },
        httpRequest: {
          type: definePropType(Function),
          default: ajaxUpload
        },
        disabled: Boolean,
        limit: Number
      });
      const uploadProps = buildProps({
        ...uploadBaseProps,
        beforeUpload: {
          type: definePropType(Function),
          default: NOOP
        },
        beforeRemove: {
          type: definePropType(Function)
        },
        onRemove: {
          type: definePropType(Function),
          default: NOOP
        },
        onChange: {
          type: definePropType(Function),
          default: NOOP
        },
        onPreview: {
          type: definePropType(Function),
          default: NOOP
        },
        onSuccess: {
          type: definePropType(Function),
          default: NOOP
        },
        onProgress: {
          type: definePropType(Function),
          default: NOOP
        },
        onError: {
          type: definePropType(Function),
          default: NOOP
        },
        onExceed: {
          type: definePropType(Function),
          default: NOOP
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const uploadListProps = buildProps({
        files: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        disabled: {
          type: Boolean,
          default: false
        },
        handlePreview: {
          type: definePropType(Function),
          default: NOOP
        },
        listType: {
          type: String,
          values: uploadListTypes,
          default: "text"
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const uploadListEmits = {
        remove: (file) => !!file
      };
      const _hoisted_1$e = ["onKeydown"];
      const _hoisted_2$b = ["src", "crossorigin"];
      const _hoisted_3$9 = ["onClick"];
      const _hoisted_4$4 = ["title"];
      const _hoisted_5$3 = ["onClick"];
      const _hoisted_6$2 = ["onClick"];
      const __default__$3 = defineComponent({
        name: "ElUploadList"
      });
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: uploadListProps,
        emits: uploadListEmits,
        setup(__props, { emit }) {
          const props = __props;
          const { t } = useLocale();
          const nsUpload = useNamespace("upload");
          const nsIcon = useNamespace("icon");
          const nsList = useNamespace("list");
          const disabled = useFormDisabled();
          const focusing = ref(false);
          const containerKls = computed$1(() => [
            nsUpload.b("list"),
            nsUpload.bm("list", props.listType),
            nsUpload.is("disabled", props.disabled)
          ]);
          const handleRemove = (file) => {
            emit("remove", file);
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(TransitionGroup, {
              tag: "ul",
              class: normalizeClass(unref(containerKls)),
              name: unref(nsList).b()
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.files, (file) => {
                  return openBlock(), createElementBlock("li", {
                    key: file.uid || file.name,
                    class: normalizeClass([
                      unref(nsUpload).be("list", "item"),
                      unref(nsUpload).is(file.status),
                      { focusing: focusing.value }
                    ]),
                    tabindex: "0",
                    onKeydown: withKeys(($event) => !unref(disabled) && handleRemove(file), ["delete"]),
                    onFocus: _cache[0] || (_cache[0] = ($event) => focusing.value = true),
                    onBlur: _cache[1] || (_cache[1] = ($event) => focusing.value = false),
                    onClick: _cache[2] || (_cache[2] = ($event) => focusing.value = false)
                  }, [
                    renderSlot(_ctx.$slots, "default", { file }, () => [
                      _ctx.listType === "picture" || file.status !== "uploading" && _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("img", {
                        key: 0,
                        class: normalizeClass(unref(nsUpload).be("list", "item-thumbnail")),
                        src: file.url,
                        crossorigin: _ctx.crossorigin,
                        alt: ""
                      }, null, 10, _hoisted_2$b)) : createCommentVNode("v-if", true),
                      file.status === "uploading" || _ctx.listType !== "picture-card" ? (openBlock(), createElementBlock("div", {
                        key: 1,
                        class: normalizeClass(unref(nsUpload).be("list", "item-info"))
                      }, [
                        createElementVNode("a", {
                          class: normalizeClass(unref(nsUpload).be("list", "item-name")),
                          onClick: withModifiers(($event) => _ctx.handlePreview(file), ["prevent"])
                        }, [
                          createVNode(unref(ElIcon), {
                            class: normalizeClass(unref(nsIcon).m("document"))
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(document_default))
                            ]),
                            _: 1
                          }, 8, ["class"]),
                          createElementVNode("span", {
                            class: normalizeClass(unref(nsUpload).be("list", "item-file-name")),
                            title: file.name
                          }, toDisplayString(file.name), 11, _hoisted_4$4)
                        ], 10, _hoisted_3$9),
                        file.status === "uploading" ? (openBlock(), createBlock(unref(ElProgress), {
                          key: 0,
                          type: _ctx.listType === "picture-card" ? "circle" : "line",
                          "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                          percentage: Number(file.percentage),
                          style: normalizeStyle(_ctx.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                        }, null, 8, ["type", "stroke-width", "percentage", "style"])) : createCommentVNode("v-if", true)
                      ], 2)) : createCommentVNode("v-if", true),
                      createElementVNode("label", {
                        class: normalizeClass(unref(nsUpload).be("list", "item-status-label"))
                      }, [
                        _ctx.listType === "text" ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("circle-check")])
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(circle_check_default))
                          ]),
                          _: 1
                        }, 8, ["class"])) : ["picture-card", "picture"].includes(_ctx.listType) ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 1,
                          class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("check")])
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(check_default))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 2),
                      !unref(disabled) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass(unref(nsIcon).m("close")),
                        onClick: ($event) => handleRemove(file)
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(close_default))
                        ]),
                        _: 2
                      }, 1032, ["class", "onClick"])) : createCommentVNode("v-if", true),
                      createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                      createCommentVNode(" This is a bug which needs to be fixed "),
                      createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
                      !unref(disabled) ? (openBlock(), createElementBlock("i", {
                        key: 3,
                        class: normalizeClass(unref(nsIcon).m("close-tip"))
                      }, toDisplayString(unref(t)("el.upload.deleteTip")), 3)) : createCommentVNode("v-if", true),
                      _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("span", {
                        key: 4,
                        class: normalizeClass(unref(nsUpload).be("list", "item-actions"))
                      }, [
                        createElementVNode("span", {
                          class: normalizeClass(unref(nsUpload).be("list", "item-preview")),
                          onClick: ($event) => _ctx.handlePreview(file)
                        }, [
                          createVNode(unref(ElIcon), {
                            class: normalizeClass(unref(nsIcon).m("zoom-in"))
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(zoom_in_default))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 10, _hoisted_5$3),
                        !unref(disabled) ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: normalizeClass(unref(nsUpload).be("list", "item-delete")),
                          onClick: ($event) => handleRemove(file)
                        }, [
                          createVNode(unref(ElIcon), {
                            class: normalizeClass(unref(nsIcon).m("delete"))
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(delete_default))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 10, _hoisted_6$2)) : createCommentVNode("v-if", true)
                      ], 2)) : createCommentVNode("v-if", true)
                    ])
                  ], 42, _hoisted_1$e);
                }), 128)),
                renderSlot(_ctx.$slots, "append")
              ]),
              _: 3
            }, 8, ["class", "name"]);
          };
        }
      });
      var UploadList = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "upload-list.vue"]]);
      const uploadDraggerProps = buildProps({
        disabled: {
          type: Boolean,
          default: false
        }
      });
      const uploadDraggerEmits = {
        file: (file) => isArray$1(file)
      };
      const _hoisted_1$d = ["onDrop", "onDragover"];
      const COMPONENT_NAME = "ElUploadDrag";
      const __default__$2 = defineComponent({
        name: COMPONENT_NAME
      });
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: uploadDraggerProps,
        emits: uploadDraggerEmits,
        setup(__props, { emit }) {
          const uploaderContext = inject(uploadContextKey);
          if (!uploaderContext) {
            throwError(COMPONENT_NAME, "usage: <el-upload><el-upload-dragger /></el-upload>");
          }
          const ns = useNamespace("upload");
          const dragover = ref(false);
          const disabled = useFormDisabled();
          const onDrop = (e) => {
            if (disabled.value)
              return;
            dragover.value = false;
            e.stopPropagation();
            const files = Array.from(e.dataTransfer.files);
            emit("file", files);
          };
          const onDragover = () => {
            if (!disabled.value)
              dragover.value = true;
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b("dragger"), unref(ns).is("dragover", dragover.value)]),
              onDrop: withModifiers(onDrop, ["prevent"]),
              onDragover: withModifiers(onDragover, ["prevent"]),
              onDragleave: _cache[0] || (_cache[0] = withModifiers(($event) => dragover.value = false, ["prevent"]))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 42, _hoisted_1$d);
          };
        }
      });
      var UploadDragger = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "upload-dragger.vue"]]);
      const uploadContentProps = buildProps({
        ...uploadBaseProps,
        beforeUpload: {
          type: definePropType(Function),
          default: NOOP
        },
        onRemove: {
          type: definePropType(Function),
          default: NOOP
        },
        onStart: {
          type: definePropType(Function),
          default: NOOP
        },
        onSuccess: {
          type: definePropType(Function),
          default: NOOP
        },
        onProgress: {
          type: definePropType(Function),
          default: NOOP
        },
        onError: {
          type: definePropType(Function),
          default: NOOP
        },
        onExceed: {
          type: definePropType(Function),
          default: NOOP
        }
      });
      const _hoisted_1$c = ["onKeydown"];
      const _hoisted_2$a = ["name", "multiple", "accept"];
      const __default__$1 = defineComponent({
        name: "ElUploadContent",
        inheritAttrs: false
      });
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: uploadContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("upload");
          const disabled = useFormDisabled();
          const requests = shallowRef({});
          const inputRef = shallowRef();
          const uploadFiles = (files) => {
            if (files.length === 0)
              return;
            const { autoUpload, limit, fileList, multiple, onStart, onExceed } = props;
            if (limit && fileList.length + files.length > limit) {
              onExceed(files, fileList);
              return;
            }
            if (!multiple) {
              files = files.slice(0, 1);
            }
            for (const file of files) {
              const rawFile = file;
              rawFile.uid = genFileId();
              onStart(rawFile);
              if (autoUpload)
                upload(rawFile);
            }
          };
          const upload = async (rawFile) => {
            inputRef.value.value = "";
            if (!props.beforeUpload) {
              return doUpload(rawFile);
            }
            let hookResult;
            let beforeData = {};
            try {
              const originData = props.data;
              const beforeUploadPromise = props.beforeUpload(rawFile);
              beforeData = isPlainObject$1(props.data) ? cloneDeep(props.data) : props.data;
              hookResult = await beforeUploadPromise;
              if (isPlainObject$1(props.data) && isEqual(originData, beforeData)) {
                beforeData = cloneDeep(props.data);
              }
            } catch (e) {
              hookResult = false;
            }
            if (hookResult === false) {
              props.onRemove(rawFile);
              return;
            }
            let file = rawFile;
            if (hookResult instanceof Blob) {
              if (hookResult instanceof File) {
                file = hookResult;
              } else {
                file = new File([hookResult], rawFile.name, {
                  type: rawFile.type
                });
              }
            }
            doUpload(Object.assign(file, {
              uid: rawFile.uid
            }), beforeData);
          };
          const resolveData = async (data, rawFile) => {
            if (isFunction$1(data)) {
              return data(rawFile);
            }
            return data;
          };
          const doUpload = async (rawFile, beforeData) => {
            const {
              headers,
              data,
              method: method4,
              withCredentials,
              name: filename,
              action,
              onProgress,
              onSuccess,
              onError,
              httpRequest
            } = props;
            try {
              beforeData = await resolveData(beforeData != null ? beforeData : data, rawFile);
            } catch (e) {
              props.onRemove(rawFile);
              return;
            }
            const { uid } = rawFile;
            const options = {
              headers: headers || {},
              withCredentials,
              file: rawFile,
              data: beforeData,
              method: method4,
              filename,
              action,
              onProgress: (evt) => {
                onProgress(evt, rawFile);
              },
              onSuccess: (res) => {
                onSuccess(res, rawFile);
                delete requests.value[uid];
              },
              onError: (err) => {
                onError(err, rawFile);
                delete requests.value[uid];
              }
            };
            const request = httpRequest(options);
            requests.value[uid] = request;
            if (request instanceof Promise) {
              request.then(options.onSuccess, options.onError);
            }
          };
          const handleChange = (e) => {
            const files = e.target.files;
            if (!files)
              return;
            uploadFiles(Array.from(files));
          };
          const handleClick = () => {
            if (!disabled.value) {
              inputRef.value.value = "";
              inputRef.value.click();
            }
          };
          const handleKeydown = () => {
            handleClick();
          };
          const abort = (file) => {
            const _reqs = entriesOf(requests.value).filter(file ? ([uid]) => String(file.uid) === uid : () => true);
            _reqs.forEach(([uid, req]) => {
              if (req instanceof XMLHttpRequest)
                req.abort();
              delete requests.value[uid];
            });
          };
          expose({
            abort,
            upload
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.listType), unref(ns).is("drag", _ctx.drag)]),
              tabindex: "0",
              onClick: handleClick,
              onKeydown: withKeys(withModifiers(handleKeydown, ["self"]), ["enter", "space"])
            }, [
              _ctx.drag ? (openBlock(), createBlock(UploadDragger, {
                key: 0,
                disabled: unref(disabled),
                onFile: uploadFiles
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["disabled"])) : renderSlot(_ctx.$slots, "default", { key: 1 }),
              createElementVNode("input", {
                ref_key: "inputRef",
                ref: inputRef,
                class: normalizeClass(unref(ns).e("input")),
                name: _ctx.name,
                multiple: _ctx.multiple,
                accept: _ctx.accept,
                type: "file",
                onChange: handleChange,
                onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_2$a)
            ], 42, _hoisted_1$c);
          };
        }
      });
      var UploadContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "upload-content.vue"]]);
      const SCOPE = "ElUpload";
      const revokeFileObjectURL = (file) => {
        var _a;
        if ((_a = file.url) == null ? void 0 : _a.startsWith("blob:")) {
          URL.revokeObjectURL(file.url);
        }
      };
      const useHandlers = (props, uploadRef) => {
        const uploadFiles = useVModel(props, "fileList", void 0, { passive: true });
        const getFile = (rawFile) => uploadFiles.value.find((file) => file.uid === rawFile.uid);
        function abort(file) {
          var _a;
          (_a = uploadRef.value) == null ? void 0 : _a.abort(file);
        }
        function clearFiles(states = ["ready", "uploading", "success", "fail"]) {
          uploadFiles.value = uploadFiles.value.filter((row) => !states.includes(row.status));
        }
        const handleError = (err, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          console.error(err);
          file.status = "fail";
          uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
          props.onError(err, file, uploadFiles.value);
          props.onChange(file, uploadFiles.value);
        };
        const handleProgress = (evt, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          props.onProgress(evt, file, uploadFiles.value);
          file.status = "uploading";
          file.percentage = Math.round(evt.percent);
        };
        const handleSuccess = (response, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          file.status = "success";
          file.response = response;
          props.onSuccess(response, file, uploadFiles.value);
          props.onChange(file, uploadFiles.value);
        };
        const handleStart = (file) => {
          if (isNil(file.uid))
            file.uid = genFileId();
          const uploadFile = {
            name: file.name,
            percentage: 0,
            status: "ready",
            size: file.size,
            raw: file,
            uid: file.uid
          };
          if (props.listType === "picture-card" || props.listType === "picture") {
            try {
              uploadFile.url = URL.createObjectURL(file);
            } catch (err) {
              debugWarn(SCOPE, err.message);
              props.onError(err, uploadFile, uploadFiles.value);
            }
          }
          uploadFiles.value = [...uploadFiles.value, uploadFile];
          props.onChange(uploadFile, uploadFiles.value);
        };
        const handleRemove = async (file) => {
          const uploadFile = file instanceof File ? getFile(file) : file;
          if (!uploadFile)
            throwError(SCOPE, "file to be removed not found");
          const doRemove = (file2) => {
            abort(file2);
            const fileList = uploadFiles.value;
            fileList.splice(fileList.indexOf(file2), 1);
            props.onRemove(file2, fileList);
            revokeFileObjectURL(file2);
          };
          if (props.beforeRemove) {
            const before = await props.beforeRemove(uploadFile, uploadFiles.value);
            if (before !== false)
              doRemove(uploadFile);
          } else {
            doRemove(uploadFile);
          }
        };
        function submit() {
          uploadFiles.value.filter(({ status }) => status === "ready").forEach(({ raw }) => {
            var _a;
            return raw && ((_a = uploadRef.value) == null ? void 0 : _a.upload(raw));
          });
        }
        watch(() => props.listType, (val) => {
          if (val !== "picture-card" && val !== "picture") {
            return;
          }
          uploadFiles.value = uploadFiles.value.map((file) => {
            const { raw, url: url2 } = file;
            if (!url2 && raw) {
              try {
                file.url = URL.createObjectURL(raw);
              } catch (err) {
                props.onError(err, file, uploadFiles.value);
              }
            }
            return file;
          });
        });
        watch(uploadFiles, (files) => {
          for (const file of files) {
            file.uid || (file.uid = genFileId());
            file.status || (file.status = "success");
          }
        }, { immediate: true, deep: true });
        return {
          uploadFiles,
          abort,
          clearFiles,
          handleError,
          handleProgress,
          handleStart,
          handleSuccess,
          handleRemove,
          submit,
          revokeFileObjectURL
        };
      };
      const __default__ = defineComponent({
        name: "ElUpload"
      });
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: uploadProps,
        setup(__props, { expose }) {
          const props = __props;
          const disabled = useFormDisabled();
          const uploadRef = shallowRef();
          const {
            abort,
            submit,
            clearFiles,
            uploadFiles,
            handleStart,
            handleError,
            handleRemove,
            handleSuccess,
            handleProgress,
            revokeFileObjectURL: revokeFileObjectURL2
          } = useHandlers(props, uploadRef);
          const isPictureCard = computed$1(() => props.listType === "picture-card");
          const uploadContentProps2 = computed$1(() => ({
            ...props,
            fileList: uploadFiles.value,
            onStart: handleStart,
            onProgress: handleProgress,
            onSuccess: handleSuccess,
            onError: handleError,
            onRemove: handleRemove
          }));
          onBeforeUnmount(() => {
            uploadFiles.value.forEach(revokeFileObjectURL2);
          });
          provide(uploadContextKey, {
            accept: toRef(props, "accept")
          });
          expose({
            abort,
            submit,
            clearFiles,
            handleStart,
            handleRemove
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", null, [
              unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
                key: 0,
                disabled: unref(disabled),
                "list-type": _ctx.listType,
                files: unref(uploadFiles),
                crossorigin: _ctx.crossorigin,
                "handle-preview": _ctx.onPreview,
                onRemove: unref(handleRemove)
              }, createSlots({
                append: withCtx(() => [
                  createVNode(UploadContent, mergeProps({
                    ref_key: "uploadRef",
                    ref: uploadRef
                  }, unref(uploadContentProps2)), {
                    default: withCtx(() => [
                      _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                      !_ctx.$slots.trigger && _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16)
                ]),
                _: 2
              }, [
                _ctx.$slots.file ? {
                  name: "default",
                  fn: withCtx(({ file }) => [
                    renderSlot(_ctx.$slots, "file", { file })
                  ])
                } : void 0
              ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true),
              !unref(isPictureCard) || unref(isPictureCard) && !_ctx.showFileList ? (openBlock(), createBlock(UploadContent, mergeProps({
                key: 1,
                ref_key: "uploadRef",
                ref: uploadRef
              }, unref(uploadContentProps2)), {
                default: withCtx(() => [
                  _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                  !_ctx.$slots.trigger && _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 16)) : createCommentVNode("v-if", true),
              _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "default", { key: 2 }) : createCommentVNode("v-if", true),
              renderSlot(_ctx.$slots, "tip"),
              !unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
                key: 3,
                disabled: unref(disabled),
                "list-type": _ctx.listType,
                files: unref(uploadFiles),
                crossorigin: _ctx.crossorigin,
                "handle-preview": _ctx.onPreview,
                onRemove: unref(handleRemove)
              }, createSlots({ _: 2 }, [
                _ctx.$slots.file ? {
                  name: "default",
                  fn: withCtx(({ file }) => [
                    renderSlot(_ctx.$slots, "file", { file })
                  ])
                } : void 0
              ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true)
            ]);
          };
        }
      });
      var Upload$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "upload.vue"]]);
      const ElUpload = withInstall(Upload$1);
      const _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const _sfc_main$d = {};
      const _hoisted_1$b = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$9 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "m64 448 832-320-128 704-446.08-243.328L832 192 242.816 545.472zm256 512V657.024L512 768z"
      }, null, -1);
      const _hoisted_3$8 = [
        _hoisted_2$9
      ];
      function _sfc_render$6(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_3$8);
      }
      const Promotion = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$6]]);
      const _sfc_main$c = {};
      const _hoisted_1$a = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$8 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248z"
      }, null, -1);
      const _hoisted_3$7 = [
        _hoisted_2$8
      ];
      function _sfc_render$5(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$7);
      }
      const Upload = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$5]]);
      const _sfc_main$b = {};
      const _hoisted_1$9 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$7 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M864 409.6a192 192 0 0 1-37.888 349.44A256.064 256.064 0 0 1 576 960h-96a32 32 0 1 1 0-64h96a192.064 192.064 0 0 0 181.12-128H736a32 32 0 0 1-32-32V416a32 32 0 0 1 32-32h32c10.368 0 20.544.832 30.528 2.432a288 288 0 0 0-573.056 0A193.235 193.235 0 0 1 256 384h32a32 32 0 0 1 32 32v320a32 32 0 0 1-32 32h-32a192 192 0 0 1-96-358.4 352 352 0 0 1 704 0M256 448a128 128 0 1 0 0 256zm640 128a128 128 0 0 0-128-128v256a128 128 0 0 0 128-128"
      }, null, -1);
      const _hoisted_3$6 = [
        _hoisted_2$7
      ];
      function _sfc_render$4(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_3$6);
      }
      const Service = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$4]]);
      const _sfc_main$a = {};
      const _hoisted_1$8 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$6 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M704 704h64v192H256V704h64v64h384zm188.544-152.192C894.528 559.616 896 567.616 896 576a96 96 0 1 1-192 0 96 96 0 1 1-192 0 96 96 0 1 1-192 0 96 96 0 1 1-192 0c0-8.384 1.408-16.384 3.392-24.192L192 128h640z"
      }, null, -1);
      const _hoisted_3$5 = [
        _hoisted_2$6
      ];
      function _sfc_render$3(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_3$5);
      }
      const Shop = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$3]]);
      const _sfc_main$9 = {};
      const _hoisted_1$7 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$5 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M640 288h-64V128H128v704h384v32a32 32 0 0 0 32 32H96a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32h512a32 32 0 0 1 32 32z"
      }, null, -1);
      const _hoisted_3$4 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M128 320v512h768V320zm-32-64h832a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32"
      }, null, -1);
      const _hoisted_4$3 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M704 640a64 64 0 1 1 0-128 64 64 0 0 1 0 128"
      }, null, -1);
      const _hoisted_5$2 = [
        _hoisted_2$5,
        _hoisted_3$4,
        _hoisted_4$3
      ];
      function _sfc_render$2(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$7, _hoisted_5$2);
      }
      const Wallet = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$2]]);
      const _sfc_main$8 = {};
      const _hoisted_1$6 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$4 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M224 318.336V896h576V318.336L552.512 115.84a64 64 0 0 0-81.024 0zM593.024 66.304l259.2 212.096A32 32 0 0 1 864 303.168V928a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V303.168a32 32 0 0 1 11.712-24.768l259.2-212.096a128 128 0 0 1 162.112 0z"
      }, null, -1);
      const _hoisted_3$3 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128m0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256"
      }, null, -1);
      const _hoisted_4$2 = [
        _hoisted_2$4,
        _hoisted_3$3
      ];
      function _sfc_render$1(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$6, _hoisted_4$2);
      }
      const PriceTag = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$1]]);
      const _sfc_main$7 = {};
      const _hoisted_1$5 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      const _hoisted_2$3 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
      }, null, -1);
      const _hoisted_3$2 = [
        _hoisted_2$3
      ];
      function _sfc_render(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$5, _hoisted_3$2);
      }
      const CircleCloseFilled = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render]]);
      class SSEClient {
        constructor(url2) {
          __publicField(this, "eventSource");
          __publicField(this, "callbackList");
          this.url = url2;
          this.eventSource = null;
          this.callbackList = [];
        }
        start() {
          let authorization = localStorage.getItem("Authorization");
          this.eventSource = new EventSourcePolyfill(this.url, {
            withCredentials: true,
            // 5分钟超时(略小于nginx sse超时时间)
            heartbeatTimeout: 5 * 59 * 1e3,
            headers: {
              "Authorization": authorization
            }
          });
          this.eventSource.onmessage = (event) => {
            this.callbackList.forEach((callBackFunc) => callBackFunc(event));
          };
          this.eventSource.onerror = (error) => {
            this.close();
          };
        }
        addEventListener(eventType, listener) {
          if (this.eventSource) {
            this.eventSource.addEventListener(eventType, listener);
          }
        }
        addOnMsgCallback(func) {
          this.callbackList.push(func);
        }
        close() {
          if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
          }
        }
      }
      const _withScopeId = (n) => (pushScopeId("data-v-382b5e09"), n = n(), popScopeId(), n);
      const _hoisted_1$4 = { key: 0 };
      const _hoisted_2$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_3$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_4$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("p", { style: { "font-size": "15px" } }, "导入简历", -1));
      const _hoisted_5$1 = { style: { "font-size": "15px" } };
      const _hoisted_6$1 = { style: { "font-size": "15px" } };
      const _hoisted_7$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", { style: { "color": "orangered" } }, "AI坐席（👈点这里查看更多）", -1));
      const _hoisted_8 = { class: "my-header" };
      const _hoisted_9 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_10 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("h3", null, "我的产品列表", -1));
      const _hoisted_11 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_12 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_13 = {
        type: "info",
        style: { "margin-top": "10px" }
      };
      const _hoisted_14 = { key: 0 };
      const _hoisted_15 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_16 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
      const _hoisted_17 = { style: { "padding-top": "10px" } };
      const _hoisted_18 = { class: "demonstration" };
      const _hoisted_19 = { class: "demonstration" };
      const _hoisted_20 = { class: "demonstration" };
      const _hoisted_21 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("div", { class: "image-slot" }, "加载订单二维码失败；请稍后刷新重试", -1));
      const _hoisted_22 = { style: { "width": "80%" } };
      const _hoisted_23 = { class: "demonstration" };
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        __name: "AiJob",
        setup(__props) {
          const platform = inject("$platform");
          const axios$1 = inject("$axios");
          const pushStatus = ref(PushStatus.NOT_START);
          const pushBtnType = ref("primary");
          const pushBtnText = ref("开始投递");
          const aiSeatBuyVisible = ref(false);
          const importResumeLoading = ref(false);
          const buyProductList = ref([]);
          const showOtherProduct = ref(true);
          const orderGroup = ref([]);
          const payStatus = ref(false);
          const promotionCode = ref("");
          const lastPromotionCode = ref("");
          let loginStore = LoginStore();
          let pushResultCounter = pushResultCount();
          const userStore = UserStore();
          const isExpired = (row) => {
            const currentTime = /* @__PURE__ */ new Date();
            const endTime = new Date(row.periodOfValidityEndTime);
            return currentTime > endTime;
          };
          const randomStyle = () => {
            const tagStyleArr = ["primary", "warning", "success", "danger"];
            let number4 = Math.floor(Math.random() * 4);
            return tagStyleArr[number4];
          };
          const handlerImport = async () => {
            var _a, _b, _c, _d;
            if (!loginInterceptor()) {
              return;
            }
            const token = (_b = (_a = Tools.window) == null ? void 0 : _a._PAGE) == null ? void 0 : _b.token;
            let bossUserId = (_d = (_c = Tools.window) == null ? void 0 : _c._PAGE) == null ? void 0 : _d.uid;
            if (!bossUserId) {
              ElMessage({
                message: "未获取到Boss userId 请刷新页面重试",
                type: "error",
                duration: 3e3
              });
              return;
            }
            importResumeLoading.value = true;
            let resumeInfoResp = await axios.get("https://www.zhipin.com/wapi/zpgeek/resume/sidebar.json", { headers: { "Zp_token": token } });
            let zpData = resumeInfoResp.data.zpData;
            if (!zpData.attachmentList) {
              importResumeLoading.value = false;
              throw Error("请先在BOSS个人中心上传附件简历");
            }
            let resumeId = zpData.attachmentList[0].resumeId;
            let resumeFileResp = await fetchWithGM_request(
              "https://docdownload.zhipin.com/wflow/zpgeek/download/download4geek?resumeId=" + resumeId,
              { headers: { "Zp_token": token }, responseType: "arraybuffer" }
            );
            let fileBlob = new Blob([resumeFileResp.response], { type: "application/pdf" });
            let formData = new FormData();
            formData.append("file", fileBlob);
            formData.append("resumeId", resumeId);
            formData.append("uniqueId", bossUserId);
            let importResp = await axios$1.post("/api/user/import/resume", formData, { headers: { "Content-Type": "multipart/form-data" } });
            if (importResp.data.code != 200) {
              ElMessage({
                message: "导入简历失败" + importResp.data.data.msg,
                type: "error",
                duration: 3e3
              });
              importResumeLoading.value = false;
              return;
            }
            let loginResp = await axios$1.post("/api/user/silently/login?uniqueId=" + bossUserId);
            localStorage.setItem("Authorization", loginResp.data.data);
            if (!importResp.data.data.email) {
              ElMessage({
                message: "导入简历成功；但未识别到邮箱，请在偏好设置中完善[通知邮箱]",
                type: "warning",
                duration: 3e3
              });
              importResumeLoading.value = false;
              return;
            }
            ElMessage({
              message: "导入简历成功",
              type: "success",
              duration: 3e3
            });
            importResumeLoading.value = false;
          };
          const handlerPush = () => {
            switch (pushStatus.value) {
              case PushStatus.NOT_START:
                startPush();
                break;
              case PushStatus.PUSHING:
                pausePush();
                break;
              case PushStatus.PAUSE:
                startPush();
                break;
            }
          };
          const selfDefPushCountLimit = ref(platform.selfDefPushCountLimit);
          const selfDefPushCountLimitChange = (val) => {
            platform.selfDefPushCountLimit = val;
          };
          const mockPush = ref(false);
          const startPush = () => {
            if (!loginInterceptor()) {
              return;
            }
            platform.pushMock = mockPush.value;
            pushStatus.value = PushStatus.PUSHING;
            pushBtnType.value = "warning";
            pushBtnText.value = "停止投递";
            let pushResultPromise = platform.startPush();
            pushResultPromise.then(() => {
              ElMessage({
                message: "批量投递完成",
                type: "success",
                duration: 3e3
              });
              setTimeout(() => {
                pushStatus.value = PushStatus.PAUSE;
                pushBtnType.value = "primary";
                pushBtnText.value = "开始投递";
              }, 200);
            });
          };
          const pausePush = () => {
            platform.pausePush();
            pushStatus.value = PushStatus.PAUSE;
            pushBtnType.value = "primary";
            pushBtnText.value = "开始投递";
          };
          const handlerAISeatClick = async () => {
            aiSeatBuyVisible.value = true;
            if (buyProductList.value.length <= 0) {
              await queryBuyProductList();
            }
            showOtherProduct.value = false;
          };
          const queryBuyProductList = async () => {
            let productResp = await axios$1.post("/api/product/user/product/list");
            buyProductList.value = productResp.data.data;
          };
          const showOrderGroup = async () => {
            if (!loginInterceptor()) {
              return;
            }
            let promotionCodeVar = promotionCode.value.trim();
            promotionCode.value = "";
            setTimeout(() => {
              showOtherProduct.value = true;
            }, 100);
            if (orderGroup.value.length < 1 || promotionCodeVar !== lastPromotionCode.value) {
              let orderGroupResp = await axios$1.post("/api/pay/generate/order/group", { promotionCode: promotionCodeVar });
              if (orderGroupResp.data.code != 200) {
                ElMessage({
                  message: orderGroupResp.data.message,
                  type: "warning",
                  duration: 3e3
                });
                setTimeout(() => {
                  showOtherProduct.value = false;
                }, 100);
                return;
              }
              orderGroup.value = orderGroupResp.data.data;
              lastPromotionCode.value = promotionCodeVar;
            }
            waitUsePay();
          };
          const waitUsePay = () => {
            const sseClient = new SSEClient(axios$1.defaults.baseURL + "api/sse/connect");
            sseClient.addOnMsgCallback((event) => {
              let data = event.data;
              if (data === "支付成功") {
                payStatus.value = true;
                orderGroup.value = [];
                queryBuyProductList();
                showOtherProduct.value = false;
                firstAiSeatStatus.value = 0;
              }
            });
            sseClient.start();
            let count = 0;
            let interval = setInterval(() => {
              if (payStatus.value) {
                clearInterval(interval);
              }
              orderGroup.value.forEach((orderItem) => {
                axios$1.get("/api/pay/searchOrder?outTradeNo=" + orderItem.orderId).then((resp) => {
                  if (resp.data.data === "TRADE_SUCCESS") {
                    payStatus.value = true;
                    orderGroup.value = [];
                    clearInterval(interval);
                  }
                  if (resp.data.data === "WAIT_BUYER_PAY") {
                    logger$1.debug("等待支付");
                  }
                  count++;
                  if (count >= 10) {
                    logger$1.warn("订单超时未支付");
                    clearInterval(interval);
                  }
                });
              });
            }, 3e4);
          };
          const firstAiSeatStatus = ref(userStore.user.aiSeatStatus);
          setTimeout(() => {
            firstAiSeatStatus.value = userStore.user.aiSeatStatus;
            logger$1.info("firstAiSeatStatus", firstAiSeatStatus.value);
          }, 1500);
          const handlerAISeatStatusChange = async (val) => {
            if (firstAiSeatStatus.value == null) {
              return;
            }
            if (!loginInterceptor()) {
              return;
            }
            return axios$1.post("/api/user/save/preference", {
              aiSeatStatus: val ? 1 : 0
            }).then((resp) => {
              if (val && resp.data.message && resp.data.message !== "成功") {
                ElNotification({
                  message: resp.data.message,
                  type: "success",
                  duration: 2e3
                });
              }
            }).catch((_2) => {
              userStore.user.aiSeatStatus = firstAiSeatStatus.value;
            });
          };
          const handlerAISeatSwitchClick = async () => {
            if (firstAiSeatStatus.value == null) {
              ElMessage({
                message: "请先点击前面的AI坐席购买",
                grouping: true,
                type: "info",
                duration: 3e3
              });
            }
          };
          if (!loginStore.login && !loginStore.loginFailStatus) {
            logger$1.info("页面静默登录");
            silentlyLogin("").catch((_2) => {
            });
          }
          return (_ctx, _cache) => {
            const _component_el_text = ElText;
            const _component_el_input_number = ElInputNumber;
            const _component_el_switch = ElSwitch;
            const _component_el_button = ElButton;
            const _component_el_tooltip = ElTooltip;
            const _component_el_link = ElLink;
            const _component_el_icon = ElIcon;
            const _component_el_table_column = ElTableColumn;
            const _component_el_tag = ElTag;
            const _component_el_table = ElTable;
            const _component_el_input = ElInput;
            const _component_el_image = ElImage;
            const _component_el_dialog = ElDialog;
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(_component_el_text, {
                size: "large",
                class: "mx-1",
                type: "primary"
              }, {
                default: withCtx(() => [
                  createTextVNode("投递成功：" + toDisplayString(unref(pushResultCounter).successCount) + "    ", 1)
                ]),
                _: 1
              }),
              createVNode(_component_el_text, {
                size: "large",
                class: "mx-1",
                type: "danger"
              }, {
                default: withCtx(() => [
                  createTextVNode(" 投递失败：" + toDisplayString(unref(pushResultCounter).failCount) + "    ", 1)
                ]),
                _: 1
              }),
              createVNode(_component_el_text, {
                size: "large",
                class: "mx-1"
              }, {
                default: withCtx(() => [
                  createTextVNode(" 单次投递限制数量：")
                ]),
                _: 1
              }),
              createVNode(_component_el_input_number, {
                modelValue: selfDefPushCountLimit.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selfDefPushCountLimit.value = $event),
                min: -1,
                max: 100,
                onChange: selfDefPushCountLimitChange
              }, null, 8, ["modelValue"]),
              !unref(isProdEnv)() ? (openBlock(), createElementBlock("span", _hoisted_1$4, [
                createTextVNode("    MOCK投递  "),
                createVNode(_component_el_switch, {
                  modelValue: mockPush.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => mockPush.value = $event)
                }, null, 8, ["modelValue"])
              ])) : createCommentVNode("", true),
              _hoisted_2$2,
              _hoisted_3$1,
              createVNode(_component_el_button, {
                icon: unref(Upload),
                type: "primary",
                onClick: handlerImport,
                loading: importResumeLoading.value
              }, {
                default: withCtx(() => [
                  _hoisted_4$1
                ]),
                _: 1
              }, 8, ["icon", "loading"]),
              createVNode(_component_el_button, {
                icon: unref(Promotion),
                type: pushBtnType.value,
                onClick: handlerPush
              }, {
                default: withCtx(() => [
                  createElementVNode("p", _hoisted_5$1, toDisplayString(pushBtnText.value), 1)
                ]),
                _: 1
              }, 8, ["icon", "type"]),
              createVNode(_component_el_tooltip, {
                effect: "dark",
                "raw-content": "",
                content: "\r\n    AI坐席：<span style='color:red;'>支持试用了，点击开关开启试用</span><br/>\r\n    - 自动响应hr的消息,根据您的简历信息进行定制化回答。<br/>\r\n    - 高意向职位邮件通知，快速筛选出最合适的职位。<br/>\r\n    - 快捷发送简历，交换 wx、联系方式。<br/>\r\n    - hr拒绝挽留，不放过每一个机会。<br/>\r\n    ",
                placement: "bottom"
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_button, {
                    icon: unref(Service),
                    color: "#626aef",
                    type: "danger",
                    onClick: handlerAISeatClick
                  }, {
                    default: withCtx(() => [
                      createElementVNode("p", _hoisted_6$1, [
                        _hoisted_7$1,
                        createVNode(_component_el_switch, {
                          "active-text": "开",
                          "inactive-text": "关",
                          "inline-prompt": "",
                          style: { "--el-switch-on-color": "#13ce66", "--el-switch-off-color": "#ff4949" },
                          modelValue: unref(userStore).user.aiSeatStatus,
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(userStore).user.aiSeatStatus = $event),
                          onClick: withModifiers(handlerAISeatSwitchClick, ["stop"]),
                          onChange: handlerAISeatStatusChange
                        }, null, 8, ["modelValue"])
                      ])
                    ]),
                    _: 1
                  }, 8, ["icon"])
                ]),
                _: 1
              }),
              createVNode(_component_el_link, {
                type: "primary",
                href: "https://www.bilibili.com/video/BV1y6PjesEvi",
                target: "_blank",
                style: { "margin-left": "10px", "margin-top": "10px" }
              }, {
                default: withCtx(() => [
                  createTextVNode("点击查看AI坐席效果演示")
                ]),
                _: 1
              }),
              createVNode(_component_el_dialog, {
                modelValue: aiSeatBuyVisible.value,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => aiSeatBuyVisible.value = $event),
                "show-close": false,
                width: "800"
              }, {
                header: withCtx(({ close, titleId, titleClass }) => [
                  createElementVNode("div", _hoisted_8, [
                    createVNode(_component_el_text, {
                      size: "large",
                      style: { "font-size": "20px" },
                      type: "info"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("AI坐席 （求职者分身）")
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_button, {
                      type: "warning",
                      onClick: close
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_icon, { class: "el-icon--left" }, {
                          default: withCtx(() => [
                            createVNode(unref(CircleCloseFilled))
                          ]),
                          _: 1
                        }),
                        createTextVNode(" 关闭 ")
                      ]),
                      _: 2
                    }, 1032, ["onClick"])
                  ]),
                  withDirectives(createElementVNode("div", null, [
                    _hoisted_9,
                    _hoisted_10,
                    _hoisted_11,
                    withDirectives(createVNode(_component_el_table, {
                      data: buyProductList.value,
                      stripe: "",
                      style: { "width": "100%" }
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_table_column, {
                          prop: "productName",
                          label: "产品",
                          width: "180"
                        }, {
                          default: withCtx(({ row }) => [
                            createElementVNode("span", {
                              style: normalizeStyle({ textDecoration: isExpired(row) ? "line-through" : "none" })
                            }, toDisplayString(row.productName), 5)
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_table_column, {
                          label: "状态",
                          width: "100"
                        }, {
                          default: withCtx(({ row }) => [
                            createElementVNode("span", {
                              style: normalizeStyle({ color: isExpired(row) ? "red" : "green" })
                            }, toDisplayString(isExpired(row) ? "过期" : "正常"), 5)
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_table_column, {
                          prop: "powerList",
                          label: "能力",
                          width: "180"
                        }, {
                          default: withCtx(({ row }) => [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(row.powerList, (power) => {
                              return openBlock(), createElementBlock("div", { key: power }, [
                                createVNode(_component_el_tag, {
                                  effect: "dark",
                                  type: randomStyle(),
                                  size: "small"
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(power), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["type"])
                              ]);
                            }), 128))
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_table_column, {
                          prop: "periodOfValidityStartTime",
                          label: "有效期开始时间"
                        }),
                        createVNode(_component_el_table_column, {
                          prop: "periodOfValidityEndTime",
                          label: "有效期结束时间"
                        })
                      ]),
                      _: 1
                    }, 8, ["data"]), [
                      [vShow, buyProductList.value.length > 0]
                    ]),
                    _hoisted_12
                  ], 512), [
                    [vShow, buyProductList.value.length > 0]
                  ]),
                  createElementVNode("div", _hoisted_13, [
                    createVNode(_component_el_button, {
                      type: "danger",
                      icon: unref(Shop),
                      onClick: showOrderGroup
                    }, {
                      default: withCtx(() => [
                        createTextVNode(" 更多产品 ")
                      ]),
                      _: 1
                    }, 8, ["icon"]),
                    createVNode(_component_el_input, {
                      "suffix-icon": unref(Wallet),
                      modelValue: promotionCode.value,
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => promotionCode.value = $event),
                      style: { "margin-left": "10px", "width": "240px" },
                      placeholder: "请输入您的优惠码"
                    }, null, 8, ["suffix-icon", "modelValue"]),
                    createVNode(_component_el_link, {
                      icon: unref(PriceTag),
                      type: "primary",
                      style: { "margin-left": "30px" },
                      target: "_blank",
                      href: "https://www.bilibili.com/video/BV1HKAyebESp"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("点击获取优惠码(评论区)")
                      ]),
                      _: 1
                    }, 8, ["icon"])
                  ]),
                  showOtherProduct.value ? (openBlock(), createElementBlock("div", _hoisted_14, [
                    _hoisted_15,
                    createElementVNode("p", null, [
                      createVNode(_component_el_text, {
                        class: "mx-1",
                        type: "danger"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("定价说明：")
                        ]),
                        _: 1
                      }),
                      createTextVNode(" 使用R1深度思考大模型时：首先，R1的价格更贵，深度思考的内容也会被记录token消耗。token消耗量巨大。同时由于boss的会话聊天机制，需要携带消息上下文调用。这也就意味着对话轮数越多，token消耗越多。按乘方的趋势增长。 ")
                    ]),
                    _hoisted_16,
                    (openBlock(true), createElementBlock(Fragment, null, renderList(orderGroup.value, (order) => {
                      return openBlock(), createElementBlock("div", {
                        key: order,
                        style: normalizeStyle([{ "display": "flex" }, "width: " + 1 / orderGroup.value.length]),
                        class: "block"
                      }, [
                        createElementVNode("div", _hoisted_17, [
                          createElementVNode("p", _hoisted_18, [
                            createVNode(_component_el_text, {
                              size: "large",
                              type: "primary"
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(order.title), 1)
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          createElementVNode("p", _hoisted_19, [
                            createVNode(_component_el_text, {
                              size: "large",
                              type: "success"
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(order.validDays) + "天", 1)
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          createElementVNode("p", _hoisted_20, [
                            createVNode(_component_el_text, {
                              size: "large",
                              type: "danger"
                            }, {
                              default: withCtx(() => [
                                createTextVNode("￥ " + toDisplayString(order.totalAmount), 1)
                              ]),
                              _: 2
                            }, 1024)
                          ])
                        ]),
                        createVNode(_component_el_image, {
                          style: { "width": "100px", "height": "100px" },
                          src: "data:image/png;base64," + order.qrCodeBase64,
                          fit: "fill"
                        }, {
                          error: withCtx(() => [
                            _hoisted_21
                          ]),
                          _: 2
                        }, 1032, ["src"]),
                        createElementVNode("div", _hoisted_22, [
                          createElementVNode("div", null, [
                            createTextVNode(" 提供能力: "),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(order.tags, (tag) => {
                              return openBlock(), createBlock(_component_el_tag, {
                                style: { "margin": "10px" },
                                key: tag,
                                type: randomStyle(),
                                size: "large",
                                effect: "light"
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(tag), 1)
                                ]),
                                _: 2
                              }, 1032, ["type"]);
                            }), 128))
                          ]),
                          createElementVNode("div", null, [
                            createElementVNode("span", _hoisted_23, toDisplayString(order.desc), 1)
                          ])
                        ])
                      ], 4);
                    }), 128))
                  ])) : createCommentVNode("", true)
                ]),
                _: 1
              }, 8, ["modelValue"])
            ], 64);
          };
        }
      });
      const AiJob = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-382b5e09"]]);
      const _hoisted_1$3 = { style: { "display": "flex", "margin-top": "10px" } };
      const _hoisted_2$1 = { style: { "display": "flex", "margin-top": "10px" } };
      const _hoisted_3 = { style: { "display": "flex" } };
      const _hoisted_4 = { style: { "display": "flex" } };
      const _hoisted_5 = { style: { "display": "flex", "height": "40px" } };
      const _hoisted_6 = { style: { "display": "flex", "margin-bottom": "10px" } };
      const _hoisted_7 = { style: { "display": "flex", "margin-top": "10px" } };
      const _sfc_main$5 = /* @__PURE__ */ defineComponent({
        __name: "Preference",
        setup(__props) {
          const axios2 = inject("$axios");
          const userStore = UserStore();
          const ruleFormRef = ref();
          const validateEmail = (rule, value, callback) => {
            if (value === "") {
              callback(new Error("请输入邮箱"));
            } else if (!/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(value)) {
              callback(new Error("请输入正确的邮箱"));
            } else {
              callback();
            }
          };
          const rules2 = reactive({
            phone: [{ required: true, message: "请输入手机号；作为偏好设置唯一键", trigger: "blur" }],
            email: [{
              required: true,
              message: "请输入邮件地址；将通过邮件通知您投递进度",
              validator: validateEmail,
              trigger: "blur"
            }]
          });
          const submitForm = async (formEl) => {
            if (!loginInterceptor()) {
              return;
            }
            if (!formEl)
              return;
            if (!userStore.user.phone || !userStore.user.email) {
              ElMessage({
                message: "请填写手机号或邮箱",
                type: "error",
                duration: 2e3
              });
            }
            let valid = await formEl.validate((valid2, fields) => {
              return valid2;
            });
            if (!valid) {
              return;
            }
            await axios2.post("/api/user/save/preference", {
              ...userStore.user,
              aiSeatStatus: userStore.user.aiSeatStatus ? 1 : 0
            }).then((resp) => {
              ElMessage({
                message: "偏好设置保存成功",
                type: "success",
                duration: 2e3
              });
            });
          };
          const resetForm = (formEl) => {
            if (!formEl)
              return;
            userStore.user.email = "";
            userStore.user.preference = {};
          };
          const firstFile = ref(null);
          const uploadData = {
            securityId: document.querySelectorAll(".job-card-wrapper")[0].__vue__.data.securityId,
            // securityId: BossOption.bossUserInfoMap?.values()?.next()?.value.securityId,
            source: "chat_file"
          };
          const beforeUpload = (file) => {
            firstFile.value = file;
            return true;
          };
          const handleUploadSuccess = async (response) => {
            userStore.user.preference.cI = response.zpData.url + "===" + response.zpData.tinyUrl;
            ElMessage({
              message: "图片简历上传成功；点击下方保存偏好设置可持久保存",
              type: "success",
              duration: 3e3
            });
          };
          const isGenerating = ref(false);
          function debounceImmediate(func, wait) {
            let timeout = null;
            return (...args) => {
              if (!timeout) {
                func(...args);
              }
              if (timeout !== null) {
                clearTimeout(timeout);
                ElNotification({
                  message: "请勿频繁点击，请等待",
                  type: "warning",
                  duration: 1e3
                });
              }
              timeout = window.setTimeout(() => {
                timeout = null;
              }, wait);
            };
          }
          const generateGreet = debounceImmediate(async () => {
            if (isGenerating.value)
              return;
            isGenerating.value = true;
            try {
              const response = await axios2.post("/api/job/ai/assistant/generate/greeting", {}, { timeout: 3e4 });
              userStore.user.preference.cg = response.data.data;
              ElNotification({
                message: "招呼语生成成功，请点击下方保存偏好设置",
                type: "success",
                duration: 2e3
              });
            } catch (error) {
              ElNotification({
                title: "AI招呼语生成失败",
                message: error,
                type: "error",
                duration: 3e3
              });
            } finally {
              isGenerating.value = false;
            }
          }, 15e3);
          return (_ctx, _cache) => {
            const _component_el_text = ElText;
            const _component_el_input = ElInput;
            const _component_el_form_item = ElFormItem;
            const _component_el_checkbox = ElCheckbox;
            const _component_el_option = ElOption;
            const _component_el_select = ElSelect;
            const _component_el_button = ElButton;
            const _component_el_upload = ElUpload;
            const _component_el_tag = ElTag;
            const _component_el_form = ElForm;
            return openBlock(), createBlock(_component_el_form, {
              ref_key: "ruleFormRef",
              ref: ruleFormRef,
              model: unref(userStore).user,
              rules: rules2,
              "label-position": "right",
              "label-width": "auto",
              class: "form-preference",
              size: "large",
              "status-icon": ""
            }, {
              default: withCtx(() => [
                createElementVNode("div", null, [
                  createVNode(_component_el_text, {
                    class: "mx-1 top-title",
                    type: "warning"
                  }, {
                    default: withCtx(() => [
                      createTextVNode("账号信息")
                    ]),
                    _: 1
                  }),
                  createElementVNode("div", _hoisted_1$3, [
                    createVNode(_component_el_form_item, {
                      label: "手机号",
                      prop: "phone",
                      style: { "margin-left": "-6px" }
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_input, {
                          modelValue: unref(userStore).user.phone,
                          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(userStore).user.phone = $event)
                        }, null, 8, ["modelValue"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_form_item, {
                      label: "通知邮箱",
                      prop: "email"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_input, {
                          modelValue: unref(userStore).user.email,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(userStore).user.email = $event)
                        }, null, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  createVNode(_component_el_text, {
                    class: "mx-1 top-title",
                    type: "warning"
                  }, {
                    default: withCtx(() => [
                      createTextVNode("投递设置")
                    ]),
                    _: 1
                  }),
                  createElementVNode("div", _hoisted_2$1, [
                    createVNode(_component_el_form_item, {
                      prop: "companyInclude",
                      style: { "margin-left": "-40px" }
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.cniE,
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(userStore).user.preference.cniE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 公司名包含 ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_select, {
                          modelValue: unref(userStore).user.preference.cni,
                          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(userStore).user.preference.cni = $event),
                          multiple: "",
                          filterable: "",
                          remote: "",
                          "allow-create": "",
                          "default-first-option": "",
                          "reserve-keyword": false,
                          placeholder: "公司名包含",
                          style: { "width": "240px" }
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createElementBlock(Fragment, null, renderList(["请输入公司名"], (item, inx) => {
                              return createVNode(_component_el_option, {
                                key: inx,
                                label: item,
                                value: item
                              }, null, 8, ["label", "value"]);
                            }), 64))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_form_item, {
                      label: "公司名排除",
                      prop: "companyExclude"
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.cneE,
                          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(userStore).user.preference.cneE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 公司名排除    ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_select, {
                          modelValue: unref(userStore).user.preference.cne,
                          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(userStore).user.preference.cne = $event),
                          multiple: "",
                          filterable: "",
                          remote: "",
                          "allow-create": "",
                          "default-first-option": "",
                          "reserve-keyword": false,
                          placeholder: "公司名排除",
                          style: { "width": "240px" }
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createElementBlock(Fragment, null, renderList(["请输入公司名"], (item, inx) => {
                              return createVNode(_component_el_option, {
                                key: inx,
                                label: item,
                                value: item
                              }, null, 8, ["label", "value"]);
                            }), 64))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  createElementVNode("div", _hoisted_3, [
                    createVNode(_component_el_form_item, {
                      label: "工作名包含",
                      style: { "margin-left": "-40px" },
                      prop: "jobNameInclude"
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.jniE,
                          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(userStore).user.preference.jniE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 工作名包含 ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_select, {
                          modelValue: unref(userStore).user.preference.jni,
                          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(userStore).user.preference.jni = $event),
                          multiple: "",
                          filterable: "",
                          remote: "",
                          "allow-create": "",
                          "default-first-option": "",
                          "reserve-keyword": false,
                          placeholder: "工作名包含",
                          style: { "width": "240px" }
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createElementBlock(Fragment, null, renderList(["请输入工作名"], (item, inx) => {
                              return createVNode(_component_el_option, {
                                key: inx,
                                label: item,
                                value: item
                              }, null, 8, ["label", "value"]);
                            }), 64))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_form_item, {
                      label: "工作内容排除",
                      prop: "jobContentExclude"
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.jceE,
                          "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => unref(userStore).user.preference.jceE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 工作内容排除 ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_select, {
                          modelValue: unref(userStore).user.preference.jce,
                          "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => unref(userStore).user.preference.jce = $event),
                          multiple: "",
                          filterable: "",
                          remote: "",
                          "allow-create": "",
                          "default-first-option": "",
                          "reserve-keyword": false,
                          placeholder: "工作内容排除",
                          style: { "width": "240px" }
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createElementBlock(Fragment, null, renderList(["请输入工作内容字符串"], (item, inx) => {
                              return createVNode(_component_el_option, {
                                key: inx,
                                label: item,
                                value: item
                              }, null, 8, ["label", "value"]);
                            }), 64))
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  createElementVNode("div", _hoisted_4, [
                    createElementVNode("div", _hoisted_5, [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.srE,
                        "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => unref(userStore).user.preference.srE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createVNode(_component_el_input, {
                        class: "input-opt",
                        modelValue: unref(userStore).user.preference.sr,
                        "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => unref(userStore).user.preference.sr = $event),
                        style: { "width": "324px" },
                        placeholder: "薪资范围 例:9-15"
                      }, {
                        prepend: withCtx(() => [
                          createVNode(_component_el_select, {
                            modelValue: unref(userStore).user.preference.srT,
                            "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => unref(userStore).user.preference.srT = $event),
                            placeholder: "月薪(k)",
                            style: { "width": "100px" }
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_option, {
                                label: "月薪(k)",
                                value: "1"
                              }),
                              createVNode(_component_el_option, {
                                label: "日薪",
                                value: "2"
                              })
                            ]),
                            _: 1
                          }, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["modelValue"])
                    ]),
                    createVNode(_component_el_form_item, {
                      label: "公司规模范围",
                      prop: "jobContentExclude",
                      style: { "margin-left": "0" }
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_checkbox, {
                          modelValue: unref(userStore).user.preference.csrE,
                          "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => unref(userStore).user.preference.csrE = $event),
                          label: "",
                          size: "large"
                        }, null, 8, ["modelValue"]),
                        createTextVNode(" 公司规模范围 ")
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_input, {
                          modelValue: unref(userStore).user.preference.csr,
                          "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => unref(userStore).user.preference.csr = $event),
                          placeholder: "公司规模范围 例:10-5000",
                          style: { "width": "242px" }
                        }, null, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  createVNode(_component_el_form_item, {
                    label: "发送自定义招呼语",
                    prop: "jobContentExclude"
                  }, {
                    label: withCtx(() => [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.cgE,
                        "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => unref(userStore).user.preference.cgE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createTextVNode(" 发送自定义招呼语 ")
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_el_input, {
                        type: "textarea",
                        modelValue: unref(userStore).user.preference.cg,
                        "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => unref(userStore).user.preference.cg = $event)
                      }, null, 8, ["modelValue"]),
                      createVNode(_component_el_button, {
                        size: "small",
                        type: "primary",
                        onClick: unref(generateGreet),
                        disabled: isGenerating.value
                      }, {
                        default: withCtx(() => [
                          createTextVNode("AI生成招呼语")
                        ]),
                        _: 1
                      }, 8, ["onClick", "disabled"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_form_item, {
                    label: "发送图片简历",
                    prop: "jobContentExclude",
                    class: "form-item-upload",
                    style: { "margin-left": "0" }
                  }, {
                    label: withCtx(() => [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.cIE,
                        "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => unref(userStore).user.preference.cIE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createTextVNode(" 发送图片简历        ")
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_el_upload, {
                        action: "https://www.zhipin.com/wapi/zpupload/image/uploadSingle",
                        "before-upload": beforeUpload,
                        "on-success": handleUploadSuccess,
                        "show-file-list": false,
                        data: uploadData,
                        headers: { "Zp_token": unref(Tools).getCookieValue("bst") }
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_button, {
                            size: "small",
                            type: "primary"
                          }, {
                            default: withCtx(() => [
                              createTextVNode("选择图片简历")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["headers"]),
                      unref(userStore).user.preference.cI ? (openBlock(), createBlock(_component_el_tag, {
                        key: 0,
                        type: "success",
                        size: "small",
                        style: { "margin-left": "5px" }
                      }, {
                        default: withCtx(() => [
                          createTextVNode("已上传")
                        ]),
                        _: 1
                      })) : createCommentVNode("", true)
                    ]),
                    _: 1
                  }),
                  createElementVNode("div", _hoisted_6, [
                    createVNode(_component_el_checkbox, {
                      modelValue: unref(userStore).user.preference.fhE,
                      "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => unref(userStore).user.preference.fhE = $event),
                      label: "",
                      size: "large"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("过滤猎头")
                      ]),
                      _: 1
                    }, 8, ["modelValue"])
                  ]),
                  createVNode(_component_el_text, {
                    class: "mx-1 top-title",
                    type: "warning"
                  }, {
                    default: withCtx(() => [
                      createTextVNode("交互设置")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_form_item, {
                    label: "预测问题",
                    prop: "jobContentExclude",
                    style: { "margin-top": "10px" }
                  }, {
                    label: withCtx(() => [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.ppE,
                        "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => unref(userStore).user.preference.ppE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createTextVNode(" 预设问题               ")
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_el_input, {
                        type: "textarea",
                        modelValue: unref(userStore).user.preference.pp,
                        "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => unref(userStore).user.preference.pp = $event)
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_form_item, {
                    label: "拒绝挽留",
                    prop: "jobContentExclude"
                  }, {
                    label: withCtx(() => [
                      createVNode(_component_el_checkbox, {
                        modelValue: unref(userStore).user.preference.rfE,
                        "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => unref(userStore).user.preference.rfE = $event),
                        label: "",
                        size: "large"
                      }, null, 8, ["modelValue"]),
                      createTextVNode(" 拒绝挽留               ")
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_el_input, {
                        type: "textarea",
                        modelValue: unref(userStore).user.preference.rf,
                        "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => unref(userStore).user.preference.rf = $event)
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_text, {
                    class: "mx-1 top-title",
                    type: "warning"
                  }, {
                    default: withCtx(() => [
                      createTextVNode("邮件通知")
                    ]),
                    _: 1
                  }),
                  createElementVNode("div", _hoisted_7, [
                    createVNode(_component_el_checkbox, {
                      modelValue: unref(userStore).user.preference.ermE,
                      "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => unref(userStore).user.preference.ermE = $event),
                      label: "",
                      size: "large"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("每轮交流邮件通知 ")
                      ]),
                      _: 1
                    }, 8, ["modelValue"]),
                    createVNode(_component_el_checkbox, {
                      modelValue: unref(userStore).user.preference.crE,
                      "onUpdate:modelValue": _cache[24] || (_cache[24] = ($event) => unref(userStore).user.preference.crE = $event),
                      label: "",
                      size: "large"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_text, {
                          class: "mx-1",
                          type: "danger"
                        }, {
                          default: withCtx(() => [
                            createTextVNode("高意向邮件通知")
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["modelValue"]),
                    createVNode(_component_el_form_item, {
                      label: "对话聊天轮数",
                      prop: "crC"
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_el_text, {
                          class: "mx-1",
                          type: "primary",
                          style: { "margin-top": "5px" }
                        }, {
                          default: withCtx(() => [
                            createTextVNode("对话轮数 >=")
                          ]),
                          _: 1
                        })
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_el_text, {
                          class: "mx-1",
                          type: "primary",
                          style: { "margin-top": "5px" }
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              type: "number",
                              style: { "width": "50px" },
                              size: "small",
                              modelValue: unref(userStore).user.preference.crC,
                              "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => unref(userStore).user.preference.crC = $event)
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, {
                          label: "对话聊天轮数关键字",
                          prop: "crC",
                          style: { "margin-left": "0", "margin-top": "3px" }
                        }, {
                          label: withCtx(() => [
                            createVNode(_component_el_text, {
                              class: "mx-1",
                              type: "primary"
                            }, {
                              default: withCtx(() => [
                                createTextVNode("OR   包含关键字")
                              ]),
                              _: 1
                            })
                          ]),
                          default: withCtx(() => [
                            createVNode(_component_el_select, {
                              modelValue: unref(userStore).user.preference.crK,
                              "onUpdate:modelValue": _cache[26] || (_cache[26] = ($event) => unref(userStore).user.preference.crK = $event),
                              multiple: "",
                              filterable: "",
                              remote: "",
                              "allow-create": "",
                              "default-first-option": "",
                              "reserve-keyword": false,
                              placeholder: "包含关键字",
                              style: { "min-width": "200px", "width": "100%" }
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createElementBlock(Fragment, null, renderList(["请输入包含关键字"], (item, inx) => {
                                  return createVNode(_component_el_option, {
                                    key: inx,
                                    label: item,
                                    value: item
                                  }, null, 8, ["label", "value"]);
                                }), 64))
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  createVNode(_component_el_form_item, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_button, {
                        type: "primary",
                        onClick: _cache[27] || (_cache[27] = ($event) => submitForm(ruleFormRef.value))
                      }, {
                        default: withCtx(() => [
                          createTextVNode("保存偏好设置")
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_button, {
                        onClick: _cache[28] || (_cache[28] = ($event) => resetForm(ruleFormRef.value))
                      }, {
                        default: withCtx(() => [
                          createTextVNode("清除偏好设置")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 1
            }, 8, ["model", "rules"]);
          };
        }
      });
      const Preference = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-7741ec68"]]);
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        __name: "RunRecord",
        setup(__props) {
          const logRecorder = new LogRecorder();
          const logs = ref([]);
          const currentPage = ref(1);
          const pageSize = ref(10);
          const totalLogs = ref(0);
          const filter = ref({
            timeRange: [],
            // 时间范围，数组：[开始时间, 结束时间]
            level: "",
            // 日志级别
            keyword: ""
            // 日志内容关键字
          });
          const fetchLogs = () => {
            var _a;
            let allLogs = logRecorder.getLogs(1, logRecorder.getLogCount());
            if (((_a = filter.value.timeRange) == null ? void 0 : _a.length) === 2) {
              const [start, end] = filter.value.timeRange.map(
                (time) => time.toTimeString().slice(0, 6) + "00"
                // 转为 'HH:mm' 格式字符串
              );
              allLogs = allLogs.filter((log) => {
                const logTime = log.timestamp;
                return logTime >= start && logTime <= end;
              });
            }
            if (filter.value.level) {
              allLogs = allLogs.filter((log) => log.level === filter.value.level);
            }
            if (filter.value.keyword) {
              const keyword = filter.value.keyword.toLowerCase();
              allLogs = allLogs.filter((log) => log.message.toLowerCase().includes(keyword));
            }
            totalLogs.value = allLogs.length;
            const startIndex = (currentPage.value - 1) * pageSize.value;
            logs.value = allLogs.slice(startIndex, startIndex + pageSize.value);
          };
          const handlePageChange = (page) => {
            currentPage.value = page;
            fetchLogs();
          };
          watch(filter, () => {
            currentPage.value = 1;
            fetchLogs();
          }, { deep: true });
          onMounted(() => {
            fetchLogs();
          });
          return (_ctx, _cache) => {
            const _component_el_time_picker = ElTimePicker;
            const _component_el_col = ElCol;
            const _component_el_option = ElOption;
            const _component_el_select = ElSelect;
            const _component_el_input = ElInput;
            const _component_el_row = ElRow;
            const _component_el_table_column = ElTableColumn;
            const _component_el_empty = ElEmpty;
            const _component_el_table = ElTable;
            const _component_el_pagination = ElPagination;
            return openBlock(), createElementBlock("div", null, [
              createVNode(_component_el_row, {
                gutter: 20,
                class: "filter-bar"
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_col, { span: 8 }, {
                    default: withCtx(() => [
                      createVNode(_component_el_time_picker, {
                        modelValue: filter.value.timeRange,
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => filter.value.timeRange = $event),
                        "is-range": "",
                        "start-placeholder": "开始时间",
                        "end-placeholder": "结束时间",
                        format: "HH:mm",
                        clearable: "",
                        style: { "width": "100%" }
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_col, { span: 8 }, {
                    default: withCtx(() => [
                      createVNode(_component_el_select, {
                        modelValue: filter.value.level,
                        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => filter.value.level = $event),
                        placeholder: "请选择日志级别",
                        style: { "width": "100%" }
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_option, {
                            label: "全部",
                            value: ""
                          }),
                          createVNode(_component_el_option, {
                            label: "Error",
                            value: "error"
                          }),
                          createVNode(_component_el_option, {
                            label: "Warn",
                            value: "warn"
                          }),
                          createVNode(_component_el_option, {
                            label: "Info",
                            value: "info"
                          }),
                          createVNode(_component_el_option, {
                            label: "Debug",
                            value: "debug"
                          }),
                          createVNode(_component_el_option, {
                            label: "Trace",
                            value: "trace"
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_col, { span: 8 }, {
                    default: withCtx(() => [
                      createVNode(_component_el_input, {
                        modelValue: filter.value.keyword,
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => filter.value.keyword = $event),
                        placeholder: "请输入日志内容",
                        clearable: "",
                        style: { "width": "100%" }
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_el_table, {
                data: logs.value,
                style: { "width": "100%", "min-height": "440px" }
              }, {
                empty: withCtx(() => [
                  createVNode(_component_el_empty, { description: "暂无日志数据" })
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_table_column, {
                    prop: "timestamp",
                    label: "时间",
                    width: "120"
                  }),
                  createVNode(_component_el_table_column, {
                    prop: "level",
                    label: "级别",
                    width: "100"
                  }),
                  createVNode(_component_el_table_column, {
                    prop: "message",
                    label: "内容"
                  })
                ]),
                _: 1
              }, 8, ["data"]),
              createVNode(_component_el_pagination, {
                onCurrentChange: handlePageChange,
                "current-page": currentPage.value,
                "page-size": pageSize.value,
                total: totalLogs.value,
                background: "",
                layout: "prev, pager, next"
              }, null, 8, ["current-page", "page-size", "total"])
            ]);
          };
        }
      });
      const RunRecord = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-fc9f5b4e"]]);
      const _hoisted_1$2 = { class: "markdown-body" };
      const _hoisted_2 = /* @__PURE__ */ createStaticVNode('<h2>AI工作猎手</h2><br><ul><li><strong><code class="">找工作，用AI工作猎手！让AI帮您找工作！</code></strong> AI坐席：【DeepSeek+ChatGpt】赋能，ai助理作为您的求职者分身24小时 * 7在线找工作，并结合您的简历信息定制化回复。批量投递，自动发送简历，交换联系方式。hr拒绝挽留。高意向邮件通知，让您不错过每一份工作机会。 <br></li></ul><hr><br><h3>AI坐席</h3><ul><li>- 让AI作为您的求职者分身，帮助您快速找到工作。</li><li>- 智能回复HR的消息,结合您的简历信息进行定制化回答。</li><li>- 预设问题支持，根据场景只能匹配您的预设问题，进行智能回答。</li><li>- AI快捷回复发送简历，交换 wx、联系方式。</li><li>- HR拒绝挽留，当hr拒绝您时，可触发拒绝挽留。主动发送简历，并发送自定义的挽留语。</li></ul><br><h3>工作通知</h3><ul><li>- 支持AI坐席与HR的每轮沟通，发送邮件通知。</li><li>- 高意向职位邮件通知，通过设置的关键字或者对话轮数，发送高意向职位的通知。</li></ul><br><h3>投递工具</h3><ul><li>- 批量投递简历。自定义单次投递数量。</li><li>- 发送自定义招呼语，充分展现您的优势。</li><li>- 投递后发送图片简历，绕开发送附件简历需要HR同意机制，直接触达。</li><li>- 自定义筛选过滤，根据您的需求筛选公司，职位，薪资…。</li></ul><br><h3>AI坐席使用</h3><ul><li>- 购买ai坐席之后，可在AI助手中开启全局AI坐席功能。</li><li>- 开启全局AI坐席功能后，HR的消息将会自动转发给AI坐席进行智能回复。</li><li>- 可随时打断AI坐席的回复，当在web端或app端自己回复HR之后，当前会话的AI坐席将会自动停止。</li><li>- 停止后，可在web端的消息列表页面中点击【重启当前会话AI坐席】按钮，重新开启当前会话的AI坐席。</li><li>- 也可在web端通过快捷指令【start】输入到聊天框并发送，开启当前会话的AI坐席。boss端并不会收到当前消息。</li><li>- 当hr拒绝您时，可触发拒绝挽留。主动发送简历，并发送自定义的挽留语。</li><li>- 当hr通过boss向你交换联系方式时，ai助手自动交换。</li><li>- 可在偏好设置中设置预设问题，ai坐席根据场景智能匹配您的预设问题，进行智能回答。</li></ul><br><h3>视频教程</h3><ul><li>- 点击下方链接观看视频教程。</li><li>- <a href="https://www.bilibili.com/video/BV1HKAyebESp" target="_blank">AI工作猎手使用教程</a></li></ul><h3>常见问题</h3><ul><li>- 在boss更新简历之后，请重新导入简历。</li><li>- 脚本未运行，请尝试刷新页面。</li><li>- ai回复需要一定时间，请耐心等待。</li></ul><hr>', 22);
      const _hoisted_24 = [
        _hoisted_2
      ];
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        __name: "UseDocument",
        setup(__props, { expose: __expose }) {
          __expose({ frontmatter: { "title": "使用文档", "date": "2021-08-11T02:17:52.000Z", "draft": false, "weight": 1 }, excerpt: void 0 });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$2, _hoisted_24);
          };
        }
      });
      const _hoisted_1$1 = { class: "markdown-container" };
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        __name: "UseDocument",
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$1, [
              createVNode(unref(_sfc_main$3))
            ]);
          };
        }
      });
      const ReadMe = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-65b48a9b"]]);
      const _hoisted_1 = { class: "show-component" };
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "Panel",
        setup(__props) {
          const showComponent = shallowRef(AiJob);
          const componentMap = /* @__PURE__ */ new Map();
          componentMap.set("1", { component: AiJob, name: "AI 助手" });
          componentMap.set("2", { component: Preference, name: "偏好设置" });
          componentMap.set("3", { component: RunRecord, name: "运行记录" });
          componentMap.set("4", { component: ReadMe, name: "使用文档" });
          const handleSelect = (key, keyPath) => {
            var _a;
            showComponent.value = (_a = componentMap.get(key)) == null ? void 0 : _a.component;
          };
          return (_ctx, _cache) => {
            const _component_el_menu_item = ElMenuItem;
            const _component_el_menu = ElMenu;
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(_component_el_menu, {
                "default-active": "1",
                class: "el-menu-demo",
                mode: "horizontal",
                onSelect: handleSelect
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(componentMap).entries(), ([key, value]) => {
                    return openBlock(), createBlock(_component_el_menu_item, {
                      index: key,
                      key
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(value.name), 1)
                      ]),
                      _: 2
                    }, 1032, ["index"]);
                  }), 128))
                ]),
                _: 1
              }),
              createElementVNode("div", _hoisted_1, [
                (openBlock(), createBlock(resolveDynamicComponent(showComponent.value)))
              ])
            ], 64);
          };
        }
      });
      const Panel = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-7e162cfe"]]);
      const _sfc_main = exports("default", /* @__PURE__ */ defineComponent({
        __name: "BossJobList",
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Panel);
          };
        }
      }));

    })
  };
}));

System.register("./el-button-BjSbSE-J-CBPRPyOw.js", ['vue'], (function (exports, module) {
  'use strict';
  var ref, defineComponent, computed, openBlock, createElementBlock, mergeProps, unref, renderSlot, createBlock, resolveDynamicComponent, withCtx, Fragment, normalizeClass, createCommentVNode, provide, reactive, toRef, watch, warn, inject, onMounted, onUnmounted, useSlots, Text, getCurrentScope, onScopeDispose, readonly, createElementVNode, getCurrentInstance, nextTick;
  return {
    setters: [module => {
      ref = module.ref;
      defineComponent = module.defineComponent;
      computed = module.computed;
      openBlock = module.openBlock;
      createElementBlock = module.createElementBlock;
      mergeProps = module.mergeProps;
      unref = module.unref;
      renderSlot = module.renderSlot;
      createBlock = module.createBlock;
      resolveDynamicComponent = module.resolveDynamicComponent;
      withCtx = module.withCtx;
      Fragment = module.Fragment;
      normalizeClass = module.normalizeClass;
      createCommentVNode = module.createCommentVNode;
      provide = module.provide;
      reactive = module.reactive;
      toRef = module.toRef;
      watch = module.watch;
      warn = module.warn;
      inject = module.inject;
      onMounted = module.onMounted;
      onUnmounted = module.onUnmounted;
      useSlots = module.useSlots;
      Text = module.Text;
      getCurrentScope = module.getCurrentScope;
      onScopeDispose = module.onScopeDispose;
      readonly = module.readonly;
      createElementVNode = module.createElementVNode;
      getCurrentInstance = module.getCurrentInstance;
      nextTick = module.nextTick;
    }],
    execute: (function () {

      exports({
        a8: resolveUnref,
        ab: tryOnScopeDispose,
        ad: identity,
        ae: fromPairs,
        ah: useGlobalConfig,
        ao: useTimeoutFn,
        au: tryOnMounted,
        ay: useThrottleFn,
        h: addUnit,
        q: isNil,
        r: refDebounced
      });

      var _a;
      const isClient = exports("D", typeof window !== "undefined");
      const isDef = exports("aB", (val) => typeof val !== "undefined");
      const isFunction$1 = exports("aA", (val) => typeof val === "function");
      const isString$1 = exports("a9", (val) => typeof val === "string");
      const noop = exports("aa", () => {
      });
      const isIOS = exports("ac", isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent));
      function resolveUnref(r) {
        return typeof r === "function" ? r() : unref(r);
      }
      function createFilterWrapper(filter, fn) {
        function wrapper(...args) {
          return new Promise((resolve, reject) => {
            Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
          });
        }
        return wrapper;
      }
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop;
        };
        const filter = (invoke) => {
          const duration = resolveUnref(ms);
          const maxDuration = resolveUnref(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke());
          }
          return new Promise((resolve, reject) => {
            lastRejector = options.rejectOnCancel ? reject : resolve;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve(invoke());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve(invoke());
            }, duration);
          });
        };
        return filter;
      }
      function throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {
        let lastExec = 0;
        let timer;
        let isLeading = true;
        let lastRejector = noop;
        let lastValue;
        const clear = () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop;
          }
        };
        const filter = (_invoke) => {
          const duration = resolveUnref(ms);
          const elapsed = Date.now() - lastExec;
          const invoke = () => {
            return lastValue = _invoke();
          };
          clear();
          if (duration <= 0) {
            lastExec = Date.now();
            return invoke();
          }
          if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke();
          } else if (trailing) {
            lastValue = new Promise((resolve, reject) => {
              lastRejector = rejectOnCancel ? reject : resolve;
              timer = setTimeout(() => {
                lastExec = Date.now();
                isLeading = true;
                resolve(invoke());
                clear();
              }, Math.max(0, duration - elapsed));
            });
          }
          if (!leading && !timer)
            timer = setTimeout(() => isLeading = true, duration);
          isLeading = false;
          return lastValue;
        };
        return filter;
      }
      function identity(arg) {
        return arg;
      }
      function tryOnScopeDispose(fn) {
        if (getCurrentScope()) {
          onScopeDispose(fn);
          return true;
        }
        return false;
      }
      function useDebounceFn(fn, ms = 200, options = {}) {
        return createFilterWrapper(debounceFilter(ms, options), fn);
      }
      function refDebounced(value, ms = 200, options = {}) {
        const debounced = ref(value.value);
        const updater = useDebounceFn(() => {
          debounced.value = value.value;
        }, ms, options);
        watch(value, () => updater());
        return debounced;
      }
      function useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
        return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn);
      }
      function tryOnMounted(fn, sync = true) {
        if (getCurrentInstance())
          onMounted(fn);
        else if (sync)
          fn();
        else
          nextTick(fn);
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear();
        }
        function start(...args) {
          clear();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, resolveUnref(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      /**
      * @vue/shared v3.4.21
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const NOOP = exports("N", () => {
      });
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      const hasOwn = exports("as", (val, key) => hasOwnProperty.call(val, key));
      const isArray = exports("A", Array.isArray);
      const isDate = exports("aw", (val) => toTypeString(val) === "[object Date]");
      const isFunction = exports("a2", (val) => typeof val === "function");
      const isString = exports("k", (val) => typeof val === "string");
      const isSymbol = exports("i", (val) => typeof val === "symbol");
      const isObject = exports("x", (val) => val !== null && typeof val === "object");
      const isPromise = exports("ar", (val) => {
        return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
      });
      const objectToString = Object.prototype.toString;
      const toTypeString = (value) => objectToString.call(value);
      const toRawType = exports("aq", (value) => {
        return toTypeString(value).slice(8, -1);
      });
      const isPlainObject = exports("at", (val) => toTypeString(val) === "[object Object]");
      const cacheStringFunction = (fn) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
      });
      const hasChanged = exports("aC", (value, oldValue) => !Object.is(value, oldValue));
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function isNil(value) {
        return value == null;
      }
      const isUndefined = exports("R", (val) => val === void 0);
      const isBoolean = exports("j", (val) => typeof val === "boolean");
      const isNumber = exports("G", (val) => typeof val === "number");
      const isEmpty = exports("ak", (val) => !val && val !== 0 || isArray(val) && val.length === 0 || isObject(val) && !Object.keys(val).length);
      const isElement = exports("y", (e) => {
        if (typeof Element === "undefined")
          return false;
        return e instanceof Element;
      });
      const isPropAbsent = exports("al", (prop) => {
        return isNil(prop);
      });
      const isStringNumber = (val) => {
        if (!isString(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = exports("an", (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      });
      const addClass = exports("a4", (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      });
      const removeClass = exports("a5", (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      });
      const getStyle = exports("av", (element, styleName) => {
        var _a2;
        if (!isClient || !element || !styleName)
          return "";
        let key = camelize(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style = element.style[key];
          if (style)
            return style;
          const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e) {
          return element.style[key];
        }
      });
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString(value)) {
          return value;
        }
      }
      /*! Element Plus Icons Vue v2.3.1 */
      var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowDown",
        __name: "arrow-down",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
            })
          ]));
        }
      });
      var arrow_down_default = exports("S", arrow_down_vue_vue_type_script_setup_true_lang_default);
      var arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowLeft",
        __name: "arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_left_default = exports("K", arrow_left_vue_vue_type_script_setup_true_lang_default);
      var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowRight",
        __name: "arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_right_default = exports("L", arrow_right_vue_vue_type_script_setup_true_lang_default);
      var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowUp",
        __name: "arrow-up",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
            })
          ]));
        }
      });
      var arrow_up_default = exports("U", arrow_up_vue_vue_type_script_setup_true_lang_default);
      var calendar_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Calendar",
        __name: "calendar",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
            })
          ]));
        }
      });
      var calendar_default = exports("C", calendar_vue_vue_type_script_setup_true_lang_default);
      var check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Check",
        __name: "check",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
            })
          ]));
        }
      });
      var check_default = exports("a1", check_vue_vue_type_script_setup_true_lang_default);
      var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCheck",
        __name: "circle-check",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
            })
          ]));
        }
      });
      var circle_check_default = exports("a0", circle_check_vue_vue_type_script_setup_true_lang_default);
      var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleClose",
        __name: "circle-close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      });
      var circle_close_default = exports("t", circle_close_vue_vue_type_script_setup_true_lang_default);
      var clock_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Clock",
        __name: "clock",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
            })
          ]));
        }
      });
      var clock_default = exports("B", clock_vue_vue_type_script_setup_true_lang_default);
      var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Close",
        __name: "close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
            })
          ]));
        }
      });
      var close_default = exports("F", close_vue_vue_type_script_setup_true_lang_default);
      var d_arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "DArrowLeft",
        __name: "d-arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
            })
          ]));
        }
      });
      var d_arrow_left_default = exports("Y", d_arrow_left_vue_vue_type_script_setup_true_lang_default);
      var d_arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "DArrowRight",
        __name: "d-arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
            })
          ]));
        }
      });
      var d_arrow_right_default = exports("_", d_arrow_right_vue_vue_type_script_setup_true_lang_default);
      var delete_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Delete",
        __name: "delete",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
            })
          ]));
        }
      });
      var delete_default = exports("a7", delete_vue_vue_type_script_setup_true_lang_default);
      var document_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Document",
        __name: "document",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
            })
          ]));
        }
      });
      var document_default = exports("a6", document_vue_vue_type_script_setup_true_lang_default);
      var full_screen_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "FullScreen",
        __name: "full-screen",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
            })
          ]));
        }
      });
      var full_screen_default = exports("I", full_screen_vue_vue_type_script_setup_true_lang_default);
      var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Hide",
        __name: "hide",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
            })
          ]));
        }
      });
      var hide_default = exports("p", hide_vue_vue_type_script_setup_true_lang_default);
      var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Loading",
        __name: "loading",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
            })
          ]));
        }
      });
      var loading_default = exports("a3", loading_vue_vue_type_script_setup_true_lang_default);
      var minus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Minus",
        __name: "minus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
            })
          ]));
        }
      });
      var minus_default = exports("T", minus_vue_vue_type_script_setup_true_lang_default);
      var more_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "MoreFilled",
        __name: "more-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
            })
          ]));
        }
      });
      var more_filled_default = exports("Z", more_filled_vue_vue_type_script_setup_true_lang_default);
      var more_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "More",
        __name: "more",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96"
            })
          ]));
        }
      });
      var more_default = exports("ap", more_vue_vue_type_script_setup_true_lang_default);
      var plus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Plus",
        __name: "plus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var plus_default = exports("W", plus_vue_vue_type_script_setup_true_lang_default);
      var refresh_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "RefreshLeft",
        __name: "refresh-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
            })
          ]));
        }
      });
      var refresh_left_default = exports("P", refresh_left_vue_vue_type_script_setup_true_lang_default);
      var refresh_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "RefreshRight",
        __name: "refresh-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
            })
          ]));
        }
      });
      var refresh_right_default = exports("Q", refresh_right_vue_vue_type_script_setup_true_lang_default);
      var scale_to_original_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ScaleToOriginal",
        __name: "scale-to-original",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118M512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412M512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512"
            })
          ]));
        }
      });
      var scale_to_original_default = exports("J", scale_to_original_vue_vue_type_script_setup_true_lang_default);
      var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "View",
        __name: "view",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
            })
          ]));
        }
      });
      var view_default = exports("v", view_vue_vue_type_script_setup_true_lang_default);
      var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "WarningFilled",
        __name: "warning-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
            })
          ]));
        }
      });
      var warning_filled_default = exports("$", warning_filled_vue_vue_type_script_setup_true_lang_default);
      var zoom_in_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ZoomIn",
        __name: "zoom-in",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var zoom_in_default = exports("O", zoom_in_vue_vue_type_script_setup_true_lang_default);
      var zoom_out_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ZoomOut",
        __name: "zoom-out",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
            })
          ]));
        }
      });
      var zoom_out_default = exports("M", zoom_out_vue_vue_type_script_setup_true_lang_default);
      const epPropKey = "__epPropKey";
      const definePropType = exports("d", (val) => val);
      const isEpProp = (val) => isObject(val) && !!val[epPropKey];
      const buildProp = exports("b", (prop, key) => {
        if (!isObject(prop) || isEpProp(prop))
          return prop;
        const { values, required, default: defaultValue, type, validator } = prop;
        const _validator = values || validator ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values) {
            allowedValues = Array.from(values);
            if (hasOwn(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator)
            valid || (valid = validator(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type,
          required: !!required,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      });
      const buildProps = exports("a", (props) => fromPairs(Object.entries(props).map(([key, option]) => [
        key,
        buildProp(option, key)
      ])));
      const iconPropType = exports("X", definePropType([
        String,
        Object,
        Function
      ]));
      const CloseComponents = exports("am", {
        Close: close_default
      });
      const ValidateComponentsMap = exports("V", {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      });
      const withInstall = exports("w", (main, extra) => {
        main.install = (app) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      });
      const withNoopInstall = exports("l", (component) => {
        component.install = NOOP;
        return component;
      });
      const componentSizes = exports("ai", ["", "default", "small", "large"]);
      const useDeprecated = exports("H", ({ from, replacement, scope, version, ref: ref2, type = "API" }, condition) => {
        watch(() => unref(condition), (val) => {
        }, {
          immediate: true
        });
      });
      const defaultNamespace = exports("ax", "el");
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = exports("af", (namespaceOverrides) => {
        const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
        const namespace = computed(() => {
          return unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      });
      const useNamespace = exports("c", (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace(namespaceOverrides);
        const b = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b,
          e,
          m,
          be,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      });
      const useProp = (name) => {
        const vm = getCurrentInstance();
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = exports("ag", () => {
        return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      });
      const useId = exports("g", (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      });
      const useSizeProp = exports("z", buildProp({
        type: String,
        values: componentSizes,
        required: false
      }));
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = inject(SIZE_INJECTION_KEY, {});
        return computed(() => {
          return unref(injectedSize.size) || "";
        });
      };
      const configProviderContextKey = Symbol();
      const globalConfig = ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return computed(() => {
            var _a2, _b;
            return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      var _export_sfc = exports("aj", (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      });
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$2 = defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: iconProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("icon");
          const style = computed(() => {
            const { size, color } = props;
            if (!size && !color)
              return {};
            return {
              fontSize: isUndefined(size) ? void 0 : addUnit(size),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("i", mergeProps({
              class: unref(ns).b(),
              style: unref(style)
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__file", "icon.vue"]]);
      const ElIcon = exports("s", withInstall(Icon));
      const formContextKey = exports("f", Symbol("formContextKey"));
      const formItemContextKey = exports("e", Symbol("formItemContextKey"));
      const useFormSize = exports("u", (fallback, ignore = {}) => {
        const emptyRef = ref(void 0);
        const size = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
        return computed(() => size.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      });
      const useFormDisabled = exports("o", (fallback) => {
        const disabled = useProp("disabled");
        const form = inject(formContextKey, void 0);
        return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      });
      const useFormItem = exports("m", () => {
        const form = inject(formContextKey, void 0);
        const formItem = inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      });
      const useFormItemInputId = exports("n", (props, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = ref(false);
        }
        const inputId = ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = computed(() => {
          var _a2;
          return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        onMounted(() => {
          idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
            const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      });
      const buttonGroupContextKey = Symbol("buttonGroupContextKey");
      const useButton = (props, emit) => {
        useDeprecated({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, computed(() => props.type === "text"));
        const buttonGroupContext = inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const { form } = useFormItem();
        const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useFormDisabled();
        const _ref = ref();
        const slots = useSlots();
        const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
        const autoInsertSpace = computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
        });
        const _props = computed(() => {
          if (props.tag === "button") {
            return {
              ariaDisabled: _disabled.value || props.loading,
              disabled: _disabled.value || props.loading,
              autofocus: props.autofocus,
              type: props.nativeType
            };
          }
          return {};
        });
        const shouldAddSpace = computed(() => {
          var _a2;
          const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === Text) {
              const text = slot.children;
              return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(text.trim());
            }
          }
          return false;
        });
        const handleClick = (evt) => {
          if (props.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit("click", evt);
        };
        return {
          _disabled,
          _size,
          _type,
          _ref,
          _props,
          shouldAddSpace,
          handleClick
        };
      };
      const buttonTypes = [
        "default",
        "primary",
        "success",
        "warning",
        "info",
        "danger",
        "text",
        ""
      ];
      const buttonNativeTypes = ["button", "submit", "reset"];
      const buttonProps = buildProps({
        size: useSizeProp,
        disabled: Boolean,
        type: {
          type: String,
          values: buttonTypes,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        nativeType: {
          type: String,
          values: buttonNativeTypes,
          default: "button"
        },
        loading: Boolean,
        loadingIcon: {
          type: iconPropType,
          default: () => loading_default
        },
        plain: Boolean,
        text: Boolean,
        link: Boolean,
        bg: Boolean,
        autofocus: Boolean,
        round: Boolean,
        circle: Boolean,
        color: String,
        dark: Boolean,
        autoInsertSpace: {
          type: Boolean,
          default: void 0
        },
        tag: {
          type: definePropType([String, Object]),
          default: "button"
        }
      });
      const buttonEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      function bound01(n, max) {
        if (isOnePointZero(n)) {
          n = "100%";
        }
        var isPercent = isPercentage(n);
        n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
        if (isPercent) {
          n = parseInt(String(n * max), 10) / 100;
        }
        if (Math.abs(n - max) < 1e-6) {
          return 1;
        }
        if (max === 360) {
          n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
        } else {
          n = n % max / parseFloat(String(max));
        }
        return n;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n) {
        return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") !== -1;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          return "".concat(Number(n) * 100, "%");
        }
        return n;
      }
      function pad2(c) {
        return c.length === 1 ? "0" + c : String(c);
      }
      function rgbToRgb(r, g, b) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b, 255) * 255
        };
      }
      function rgbToHsl(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h = 0;
        var s = 0;
        var l = (max + min) / 2;
        if (max === min) {
          s = 0;
          h = 0;
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h, s, l };
      }
      function hue2rgb(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * (6 * t);
        }
        if (t < 1 / 2) {
          return q;
        }
        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
      }
      function hslToRgb(h, s, l) {
        var r;
        var g;
        var b;
        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);
        if (s === 0) {
          g = l;
          b = l;
          r = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHsv(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h = 0;
        var v = max;
        var d = max - min;
        var s = max === 0 ? 0 : d / max;
        if (max === min) {
          h = 0;
        } else {
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h, s, v };
      }
      function hsvToRgb(h, s, v) {
        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);
        var i = Math.floor(h);
        var f = h - i;
        var p = v * (1 - s);
        var q = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);
        var mod = i % 6;
        var r = [v, q, p, p, t, v][mod];
        var g = [t, v, v, q, p, p][mod];
        var b = [p, p, t, v, v, q][mod];
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHex(r, g, b, allow3Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b, a, allow4Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b).toString(16)),
          pad2(convertDecimalToHex(a))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h) {
        return parseIntFromHex(h) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a = color.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color.format || format,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match = matchers.rgb.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        match = matchers.rgba.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        match = matchers.hsl.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        match = matchers.hsla.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        match = matchers.hsv.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        match = matchers.hsva.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        match = matchers.hex8.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex6.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        match = matchers.hex4.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex3.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = exports("az", (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a2;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R;
            var G;
            var B;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R = RsRGB / 12.92;
            } else {
              R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G = GsRGB / 12.92;
            } else {
              G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B = BsRGB / 12.92;
            } else {
              B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s = this.toHsl().s;
            return s === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h = Math.round(hsv.h * 360);
            var s = Math.round(hsv.s * 100);
            var v = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h = Math.round(hsl.h * 360);
            var s = Math.round(hsl.s * 100);
            var l = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r = Math.round(this.r);
            var g = Math.round(this.g);
            var b = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x) {
              return "".concat(Math.round(bound01(x, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x) {
              return Math.round(bound01(x, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
              var _b = _a2[_i], key = _b[0], value = _b[1];
              if (hex === value) {
                return key;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format) {
            var formatSet = Boolean(format);
            format = format !== null && format !== void 0 ? format : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
            if (needsAlphaFormat) {
              if (format === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p + rgb1.r,
              g: (rgb2.g - rgb1.g) * p + rgb1.g,
              b: (rgb2.b - rgb1.b) * p + rgb1.b,
              a: (rgb2.a - rgb1.a) * p + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h = hsv.h;
            var s = hsv.s;
            var v = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h, s, v }));
              v = (v + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n) {
            var hsl = this.toHsl();
            var h = hsl.h;
            var result = [this];
            var increment = 360 / n;
            for (var i = 1; i < n; i++) {
              result.push(new TinyColor2({ h: (h + i * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      ));
      function darken(color, amount = 20) {
        return color.mix("#141414", amount).toString();
      }
      function useButtonCustomStyle(props) {
        const _disabled = useFormDisabled();
        const ns = useNamespace("button");
        return computed(() => {
          let styles = {};
          const buttonColor = props.color;
          if (buttonColor) {
            const color = new TinyColor(buttonColor);
            const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
            if (props.plain) {
              styles = ns.cssVarBlock({
                "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
                "text-color": buttonColor,
                "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
                "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                "hover-bg-color": buttonColor,
                "hover-border-color": buttonColor,
                "active-bg-color": activeBgColor,
                "active-text-color": `var(${ns.cssVarName("color-white")})`,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
              }
            } else {
              const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
              const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
              styles = ns.cssVarBlock({
                "bg-color": buttonColor,
                "text-color": textColor,
                "border-color": buttonColor,
                "hover-bg-color": hoverBgColor,
                "hover-text-color": textColor,
                "hover-border-color": hoverBgColor,
                "active-bg-color": activeBgColor,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
              }
            }
          }
          return styles;
        });
      }
      const __default__$1 = defineComponent({
        name: "ElButton"
      });
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: buttonProps,
        emits: buttonEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const buttonStyle = useButtonCustomStyle(props);
          const ns = useNamespace("button");
          const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit);
          const buttonKls = computed(() => [
            ns.b(),
            ns.m(_type.value),
            ns.m(_size.value),
            ns.is("disabled", _disabled.value),
            ns.is("loading", props.loading),
            ns.is("plain", props.plain),
            ns.is("round", props.round),
            ns.is("circle", props.circle),
            ns.is("text", props.text),
            ns.is("link", props.link),
            ns.is("has-bg", props.bg)
          ]);
          expose({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
              ref_key: "_ref",
              ref: _ref
            }, unref(_props), {
              class: unref(buttonKls),
              style: unref(buttonStyle),
              onClick: unref(handleClick)
            }), {
              default: withCtx(() => [
                _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"]))
                ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ]),
                  _: 3
                })) : createCommentVNode("v-if", true),
                _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                  key: 2,
                  class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["class", "style", "onClick"]);
          };
        }
      });
      var Button = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__file", "button.vue"]]);
      const buttonGroupProps = {
        size: buttonProps.size,
        type: buttonProps.type
      };
      const __default__ = defineComponent({
        name: "ElButtonGroup"
      });
      const _sfc_main = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: buttonGroupProps,
        setup(__props) {
          const props = __props;
          provide(buttonGroupContextKey, reactive({
            size: toRef(props, "size"),
            type: toRef(props, "type")
          }));
          const ns = useNamespace("button");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(`${unref(ns).b("group")}`)
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main, [["__file", "button-group.vue"]]);
      const ElButton = exports("E", withInstall(Button, {
        ButtonGroup
      }));
      withNoopInstall(ButtonGroup);

    })
  };
}));

System.import("./__entry.js", "./");